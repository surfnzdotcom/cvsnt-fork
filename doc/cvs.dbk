<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book lang="en">
  <bookinfo>
    <title>Concurrent Versions System (cvsnt) __VERSION__</title>
    <releaseinfo>cvsnt __VERSION__</releaseinfo>
    <abstract>
      <para>This info manual describes how to use and administer cvsnt version
      __VERSION__.</para>
    </abstract>
  </bookinfo>

  <chapter id="Overview">
    <title>Overview</title>

    <para><indexterm>
        <primary>Overview</primary>
      </indexterm> This chapter is for people who have never used cvsnt, and
    perhaps have never used version control software before.</para>

    <para>If you are already familiar with cvsnt and are just trying to learn
    a particular feature or remember a certain command, you can probably skip
    everything here.</para>

    <sect1 id="What-is-CVS-">
      <title>What is CVS?</title>

      <para><indexterm>
          <primary>What is CVS?</primary>
        </indexterm><indexterm>
          <primary>Introduction to CVS</primary>
        </indexterm><indexterm>
          <primary>CVS, introduction to</primary>
        </indexterm> cvsnt is a version control system. Using it, you can
      record the history of your source files.</para>

      <para>For example, bugs sometimes creep in when software is modified,
      and you might not detect the bug until a long time after you make the
      modification. With cvsnt, you can easily retrieve old versions to see
      exactly which change caused the bug. This can sometimes be a big
      help.</para>

      <para>You could of course save every version of every file you have ever
      created. This would however waste an enormous amount of disk space.
      cvsnt stores all the versions of a file in a single file in a clever way
      that only stores the differences between versions.</para>

      <para>cvsnt also helps you if you are part of a group of people working
      on the same project. It is all too easy to overwrite each others'
      changes unless you are extremely careful. Some editors, like gnu Emacs,
      try to make sure that the same file is never modified by two people at
      the same time. Unfortunately, if someone is using another editor, that
      safeguard will not work. cvsnt solves this problem by insulating the
      different developers from each other. Every developer works in his own
      directory, and cvsnt merges the work when each developer is done.</para>

      <para><indexterm>
          <primary>History of cvsnt</primary>
        </indexterm><indexterm>
          <primary>cvsnt, history of</primary>
        </indexterm><indexterm>
          <primary>Credits (cvsnt program)</primary>
        </indexterm><indexterm>
          <primary>Contributors (cvsnt program)</primary>
        </indexterm>cvsnt started out as a bunch of shell scripts written by
      Dick Grune, posted to the newsgroup <command>comp.sources.unix</command>
      in the volume 6 release of December, 1986. While no actual code from
      these shell scripts is present in the current version of cvsnt much of
      the cvsnt conflict resolution algorithms come from them.</para>

      <para>In April, 1989, Brian Berliner designed and coded cvs. Jeff Polk
      later helped Brian with the design of the cvs module and vendor branch
      support.</para>

      <para>In December, 1999 Tony Hoyle converted the unix based CVS to run
      under Windows NT. This later became cvsnt, which developed into a
      project of its own.</para>

      <para>CVSNT is now a major project with solid commercial backing, and an
      active support community.</para>

      <para><indexterm>
          <primary>Source, getting cvsnt source</primary>
        </indexterm>You can get cvsnt in a variety of ways, including free
      download from the internet. For more information on downloading cvsnt
      and other cvsnt topics, see:</para>

      <para><screen>http://www.cvsnt.org/
</screen></para>

      <para><indexterm>
          <primary>Mailing list</primary>
        </indexterm><indexterm>
          <primary>List, mailing list</primary>
        </indexterm><indexterm>
          <primary>Newsgroups</primary>
        </indexterm>There is a mailing list, known as
      <command>cvsnt</command>, devoted to cvsnt. To subscribe or unsubscribe
      see: <screen>
http://www.cvsnt.org/mailman/listinfo/cvsnt
news://news.cvsnt.org/support.cvsnt
</screen></para>
    </sect1>

    <sect1 id="What-is-CVS-not-">
      <title>What is CVS not?</title>

      <para><indexterm>
          <primary>What is CVS not?</primary>
        </indexterm> cvsnt can do a lot of things for you, but it does not try
      to be everything for everyone.</para>

      <variablelist>
        <varlistentry>
          <term>cvsnt is not a build system.</term>

          <listitem>
            <para>Though the structure of your repository and modules file
            interact with your build system (e.g.
            <command>Makefile</command>s), they are essentially
            independent.</para>

            <para>cvsnt does not dictate how you build anything. It merely
            stores files for retrieval in a tree structure you devise.</para>

            <para>cvsnt does not dictate how to use disk space in the checked
            out working directories. If you write your
            <command>Makefile</command>s or scripts in every directory so they
            have to know the relative positions of everything else, you wind
            up requiring the entire repository to be checked out.</para>

            <para>If you modularize your work, and construct a build system
            that will share files (via links, mounts, <command>VPATH</command>
            in <command>Makefile</command>s, etc.), you can arrange your disk
            usage however you like.</para>

            <para>But you have to remember that <emphasis>any</emphasis> such
            system is a lot of work to construct and maintain. cvsnt does not
            address the issues involved.</para>

            <para>Of course, you should place the tools created to support
            such a build system (scripts, <command>Makefile</command>s, etc)
            under cvsnt.</para>

            <para>Figuring out what files need to be rebuilt when something
            changes is, again, something to be handled outside the scope of
            cvsnt. One traditional approach is to use <command>make</command>
            for building, and use some automated tool for generating the
            dependencies which <command>make</command> uses.</para>

            <para>See <xref linkend="Builds" />, for more information on doing
            builds in conjunction with cvsnt.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvsnt is not a substitute for management.</term>

          <listitem>
            <para>Your managers and project leaders are expected to talk to
            you frequently enough to make certain you are aware of schedules,
            merge points, branch names and release dates. If they don't, cvsnt
            can't help.</para>

            <para>cvsnt is an instrument for making sources dance to your
            tune. But you are the piper and the composer. No instrument plays
            itself or writes its own music.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvsnt is not a substitute for developer communication.</term>

          <listitem>
            <para>When faced with conflicts within a single file, most
            developers manage to resolve them without too much effort. But a
            more general definition of "conflict" includes problems too
            difficult to solve without communication between
            developers.</para>

            <para>cvsnt cannot determine when simultaneous changes within a
            single file, or across a whole collection of files, will logically
            conflict with one another. Its concept of a
            <firstterm>conflict</firstterm> is purely textual, arising when
            two changes to the same base file are near enough to spook the
            merge (i.e. <command>diff3</command>) command.</para>

            <para>cvsnt does not claim to help at all in figuring out
            non-textual or distributed conflicts in program logic.</para>

            <para>For example: Say you change the arguments to function
            <command>X</command> defined in file <command>A</command>. At the
            same time, someone edits file <command>B</command>, adding new
            calls to function <command>X</command> using the old arguments.
            You are outside the realm of cvsnt's competence.</para>

            <para>Acquire the habit of reading specs and talking to your
            peers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvsnt does not have change control (but it comes close)</term>

          <listitem>
            <para>Change control refers to a number of things. First of all it
            can mean <firstterm>bug-tracking</firstterm>, that is being able
            to keep a database of reported bugs and the status of each one (is
            it fixed? in what release? has the bug submitter agreed that it is
            fixed?). For interfacing cvsnt to an external bug-tracking system,
            see the <command>rcsinfo</command> and
            <command>verifymsg</command> files (<xref
            linkend="Administrative-files" />).</para>

            <para>Another aspect of change control is keeping track of the
            fact that changes to several files were in fact changed together
            as one logical change. If you check in several files in a single
            <command>cvs commit</command> operation, cvsnt marks that commit
            with a session identifier or <command>commitid</command>.</para>

            <para>cvsnt is also able to group a set of commits under a logical
            group by its group identifier, also known as the
            <command>bugid</command>. You can also selectively merge changes
            based on this identifier.</para>

            <para>Another aspect of change control, in some systems, is the
            ability to keep track of the status of each change. Some changes
            have been written by a developer, others have been reviewed by a
            second developer, and so on. Generally, the way to do this with
            cvsnt is to generate a diff (using <command>cvs diff</command> or
            <command>diff</command>) and email it to someone who can then
            apply it using the <command>patch</command> utility. This is very
            flexible, but depends on mechanisms outside cvsnt to make sure
            nothing falls through the cracks.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvsnt is not an automated testing program</term>

          <listitem>
            <para>It is possible to link into automated testing scripts using
            the <command>postcommit</command>and <command>trigger</command>
            functionality. This is outside the scope of this manual
            however.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvsnt does not have a builtin process model</term>

          <listitem>
            <para>Some systems provide ways to ensure that changes or releases
            go through various steps, with various approvals as needed.
            Generally, one can accomplish this with cvsnt but it might be a
            little more work. In some cases you'll want to use the
            <command>commitinfo</command>, <command>loginfo</command>,
            <command>rcsinfo</command>, or <command>verifymsg</command> files,
            to require that certain steps be performed before cvs will allow a
            checkin. Also consider whether features such as branches and tags
            can be used to perform tasks such as doing work in a development
            tree and then merging certain changes over to a stable tree only
            once they have been proven.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="A-sample-session">
      <title>A sample session</title>

      <para><indexterm>
          <primary>Example of a work-session</primary>
        </indexterm><indexterm>
          <primary>Getting started</primary>
        </indexterm><indexterm>
          <primary>Work-session, example of</primary>
        </indexterm><indexterm>
          <primary>tc, Trivial Compiler (example)</primary>
        </indexterm><indexterm>
          <primary>Trivial Compiler (example)</primary>
        </indexterm></para>

      <para>As a way of introducing cvsnt, we'll go through a typical
      work-session using cvsnt. The first thing to understand is that cvsnt
      stores all files in a centralized <firstterm>repository</firstterm>
      (<xref linkend="Repository" />); this section assumes that a repository
      is set up.</para>

      <para>Suppose you are working on a simple compiler. The source consists
      of a handful of C files and a <command>Makefile</command>. The compiler
      is called <command>tc</command> (Trivial Compiler), and the repository
      is set up so that there is a module called <command>tc</command>.</para>

      <sect2 id="Getting-the-source">
        <title>Getting the source</title>

        <para><indexterm>
            <primary>Getting the source</primary>
          </indexterm><indexterm>
            <primary>Checking out source</primary>
          </indexterm><indexterm>
            <primary>Fetching source</primary>
          </indexterm><indexterm>
            <primary>Source, getting from CVS</primary>
          </indexterm><indexterm>
            <primary>Checkout, example</primary>
          </indexterm> The first thing you must do is to get your own working
        copy of the source for <command>tc</command>. For this, you use the
        <command>checkout</command> command:</para>

        <para><screen>$ cvs checkout tc
</screen></para>

        <para>This will create a new directory called <command>tc</command>
        and populate it with the source files (the commands used may be
        slightly different on Windows machines, but the output is the
        same).</para>

        <para><screen>
$ cd tc
$ ls
CVS         Makefile    backend.c   driver.c    frontend.c  parser.c
</screen></para>

        <para>The <command>CVS</command> directory is used internally by cvsnt
        (on Windows clients it is normally hidden). Normally, you should not
        modify or remove any of the files in it.</para>

        <para>You start your favorite editor, hack away at
        <command>backend.c</command>, and a couple of hours later you have
        added an optimization pass to the compiler. A note to rcs and sccs
        users: There is no need to lock the files that you want to edit. <xref
        linkend="Multiple-developers" />, for an explanation.</para>
      </sect2>

      <sect2 id="Committing-your-changes">
        <title>Committing your changes</title>

        <para><indexterm>
            <primary>Committing changes</primary>
          </indexterm><indexterm>
            <primary>Log message entry</primary>
          </indexterm><indexterm>
            <primary>CVSEDITOR, environment variable</primary>
          </indexterm><indexterm>
            <primary>EDITOR, environment variable</primary>
          </indexterm> When you have checked that the compiler is still
        compilable you decide to make a new version of
        <command>backend.c</command>. This will store your new
        <command>backend.c</command> in the repository and make it available
        to anyone else who is using that same repository.</para>

        <para><screen>$ cvs commit backend.c
</screen></para>

        <para>cvsnt starts an editor, to allow you to enter a log message. You
        type in "Added an optimization pass.", save the temporary file, and
        exit the editor.</para>

        <para>The environment variable <command>$CVSEDITOR</command>
        determines which editor is started. If <command>$CVSEDITOR</command>
        is not set, then if the environment variable
        <command>$EDITOR</command> is set, it will be used. If both
        <command>$CVSEDITOR</command> and <command>$EDITOR</command> are not
        set then there is a default which will vary with your operating
        system, for example <command>vi</command> for unix or
        <command>notepad</command> for Windows NT/95.</para>

        <para>When cvsnt starts the editor, it includes a list of files which
        are modified. For the cvsnt client, this list is based on comparing
        the modification time of the file against the modification time that
        the file had when it was last gotten or updated. Therefore, if a
        file's modification time has changed but its contents have not, it
        will show up as modified. The simplest way to handle this is simply
        not to worry about it--if you proceed with the commit cvsnt will
        detect that the contents are not modified and treat it as an
        unmodified file. The next <command>update</command> will clue cvsnt in
        to the fact that the file is unmodified, and it will reset its stored
        timestamp so that the file will not show up in future editor
        sessions.</para>

        <para>If you want to avoid starting an editor you can specify the log
        message on the command line using the <command>-m</command> flag
        instead, like this:</para>

        <para><screen>
$ cvs commit -m "Added an optimization pass" backend.c
</screen></para>
      </sect2>

      <sect2 id="Cleaning-up">
        <title>Cleaning up</title>

        <para><indexterm>
            <primary>Cleaning up</primary>
          </indexterm><indexterm>
            <primary>Working copy, removing</primary>
          </indexterm><indexterm>
            <primary>Removing your working copy</primary>
          </indexterm><indexterm>
            <primary>Releasing your working copy</primary>
          </indexterm> Before you turn to other tasks you decide to remove
        your working copy of tc. One acceptable way to do that is of
        course</para>

        <para><screen>$ cd ..
$ rm -r tc
</screen></para>

        <para>but a better way is to use the <command>release</command>
        command (<xref linkend="release" />):</para>

        <para><screen>
$ cd ..
$ cvs release -d tc
M driver.c
? tc
You have [1] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': n
** `release' aborted by user choice.
</screen></para>

        <para>The <command>release</command> command checks that all your
        modifications have been committed. If history logging is enabled it
        also makes a note in the history file. <xref
        linkend="history-file" />.</para>

        <para>When you use the <command>-d</command> flag with
        <command>release</command>, it also removes your working copy. The
        <command>-f</command> tells cvsnt to also delete unknown files (such
        as object files).</para>

        <para>The <command>release</command> command always finishes by
        telling you how many modified files you have in your working copy of
        the sources, and then asks you for confirmation before deleting any
        files or making any note in the history file.</para>

        <para>You can decide to play it safe and answer <userinput>n
        <keycap>RET</keycap></userinput> when <command>release</command> asks
        for confirmation.</para>
      </sect2>

      <sect2 id="Viewing-differences">
        <title>Viewing differences</title>

        <para><indexterm>
            <primary>Viewing differences</primary>
          </indexterm><indexterm>
            <primary>Diff</primary>
          </indexterm> You do not remember modifying
        <command>driver.c</command>, so you want to see what has happened to
        that file.</para>

        <para><screen>$ cd tc
$ cvs diff driver.c
</screen></para>

        <para>This command runs <command>diff</command> to compare the version
        of <command>driver.c</command> that you checked out with your working
        copy. When you see the output you remember that you added a command
        line option that enabled the optimization pass. You check it in, and
        release the module.</para>

        <para><screen>
$ cvs commit -m "Added an optimization pass" driver.c
Checking in driver.c;
/usr/local/cvsroot/tc/driver.c,v  &lt;--  driver.c
new revision: 1.2; previous revision: 1.1
done
$ cd ..
$ cvs release -d tc
? tc
You have [0] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': y
</screen></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="Repository">
    <title>The Repository</title>

    <para><indexterm>
        <primary>Repository (intro)</primary>
      </indexterm><indexterm>
        <primary>Repository, example</primary>
      </indexterm><indexterm>
        <primary>Layout of repository</primary>
      </indexterm><indexterm>
        <primary>Typical repository</primary>
      </indexterm><indexterm>
        <primary>/usr/local/cvsroot, as example repository</primary>
      </indexterm><indexterm>
        <primary>cvsroot</primary>
      </indexterm> The cvsnt <firstterm>repository</firstterm> stores a
    complete copy of all the files and directories which are under version
    control.</para>

    <para>Normally, you never access any of the files in the repository
    directly. Instead, you use cvsnt commands to get your own copy of the
    files into a <firstterm>working directory</firstterm>, and then work on
    that copy. When you've finished a set of changes, you check (or
    <firstterm>commit</firstterm>) them back into the repository. The
    repository then contains the changes which you have made, as well as
    recording exactly what you changed, when you changed it, and other such
    information. Note that the repository is not a subdirectory of the working
    directory, or vice versa; they should be in separate locations.</para>

    <para><indexterm>
        <primary>:local:, setting up</primary>
      </indexterm>cvsnt can access a repository by a variety of means. It
    might be on the local computer, or it might be on a computer across the
    room or across the world. To distinguish various ways to access a
    repository, the repository name can start with an <firstterm>access
    method</firstterm>. For example, the access method
    <command>:local:</command> means to access a repository directory, so the
    repository <command>:local:/usr/local/cvsroot</command> means that the
    repository is in <command>/usr/local/cvsroot</command> on the computer
    running cvsnt. For information on other access methods, see <xref
    linkend="Remote-repositories" />.</para>

    <para>If the access method is omitted, then if the repository does not
    contain <command>@</command>, then <command>:local:</command> is assumed.
    If it does contain <command>@</command> then <command>:ext:</command> is
    assumed. For example, if you have a local repository in
    <command>/usr/local/cvsroot</command>, you can use
    <command>/usr/local/cvsroot</command> instead of
    <command>:local:/usr/local/cvsroot</command>.</para>

    <para>The repository is split in two parts.
    <command>$CVSROOT/CVSROOT</command> contains administrative files for
    cvsnt. The other directories contain the actual user-defined
    modules.</para>

    <sect1 id="Specifying-a-repository">
      <title>Telling CVS where your repository is</title>

      <para>There are several ways to tell cvsnt where to find the repository.
      You can name the repository on the command line explicitly, with the
      <command>-d</command> (for "directory") option:</para>

      <para><screen>cvs -d /usr/local/cvsroot checkout yoyodyne/tc
</screen></para>

      <para><indexterm>
          <primary>.profile, setting CVSROOT in</primary>
        </indexterm><indexterm>
          <primary>.cshrc, setting CVSROOT in</primary>
        </indexterm><indexterm>
          <primary>.tcshrc, setting CVSROOT in</primary>
        </indexterm><indexterm>
          <primary>.bashrc, setting CVSROOT in</primary>
        </indexterm><indexterm>
          <primary>CVSROOT, environment variable</primary>
        </indexterm> Or you can set the <command>$CVSROOT</command>
      environment variable to an absolute path to the root of the repository,
      <command>/usr/local/cvsroot</command> in this example. To set
      <command>$CVSROOT</command>, <command>csh</command> and
      <command>tcsh</command> users should have this line in their
      <command>.cshrc</command> or <command>.tcshrc</command> files:</para>

      <para><screen>
setenv CVSROOT /usr/local/cvsroot
</screen></para>

      <para><command>sh</command> and <command>bash</command> users should
      instead have these lines in their <command>.profile</command> or
      <command>.bashrc</command>:</para>

      <para><screen>
CVSROOT=/usr/local/cvsroot
export CVSROOT
</screen></para>

      <para>It is common for cvs frontends to set this up automatically. On
      most frontends there will be a dialog box which prompts you for the
      CVSROOT when it is first configured.</para>

      <para><indexterm>
          <primary>Root file, in CVS directory</primary>
        </indexterm><indexterm>
          <primary>CVS/Root file</primary>
        </indexterm> A repository specified with <command>-d</command> will
      override the <command>$CVSROOT</command> environment variable. Once
      you've checked a working copy out from the repository, it will remember
      where its repository is (the information is recorded in the
      <command>CVS/Root</command> file in the working copy).</para>

      <para>The <command>-d</command> option and the
      <command>CVS/Root</command> file both override the
      <command>$CVSROOT</command> environment variable. If
      <command>-d</command> option differs from <command>CVS/Root</command>,
      the former is used. Of course, for proper operation they should be two
      ways of referring to the same repository.</para>
    </sect1>

    <sect1 id="Repository-storage">
      <title>How data is stored in the repository</title>

      <para><indexterm>
          <primary>Repository, how data is stored</primary>
        </indexterm> For most purposes it isn't important
      <emphasis>how</emphasis> cvsnt stores information in the repository. In
      fact, the format has changed in the past, and is likely to change in the
      future. Since in almost all cases one accesses the repository via cvsnt
      commands, such changes need not be disruptive.</para>

      <para>However, in some cases it may be necessary to understand how cvsnt
      stores data in the repository, for example you might need to track down
      cvsnt locks (<xref linkend="Concurrency" />) or you might need to deal
      with the file permissions appropriate for the repository.</para>

      <sect2 id="Repository-files">
        <title>Where files are stored within the repository</title>

        <para>The overall structure of the repository is a directory tree
        corresponding to the directories in the working directory. For
        example, supposing the repository is in</para>

        <para><screen>/usr/local/cvsroot
</screen></para>

        <para>here is a possible directory tree (showing only the
        directories):</para>

        <para><screen>
<wordasword>/usr</wordasword>
 |
 +--<wordasword>local</wordasword>
 |   |
 |   +--<wordasword>cvsroot</wordasword>
 |   |    |
 |   |    +--<wordasword>CVSROOT</wordasword>
          |      (administrative files)
          |
          +--<wordasword>gnu</wordasword>
          |   |
          |   +--<wordasword>diff</wordasword>
          |   |   (source code to gnu diff)
          |   |
          |   +--<wordasword>rcs</wordasword>
          |   |   (source code to rcs)
          |   |
          |   +--<wordasword>cvsnt</wordasword>
          |       (source code to cvsnt)
          |
          +--<wordasword>yoyodyne</wordasword>
              |
              +--<wordasword>tc</wordasword>
              |    |
              |    +--<wordasword>man</wordasword>
              |    |
              |    +--<wordasword>testing</wordasword>
              |
              +--(other Yoyodyne software)
</screen></para>

        <para>With the directories are <firstterm>history files</firstterm>
        for each file under version control. The name of the history file is
        the name of the corresponding file with <command>,v</command> appended
        to the end. Here is what the repository for the
        <command>yoyodyne/tc</command> directory might look like: <screen>
  <command>$CVSROOT</command>
    |
    +--<wordasword>yoyodyne</wordasword>
    |   |
    |   +--<wordasword>tc</wordasword>
    |   |   |
            +--<wordasword>Makefile,v</wordasword>
            +--<wordasword>backend.c,v</wordasword>
            +--<wordasword>driver.c,v</wordasword>
            +--<wordasword>frontend.c,v</wordasword>
            +--<wordasword>parser.c,v</wordasword>
            +--<wordasword>man</wordasword>
            |    |
            |    +--<wordasword>tc.1,v</wordasword>
            |
            +--<wordasword>testing</wordasword>
                 |
                 +--<wordasword>testpgm.t,v</wordasword>
                 +--<wordasword>test2.t,v</wordasword>
</screen></para>

        <para><indexterm>
            <primary>History files</primary>
          </indexterm><indexterm>
            <primary>rcs history files</primary>
          </indexterm>The history files contain, among other things, enough
        information to recreate any revision of the file, a log of all commit
        messages and the user-name of the person who committed the revision.
        The history files are known as <firstterm>rcs files</firstterm>,
        because the first program to store files in that format was a version
        control system known as rcs. For a full description of the file
        format, see the <command>man</command> page
        <citation>rcsfile(5)</citation>, distributed with rcs, or the file
        <command>doc/rcsfile</command> in the cvsnt source distribution. This
        file format has become very common--many systems other than cvsnt or
        rcs can at least import history files in this format.</para>

        <para>The rcs files used in cvs and cvsnt differ in a few ways from
        the standard format. The biggest difference in cvs is magic branches;
        for more information see <xref linkend="Magic-branch-numbers" />. Also
        in cvsnt the valid tag names are a subset of what rcs accepts; for
        cvsnt's rules see <xref linkend="Tags" />. cvsnt also brings binary
        diffs and mergepoints to the table. Future versions of cvsnt may
        introduce still further changes, so it is unwise to try to read (or
        write to) the repository with rcs. cvsnt provides some rcs 'lookalike'
        comands for accessing the repository files.</para>
      </sect2>

      <sect2 id="File-permissions">
        <title>File permissions</title>

        <para><indexterm>
            <primary>Security, file permissions in repository</primary>
          </indexterm><indexterm>
            <primary>File permissions, general</primary>
          </indexterm><indexterm>
            <primary>Permissions, general</primary>
          </indexterm><indexterm>
            <primary>Group</primary>
          </indexterm><indexterm>
            <primary>Read-only files, in repository</primary>
          </indexterm>All <command>,v</command> files are created read-only,
        and you should not change the permission of those files. The
        directories inside the repository should be writable by the persons
        that have permission to modify the files in each directory. On Unix,
        this normally means that you must create a group (see group(5))
        consisting of the persons that are to edit the files in a project, and
        set up the repository so that it is that group that owns the
        directory. On Windows, you must allow write access to the files for
        each user or group that is accessing the repository. If impersonation
        is not enabled, then the repository is always accessed as
        SYSTEM.</para>

        <para>This means that you can only control access to files on a
        per-directory basis using the operating system (however see the <link
        linkend="chacl">chacl</link> and <link linkend="lsacl">lsacl</link>
        commands for a way to do this withing cvsnt itself).</para>

        <para>Note that users must also have write access to check out files,
        because cvsnt needs to create lock files (<xref
        linkend="Concurrency" />).</para>

        <para>Also note that users must have write access to the
        <command>CVSROOT/val-tags</command> file. cvsnt uses it to keep track
        of what tags are valid tag names (it is sometimes updated when tags
        are used, as well as when they are created).</para>

        <para>Normally each rcs file will be owned by the user who last
        checked it in. This has little significance; what really matters is
        who owns the directories. See also <xref
        linkend="Runas-User" />.</para>

        <para><indexterm>
            <primary>CVSUMASK, environment variable (Unix only)</primary>
          </indexterm><indexterm>
            <primary>Umask, for repository files (Unix only)</primary>
          </indexterm>cvsnt tries to set up reasonable file permissions for
        new directories that are added inside the tree, but you must fix the
        permissions manually when a new directory should have different
        permissions than its parent directory. If you set the
        <command>CVSUMASK</command> environment variable that will control the
        file permissions which cvsnt uses in creating directories and/or files
        in the repository. <command>CVSUMASK</command> does not affect the
        file permissions in the working directory; such files have the
        permissions which are typical for newly created files, except that
        sometimes cvsnt creates them read-only (see the sections on watches,
        <xref linkend="Setting-a-watch" />; -r, <xref
        linkend="Global-options" />; or <command>CVSREAD</command>, <xref
        linkend="Environment-variables" />).</para>

        <para>Note that using the client/server cvsnt (<xref
        linkend="Remote-repositories" />), there is no good way to set
        <command>CVSUMASK</command>; the setting on the client machine has no
        effect. If you are connecting with <command>ssh</command>, you can set
        <command>CVSUMASK</command> in <command>.bashrc</command> or
        <command>.cshrc</command>, as described in the documentation for your
        operating system. This behavior might change in future versions of
        cvsnt; do not rely on the setting of <command>CVSUMASK</command> on
        the client having no effect.</para>

        <para>Under Windows NT, because of the way directory permissions work
        on that platform, setting CVSUMASK will have no effect.</para>

        <para>Using remote repositories, you will generally need stricter
        permissions on the cvsroot directory and directories above it in the
        tree; see <xref linkend="Authentication-security" />.</para>

        <para><indexterm>
            <primary>Setuid (Unix only)</primary>
          </indexterm><indexterm>
            <primary>Setgid (Unix only)</primary>
          </indexterm><indexterm>
            <primary>Security, setuid (Unix only)</primary>
          </indexterm>Some operating systems have features which allow a
        particular program to run with the ability to perform operations which
        the caller of the program could not. For example, the set user ID
        (setuid) or set group ID (setgid) features of unix or the installed
        image feature of VMS. cvsnt was not written to use such features and
        therefore attempting to install cvsnt in this fashion will provide
        protection against only accidental lapses; anyone who is trying to
        circumvent the measure will be able to do so, and depending on how you
        have set it up may gain access to more than just cvsnt. You may wish
        to instead consider pserver or sserver. They shares some of the same
        attributes, in terms of possibly providing a false sense of security
        or opening security holes wider than the ones you are trying to fix,
        so read the documentation on pserver security carefully if you are
        considering this option (<xref
        linkend="Authentication-security" />).</para>
      </sect2>

      <sect2 id="Attic">
        <title>The attic</title>

        <para><indexterm>
            <primary>Attic</primary>
          </indexterm> The attic was used in older versions of cvs to store
        files in the branches. Its use has been depreciated since cvsnt
        2.0.15, and cvsnt no longer stores files in the
        <command>Attic</command>. It will, however, read files that have been
        stored in the <command>Attic</command> by previous versions of
        cvs.</para>

        <para><indexterm>
            <primary>Dead state</primary>
          </indexterm>instead. It should not matter from a user point of view
        whether a file is in the attic; cvsnt keeps track of this and looks in
        the attic when it needs to. But in case you want to know, the rule was
        that the rcs file is stored in the attic if and only if the head
        revision on the trunk has state <command>dead</command>. A
        <command>dead</command> state means that file has been removed, or
        never added, for that revision. For example, if you add a file on a
        branch, it will have a trunk revision in <command>dead</command>
        state, and a branch revision in a non-<command>dead</command>
        state.</para>
      </sect2>

      <sect2 id="CVS-in-repository">
        <title>The CVS directory in the repository</title>

        <para><indexterm>
            <primary>CVS directory, in repository</primary>
          </indexterm> <indexterm>
            <primary>fileattr.xml, in repository</primary>
          </indexterm> The <command>CVS</command> directory in each repository
        directory contains information such as file attributes (in a file
        called <command>CVS/fileattr.xml</command>. In the future additional
        files may be added to this directory, so implementations should
        silently ignore additional files.</para>

        <para>The format of the fileattr.xml file is a series of XML entries
        describing the edit state of each file, and any access permissions
        that are current.</para>
      </sect2>

      <sect2 id="Locks">
        <title>CVS locks in the repository</title>

        <para><indexterm>
            <primary>#cvs.rfl, technical details</primary>
          </indexterm><indexterm>
            <primary>#cvs.wfl, technical details</primary>
          </indexterm><indexterm>
            <primary>#cvs.lock, technical details</primary>
          </indexterm><indexterm>
            <primary>Locks, cvs, technical details</primary>
          </indexterm>For an introduction to cvsnt locks focusing on
        user-visible behavior, see <xref linkend="Concurrency" />. The
        following section is aimed at people who are writing tools which want
        to access a cvsnt repository without interfering with other tools
        acessing the same repository. If you find yourself confused by
        concepts described here, like <firstterm>read lock</firstterm>,
        <firstterm>write lock</firstterm>, and
        <firstterm>deadlock</firstterm>, you might consult the literature on
        operating systems or databases.</para>

        <para><indexterm>
            <primary>Filesystem locks (obsolete)</primary>
          </indexterm> cvsnt now uses the <command>LockServer</command> to
        handle lock concurrency in a dynamic way (see <xref
        linkend="Lockserver" />. This following section refers to the obsolete
        filesysem lock method, which may still be in use on some sites.</para>

        <para><indexterm>
            <primary>#cvs.tfl</primary>
          </indexterm>Any file in the repository with a name starting with
        <command>#cvs.rfl.</command> is a read lock. Any file in the
        repository with a name starting with <command>#cvs.wfl</command> is a
        write lock. Old versions of cvsnt (before cvsnt 1.5) also created
        files with names starting with <command>#cvs.tfl</command>, but they
        are not discussed here. The directory <command>#cvs.lock</command>
        serves as a master lock. That is, one must obtain this lock first
        before creating any of the other locks.</para>

        <para>To obtain a readlock, first create the
        <command>#cvs.lock</command> directory. This operation must be atomic
        (which should be true for creating a directory under most operating
        systems). If it fails because the directory already existed, wait for
        a while and try again. After obtaining the
        <command>#cvs.lock</command> lock, create a file whose name is
        <command>#cvs.rfl.</command> followed by information of your choice
        (for example, hostname and process identification number). Then remove
        the <command>#cvs.lock</command> directory to release the master lock.
        Then proceed with reading the repository. When you are done, remove
        the <command>#cvs.rfl</command> file to release the read lock.</para>

        <para>To obtain a writelock, first create the
        <command>#cvs.lock</command> directory, as with a readlock. Then check
        that there are no files whose names start with
        <command>#cvs.rfl.</command>. If there are, remove
        <command>#cvs.lock</command>, wait for a while, and try again. If
        there are no readers, then create a file whose name is
        <command>#cvs.wfl</command> followed by information of your choice
        (for example, hostname and process identification number). Hang on to
        the <command>#cvs.lock</command> lock. Proceed with writing the
        repository. When you are done, first remove the
        <command>#cvs.wfl</command> file and then the
        <command>#cvs.lock</command> directory. Note that unlike the
        <command>#cvs.rfl</command> file, the <command>#cvs.wfl</command> file
        is just informational; it has no effect on the locking operation
        beyond what is provided by holding on to the
        <command>#cvs.lock</command> lock itself.</para>

        <para>Note that each lock (writelock or readlock) only locks a single
        directory in the repository, including <command>Attic</command> and
        <command>CVS</command> but not including subdirectories which
        represent other directories under version control. To lock an entire
        tree, you need to lock each directory (note that if you fail to obtain
        any lock you need, you must release the whole tree before waiting and
        trying again, to avoid deadlocks).</para>

        <para>Note also that cvsnt expects writelocks to control access to
        individual <command>foo,v</command> files. rcs has a scheme where the
        <command>,foo,</command> file serves as a lock, but cvsnt does not
        implement it and so taking out a cvsnt writelock is recommended. See
        the comments at rcs_internal_lockfile in the cvsnt source code for
        further discussion/rationale.</para>
      </sect2>

      <sect2 id="CVSROOT-storage">
        <title>How files are stored in the CVSROOT directory</title>

        <para><indexterm>
            <primary>CVSROOT, storage of files</primary>
          </indexterm> The <command>$CVSROOT/CVSROOT</command> directory
        contains the various administrative files. In some ways this directory
        is just like any other directory in the repository; it contains rcs
        files whose names end in <command>,v</command>, and many of the cvsnt
        commands operate on it the same way. However, there are a few
        differences.</para>

        <para>For each administrative file, in addition to the rcs file, there
        is also a checked out copy of the file. For example, there is an rcs
        file <command>loginfo,v</command> and a file
        <command>loginfo</command> which contains the latest revision
        contained in <command>loginfo,v</command>. When you check in an
        administrative file, cvsnt should print</para>

        <para><screen>cvs commit: Rebuilding administrative file database
</screen></para>

        <para>and update the checked out copy in
        <command>$CVSROOT/CVSROOT</command>. If it does not, there is
        something wrong (<xref linkend="BUGS" />). To add your own files to
        the files to be updated in this fashion, you can add them to the
        <command>checkoutlist</command> administrative file (<xref
        linkend="checkoutlist" />).</para>

        <para><indexterm>
            <primary>modules.db</primary>
          </indexterm><indexterm>
            <primary>modules.pag</primary>
          </indexterm><indexterm>
            <primary>modules.dir</primary>
          </indexterm>By default, the <command>modules</command> file behaves
        as described above. If the modules file is very large, storing it as a
        flat text file may make looking up modules slow (I'm not sure whether
        this is as much of a concern now as when cvsnt first evolved this
        feature; I haven't seen benchmarks). Therefore, by making appropriate
        edits to the cvsnt source code one can store the modules file in a
        database which implements the <command>ndbm</command> interface, such
        as Berkeley db or GDBM. If this option is in use, then the modules
        database will be stored in the files <command>modules.db</command>,
        <command>modules.pag</command>, and/or
        <command>modules.dir</command>.</para>

        <para>For information on the meaning of the various administrative
        files, see <xref linkend="Administrative-files" />.</para>
      </sect2>
    </sect1>

    <sect1 id="Working-directory-storage">
      <title>How data is stored in the working directory</title>

      <para><indexterm>
          <primary>CVS directory, in working directory</primary>
        </indexterm>While we are discussing cvsnt internals which may become
      visible from time to time, we might as well talk about what cvsnt puts
      in the <command>CVS</command> directories in the working directories. As
      with the repository, cvsnt handles this information and one can usually
      access it via cvsnt commands. But in some cases it may be useful to look
      at it, and other programs, such as the <command>jCVS</command> graphical
      user interface or the <command>VC</command> package for emacs, may need
      to look at it. Such programs should follow the recommendations in this
      section if they hope to be able to work with other programs which use
      those files, including future versions of the programs just mentioned
      and the command-line cvsnt client.</para>

      <para>The <command>CVS</command> directory contains several files.
      Programs which are reading this directory should silently ignore files
      which are in the directory but which are not documented here, to allow
      for future expansion.</para>

      <para>The files are stored according to the text file convention for the
      system in question. This means that working directories are not portable
      between systems with differing conventions for storing text files. This
      is intentional, on the theory that the files being managed by cvsnt
      probably will not be portable between such systems either.</para>

      <variablelist>
        <varlistentry>
          <term>Root</term>

          <listitem>
            <para>This file contains the current cvsnt root, as described in
            <xref linkend="Specifying-a-repository" />.</para>

            <para><indexterm>
                <primary>Repository file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Repository file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Repository</term>

          <listitem>
            <para>This file contains the directory within the repository which
            the current directory corresponds with. It can be either an
            absolute pathname or a relative pathname; cvsnt has had the
            ability to read either format since at least version 1.3 or so.
            The relative pathname is relative to the root, and is the more
            sensible approach, but the absolute pathname is quite common and
            implementations should accept either. For example, after the
            command</para>

            <para><screen>cvs -d :local:/usr/local/cvsroot checkout yoyodyne/tc
</screen></para>

            <para><command>Root</command> will contain</para>

            <para><screen>
:local:/usr/local/cvsroot
</screen></para>

            <para>and <command>Repository</command> will contain either</para>

            <para><screen>
/usr/local/cvsroot/yoyodyne/tc
</screen></para>

            <para>or</para>

            <para><screen>
yoyodyne/tc
</screen></para>

            <para>If the particular working directory does not correspond to a
            directory in the repository, then <command>Repository</command>
            should contain <command>CVSROOT/Emptydir</command>.</para>

            <para><indexterm>
                <primary>Entries file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Entries file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Entries</term>

          <listitem>
            <para>This file lists the files and directories in the working
            directory. The first character of each line indicates what sort of
            line it is. If the character is unrecognized, programs reading the
            file should silently skip that line, to allow for future
            expansion.</para>

            <para>If the first character is <command>/</command>, then the
            format is:</para>

            <para><screen>
/<varname>name</varname>/<varname>revision</varname>/<varname>timestamp</varname>[+<varname>conflict</varname>]/<varname>options</varname>/<varname>tagdate</varname>
</screen></para>

            <para>where <command>[</command> and <command>]</command> are not
            part of the entry, but instead indicate that the
            <command>+</command> and conflict marker are optional.
            <varname>name</varname> is the name of the file within the
            directory. <varname>revision</varname> is the revision that the
            file in the working derives from, or <command>0</command> for an
            added file, or <command>-</command> followed by a revision for a
            removed file. <varname>timestamp</varname> is the timestamp of the
            file at the time that cvsnt created it; if the timestamp differs
            with the actual modification time of the file it means the file
            has been modified. It is stored in the format used by the ISO C
            asctime() function (for example, <command>Sun Apr 7 01:29:26
            1996</command>). One may write a string which is not in that
            format, for example, <command>Result of merge</command>, to
            indicate that the file should always be considered to be modified.
            This is not a special case; to see whether a file is modified a
            program should take the timestamp of the file and simply do a
            string compare with <varname>timestamp</varname>. If there was a
            conflict, <varname>conflict</varname> can be set to the
            modification time of the file after the file has been written with
            conflict markers (<xref linkend="Conflicts-example" />). Thus if
            <varname>conflict</varname> is subsequently the same as the actual
            modification time of the file it means that the user has obviously
            not resolved the conflict. <varname>options</varname> contains
            sticky options (for example <command>-kb</command> for a binary
            file). <varname>tagdate</varname> contains <command>T</command>
            followed by a tag name, or <command>D</command> for a date,
            followed by a sticky tag or date. Note that if
            <varname>timestamp</varname> contains a pair of timestamps
            separated by a space, rather than a single timestamp, you are
            dealing with a version of cvsnt earlier than cvsnt 1.5 (not
            documented here).</para>

            <para>The timezone on the timestamp in CVS/Entries (local or
            universal) should be the same as the operating system stores for
            the timestamp of the file itself. For example, on Unix the file's
            timestamp is in universal time (UT), so the timestamp in
            CVS/Entries should be too. On vms, the file's timestamp is in
            local time, so cvsnt on vms should use local time. This rule is so
            that files do not appear to be modified merely because the
            timezone changed (for example, to or from summer time).</para>

            <para>If the first character of a line in
            <command>Entries</command> is <command>D</command>, then it
            indicates a subdirectory. <command>D</command> on a line all by
            itself indicates that the program which wrote the
            <command>Entries</command> file does record subdirectories
            (therefore, if there is such a line and no other lines beginning
            with <command>D</command>, one knows there are no subdirectories).
            Otherwise, the line looks like:</para>

            <para><screen>
D/<varname>name</varname>/<varname>filler1</varname>/<varname>filler2</varname>/<varname>filler3</varname>/<varname>filler4</varname>
</screen></para>

            <para>where <varname>name</varname> is the name of the
            subdirectory, and all the <varname>filler</varname> fields should
            be silently ignored, for future expansion. Programs which modify
            <command>Entries</command> files should preserve these
            fields.</para>

            <para>The lines in the <command>Entries</command> file can be in
            any order.</para>

            <para><indexterm>
                <primary>Entries.Log file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Entries.Log file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Entries.Log</term>

          <listitem>
            <para>This file does not record any information beyond that in
            <command>Entries</command>, but it does provide a way to update
            the information without having to rewrite the entire
            <command>Entries</command> file, including the ability to preserve
            the information even if the program writing
            <command>Entries</command> and <command>Entries.Log</command>
            abruptly aborts. Programs which are reading the
            <command>Entries</command> file should also check for
            <command>Entries.Log</command>. If the latter exists, they should
            read <command>Entries</command> and then apply the changes
            mentioned in <command>Entries.Log</command>. After applying the
            changes, the recommended practice is to rewrite
            <command>Entries</command> and then delete
            <command>Entries.Log</command>. The format of a line in
            <command>Entries.Log</command> is a single character command
            followed by a space followed by a line in the format specified for
            a line in <command>Entries</command>. The single character command
            is <command>A</command> to indicate that the entry is being added,
            <command>R</command> to indicate that the entry is being removed,
            or any other character to indicate that the entire line in
            <command>Entries.Log</command> should be silently ignored (for
            future expansion). If the second character of the line in
            <command>Entries.Log</command> is not a space, then it was written
            by an older version of cvsnt (not documented here).</para>

            <para>Programs which are writing rather than reading can safely
            ignore <command>Entries.Log</command> if they so choose.</para>

            <para><indexterm>
                <primary>Entries.Backup file, in CVS directory</primary>
              </indexterm> <indexterm>
                <primary>CVS/Entries.Backup file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Entries.Backup</term>

          <listitem>
            <para>This is a temporary file. Recommended usage is to write a
            new entries file to <command>Entries.Backup</command>, and then to
            rename it (atomically, where possible) to
            <command>Entries</command>.</para>

            <para><indexterm>
                <primary>Entries.Old file, in CVS directory</primary>
              </indexterm> <indexterm>
                <primary>CVS/Entries.Old file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Entries.Old</term>

          <listitem>
            <para>This is the previous generation of the 'Entries' file. If
            your program modifies the 'Entries' file rename the existing file
            to 'Entries.Old' so that frontends are able to find out what has
            changed.</para>

            <para><indexterm>
                <primary>Entries.Static file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Entries.Static file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Entries.Static</term>

          <listitem>
            <para>The only relevant thing about this file is whether it exists
            or not. If it exists, then it means that only part of a directory
            was gotten and cvsnt will not create additional files in that
            directory. To clear it, use the <command>update</command> command
            with the <command>-d</command> option, which will get the
            additional files and remove
            <command>Entries.Static</command>.</para>

            <para><indexterm>
                <primary>Entries.Extra file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Entries.Static file</primary>
              </indexterm> <indexterm>
                <primary>CVS/Entries.Extra file</primary>
              </indexterm><indexterm>
                <primary>CVS/Entries.Static file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Entries.Extra</term>

          <listitem>
            <para>This holds extra information about the file that was not
            recorded by the original CVS client. If this file exists there is
            a line for each file in the Entries file. The lines can be in any
            order.</para>

            <para>The format of the lines is:</para>

            <para><symbol> /name/saved
            mergepoint/filler1/rcstime/edit_revision/edit_tag/edit_bugid/
            </symbol></para>

            <para>If there are any extra fields after rcstime these should be
            ignored.</para>

            <para>The second field is the saved tag from an update -j, which
            is recorded the next time the file is committed to store the
            mergepoint data.</para>

            <para>The third field is unused (and reserved) at present.</para>

            <para>The fourth field is the last checkin time of the file,
            expressed as a time_t. Do not assume that this value will fit into
            a 32bit variable, as this will cause problems in 2038.</para>

            <para>The fifth, sixth and seventh fields define the revision,
            tag/branch and bug identifier of the last <command>cvs
            edit</command> that was invoked by the client.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Entries.Extra.Old</term>

          <listitem>
            <para><indexterm>
                <primary>Entries.Extra.Old file, in CVS directory</primary>
              </indexterm> <indexterm>
                <primary>CVS/Entries.Extra.Old file</primary>
              </indexterm></para>

            <para>This is the previous generation of the 'Entries.Extra' file.
            If your program modifies the 'Entries' file rename the existing
            file to 'Entries.Extra.Old' so that frontends are able to find out
            what has changed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Rename</term>

          <listitem>
            <para><indexterm>
                <primary>Rename file, in CVS directory</primary>
              </indexterm> <indexterm>
                <primary>CVS/Rename file</primary>
              </indexterm></para>

            <para>This file contains information about any renames that have
            not yet been committed to the repository. The file is stored as
            pairs of filenames within the directory, with a blank meaning
            'removed'.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Tag</term>

          <listitem>
            <para><indexterm>
                <primary>Tag file, in CVS directory</primary>
              </indexterm> <indexterm>
                <primary>CVS/Tag file</primary>
              </indexterm> <indexterm>
                <primary>Sticky tags/dates, per-directory</primary>
              </indexterm> <indexterm>
                <primary>Per-directory sticky tags/dates</primary>
              </indexterm></para>

            <para>This file contains per-directory sticky tags or dates. The
            first character is <command>T</command> for a branch tag,
            <command>N</command> for a non-branch tag, or <command>D</command>
            for a date, or another character to mean the file should be
            silently ignored, for future expansion. This character is followed
            by the tag or date. Note that per-directory sticky tags or dates
            are used for things like applying to files which are newly added;
            they might not be the same as the sticky tags or dates on
            individual files. For general information on sticky tags and
            dates, see <xref linkend="Sticky-tags" />.</para>

            <para>CVSNT also stores the directory revision in this file, as a
            numeric tag.</para>

            <para><indexterm>
                <primary>Notify file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Notify file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notify</term>

          <listitem>
            <para>This file stores notifications (for example, for
            <command>edit</command> or <command>unedit</command>) which have
            not yet been sent to the server. Its format is not yet documented
            here.</para>

            <para><indexterm>
                <primary>Notify.tmp file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Notify.tmp file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notify.tmp</term>

          <listitem>
            <para>This file is to <command>Notify</command> as
            <command>Entries.Backup</command> is to
            <command>Entries</command>. That is, to write
            <command>Notify</command>, first write the new contents to
            <command>Notify.tmp</command> and then (atomically where
            possible), rename it to <command>Notify</command>.</para>

            <para><indexterm>
                <primary>Base directory, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Base directory</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Base</term>

          <listitem>
            <para>If watches are in use, then an <command>edit</command>
            command stores the original copy of the file in the
            <command>Base</command> directory. This allows the
            <command>unedit</command> command to operate even if it is unable
            to communicate with the server.</para>

            <para><indexterm>
                <primary>Template file, in CVS directory</primary>
              </indexterm><indexterm>
                <primary>CVS/Template file</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Template</term>

          <listitem>
            <para>This file contains the template specified by the
            <command>rcsinfo</command> file (<xref linkend="rcsinfo" />). It
            is only used by the client; the non-client/server cvsnt consults
            <command>rcsinfo</command> directly.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="Intro-administrative-files">
      <title>The administrative files</title>

      <para><indexterm>
          <primary>Administrative files (intro)</primary>
        </indexterm><indexterm>
          <primary>Modules file</primary>
        </indexterm><indexterm>
          <primary>CVSROOT, module name</primary>
        </indexterm><indexterm>
          <primary>Defining modules (intro)</primary>
        </indexterm></para>

      <para>The directory <command>$CVSROOT/CVSROOT</command> contains some
      <firstterm>administrative files</firstterm>. <xref
      linkend="Administrative-files" />, for a complete description. You can
      use cvsnt without any of these files, but some commands work better when
      at least the <command>modules</command> file is properly set up.</para>

      <para>The most important of these files is the
      <command>modules</command> file. It defines all modules in the
      repository. This is a sample <command>modules</command> file.</para>

      <para><screen>CVSROOT         CVSROOT
modules         CVSROOT modules
cvs             gnu/cvs
rcs             gnu/rcs
diff            gnu/diff
tc              yoyodyne/tc
</screen></para>

      <para>The <command>modules</command> file is line oriented. In its
      simplest form each line contains the name of the module, whitespace, and
      the directory where the module resides. The directory is a path relative
      to <command>$CVSROOT</command>. The last four lines in the example above
      are examples of such lines.</para>

      <para>The line that defines the module called <command>modules</command>
      uses features that are not explained here. <xref linkend="modules" />,
      for a full explanation of all the available features.</para>

      <para>In many cases the <command>modules2</command> file may be more
      suitable for defining modules. See <xref linkend="modules2" /> for
      details.</para>

      <sect2>
        <title>Editing administrative files</title>

        <para><indexterm>
            <primary>Editing administrative files</primary>
          </indexterm><indexterm>
            <primary>Administrative files, editing them</primary>
          </indexterm> You edit the administrative files in the same way that
        you would edit any other module. Use <command>cvs checkout
        CVSROOT</command> to get a working copy, edit it, and commit your
        changes in the normal way.</para>

        <para>It is possible to commit an erroneous administrative file. You
        can often fix the error and check in a new revision, but sometimes a
        particularly bad error in the administrative file makes it impossible
        to commit new revisions.</para>
      </sect2>
    </sect1>

    <sect1 id="Multiple-repositories">
      <title>Multiple repositories</title>

      <para><indexterm>
          <primary>Multiple repositories</primary>
        </indexterm><indexterm>
          <primary>Repositories, multiple</primary>
        </indexterm><indexterm>
          <primary>Many repositories</primary>
        </indexterm><indexterm>
          <primary>Parallel repositories</primary>
        </indexterm><indexterm>
          <primary>Disjoint repositories</primary>
        </indexterm><indexterm>
          <primary>CVSROOT, multiple repositories</primary>
        </indexterm> In some situations it is a good idea to have more than
      one repository, for instance if you have two development groups that
      work on separate projects without sharing any code. All you have to do
      to have several repositories is to specify the appropriate repository,
      using the <command>CVSROOT</command> environment variable, the
      <command>-d</command> option to cvsnt, or (once you have checked out a
      working directory) by simply allowing cvsnt to use the repository that
      was used to check out the working directory (<xref
      linkend="Specifying-a-repository" />).</para>

      <para>The big advantage of having multiple repositories is that they can
      reside on different servers. With CVS version 1.10, a single command
      cannot recurse into directories from different repositories. With
      development versions of cvsnt, you can check out code from multiple
      servers into your working directory. cvsnt will recurse and handle all
      the details of making connections to as many server machines as
      necessary to perform the requested command. Here is an example of how to
      set up a working directory:</para>

      <para><screen>cvs -d server1:/cvs co dir1
cd dir1
cvs -d server2:/root co sdir
cvs update
</screen></para>

      <para>The <command>cvs co</command> commands set up the working
      directory, and then the <command>cvs update</command> command will
      contact server2, to update the dir1/sdir subdirectory, and server1, to
      update everything else.</para>
    </sect1>

    <sect1 id="Creating-a-repository">
      <title>Creating a repository</title>

      <para><indexterm>
          <primary>Repository, setting up</primary>
        </indexterm><indexterm>
          <primary>Creating a repository</primary>
        </indexterm><indexterm>
          <primary>Setting up a repository</primary>
        </indexterm> To set up a cvsnt repository, first choose the machine
      and disk on which you want to store the revision history of the source
      files. CPU and memory requirements are modest, so most machines should
      be adequate. For details see <xref
      linkend="Server-requirements" />.</para>

      <para>To estimate disk space requirements, if you are importing rcs
      files from another system, the size of those files is the approximate
      initial size of your repository, or if you are starting without any
      version history, a rule of thumb is to allow for the server
      approximately three times the size of the code to be under cvsnt for the
      repository (you will eventually outgrow this, but not for a while). On
      the machines on which the developers will be working, you'll want disk
      space for approximately one working directory for each developer (either
      the entire tree or a portion of it, depending on what each developer
      uses).</para>

      <para>The repository should be accessible (directly or via a networked
      file system) from all machines which want to use cvsnt in server or
      local mode; the client machines need not have any access to it other
      than via the cvsnt protocol. It is not possible to use cvsnt to read
      from a repository which one only has read access to; cvsnt needs to be
      able to create lock files (<xref linkend="Concurrency" />).</para>

      <para><indexterm>
          <primary>init</primary>
        </indexterm>To create a repository, run the <command>cvs
      init</command> command. It will set up an empty repository in the cvsnt
      root specified in the usual way (<xref linkend="Repository" />). For
      example,</para>

      <para><screen>cvs -d /usr/local/cvsroot init
</screen></para>

      <para><command>cvs init</command> is careful to never overwrite any
      existing files in the repository, so no harm is done if you run
      <command>cvs init</command> on an already set-up repository.</para>
    </sect1>

    <sect1 id="Backing-up">
      <title>Backing up a repository</title>

      <para><indexterm>
          <primary>Repository, backing up</primary>
        </indexterm><indexterm>
          <primary>Backing up, repository</primary>
        </indexterm> There is nothing particularly magical about the files in
      the repository; for the most part it is possible to back them up just
      like any other files. However, there are a few issues to
      consider.</para>

      <para><indexterm>
          <primary>Locks, cvs, and backups</primary>
        </indexterm><indexterm>
          <primary>#cvs.rfl, and backups</primary>
        </indexterm>The first is that to be paranoid, one should either not
      use cvsnt during the backup, or have the backup program lock cvsnt while
      doing the backup. To not use cvsnt, you might forbid logins to machines
      which can access the repository, turn off your cvsnt server, or similar
      mechanisms. The details would depend on your operating system and how
      you have cvsnt set up. To lock cvsnt, you would create
      <command>#cvs.rfl</command> locks in each repository directory. See
      <xref linkend="Concurrency" />, for more on cvsnt locks. Having said all
      this, if you just back up without any of these precautions, the results
      are unlikely to be particularly dire. Restoring from backup, the
      repository might be in an inconsistent state, but this would not be
      particularly hard to fix manually.</para>

      <para>When you restore a repository from backup, assuming that changes
      in the repository were made after the time of the backup, working
      directories which were not affected by the failure may refer to
      revisions which no longer exist in the repository. Trying to run cvsnt
      in such directories will typically produce an error message. One way to
      get those changes back into the repository is as follows:</para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Get a new working directory.</para>
        </listitem>

        <listitem>
          <para>Copy the files from the working directory from before the
          failure over to the new working directory (do not copy the contents
          of the <command>CVS</command> directories, of course).</para>
        </listitem>

        <listitem>
          <para>Working in the new working directory, use commands such as
          <command>cvs update</command> and <command>cvs diff</command> to
          figure out what has changed, and then when you are ready, commit the
          changes into the repository.</para>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1 id="Moving-a-repository">
      <title>Moving a repository</title>

      <para><indexterm>
          <primary>Repository, moving</primary>
        </indexterm><indexterm>
          <primary>Moving a repository</primary>
        </indexterm><indexterm>
          <primary>Copying a repository</primary>
        </indexterm> Just as backing up the files in the repository is pretty
      much like backing up any other files, if you need to move a repository
      from one place to another it is also pretty much like just moving any
      other collection of files.</para>

      <para>The main thing to consider is that working directories point to
      the repository. The simplest way to deal with a moved repository is to
      just get a fresh working directory after the move. Of course, you'll
      want to make sure that the old working directory had been checked in
      before the move, or you figured out some other way to make sure that you
      don't lose any changes. If you really do want to reuse the existing
      working directory, it should be possible with manual surgery on the
      <command>CVS/Repository</command> files. You can see <xref
      linkend="Working-directory-storage" />, for information on the
      <command>CVS/Repository</command> and <command>CVS/Root</command> files,
      but unless you are sure you want to bother, it probably isn't worth
      it.</para>
    </sect1>

    <sect1 id="Remote-repositories">
      <title>Remote repositories</title>

      <para><indexterm>
          <primary>Repositories, remote</primary>
        </indexterm><indexterm>
          <primary>Remote repositories</primary>
        </indexterm><indexterm>
          <primary>Client/Server Operation</primary>
        </indexterm><indexterm>
          <primary>Server, CVS</primary>
        </indexterm><indexterm>
          <primary>Remote repositories, port specification</primary>
        </indexterm><indexterm>
          <primary>Repositories, remote, port specification</primary>
        </indexterm><indexterm>
          <primary>Client/Server Operation, port specification</primary>
        </indexterm><indexterm>
          <primary>pserver (client/server connection method), port
          specification</primary>
        </indexterm><indexterm>
          <primary>sspi (client/server connection method), port
          specification</primary>
        </indexterm><indexterm>
          <primary>gserver (client/server connection method), port
          specification</primary>
        </indexterm><indexterm>
          <primary>sserver (client/server connection method), port
          specification</primary>
        </indexterm><indexterm>
          <primary>port, specifying for remote repositories</primary>
        </indexterm> Your working copy of the sources can be on a different
      machine than the repository. Using cvsnt in this manner is known as
      <firstterm>client/server</firstterm> operation. You run cvsnt on a
      machine which can mount your working directory, known as the
      <firstterm>client</firstterm>, and tell it to communicate to a machine
      which can mount the repository, known as the
      <firstterm>server</firstterm>. Generally, using a remote repository is
      just like using a local one, except that the format of the repository
      name is:</para>

      <para><screen>:<varname>method</varname>[;keywords...]:[[<varname>user</varname>][:<varname>password</varname>]@]<varname>hostname</varname>[:[<varname>port</varname>]][:]/path/to/repository
</screen></para>

      <para>Specifying a password in the repository name is not recommended
      during checkout, since this will cause cvsnt to store a cleartext copy
      of the password in each created directory. <command>cvs login</command>
      first instead (<xref linkend="Authentication-client" />).</para>

      <para>With most protocols the username is optional. Your current login
      name will be used in this case. Also, a special username of '.' (dot)
      can be used, and means the same as not specifying a username. This can
      be used for frontends built for older cvs versions which required a
      username to be specified.</para>

      <para>The details of exactly what needs to be set up depend on how you
      are connecting to the server.</para>

      <para>If <varname>method</varname> is not specified, and the repository
      name contains <command>:</command>, then the default is
      <command>ext</command> or <command>server</command>, depending on your
      platform; both are described in <xref
      linkend="Connecting-via-ssh" />.</para>

      <sect2 id="Server-requirements">
        <title>Server requirements</title>

        <para>The quick answer to what sort of machine is suitable as a server
        is that requirements are modest--a server with 32M of memory or even
        less can handle a fairly large source tree with a fair amount of
        activity.</para>

        <para>The real answer, of course, is more complicated. Estimating the
        known areas of large memory consumption should be sufficient to
        estimate memory requirements. There are two such areas documented
        here; other memory consumption should be small by comparison (if you
        find that is not the case, let us know, as described in <xref
        linkend="BUGS" />, so we can update this documentation).</para>

        <para>The first area of big memory consumption is large checkouts,
        when using the cvsnt server. The server consists of two processes for
        each client that it is serving. Memory consumption on the child
        process should remain fairly small. Memory consumption on the parent
        process, particularly if the network connection to the client is slow,
        can be expected to grow to slightly more than the size of the sources
        in a single directory, or two megabytes, whichever is larger.</para>

        <para>Multiplying the size of each cvsnt server by the number of
        servers which you expect to have active at one time should give an
        idea of memory requirements for the server. For the most part, the
        memory consumed by the parent process probably can be swap space
        rather than physical memory.</para>

        <para>The second area of large memory consumption is
        <command>diff</command>, when checking in large files. This is
        required even for binary files. The rule of thumb is to allow about
        ten times the size of the largest file you will want to check in,
        although five times may be adequate. For example, if you want to check
        in a file which is 10 megabytes, you should have 100 megabytes of
        memory on the machine doing the checkin (the server machine for
        client/server, or the machine running cvsnt for non-client/server).
        This can be swap space rather than physical memory. Because the memory
        is only required briefly, there is no particular need to allow memory
        for more than one such checkin at a time.</para>

        <para>Resource consumption for the client is even more modest--any
        machine with enough capacity to run the operating system in question
        should have little trouble.</para>

        <para>For information on disk space requirements, see <xref
        linkend="Creating-a-repository" />.</para>
      </sect2>

      <sect2 id="Connecting-via-ssh">
        <title>Connecting with ssh</title>

        <para><indexterm>
            <primary>ssh</primary>
          </indexterm>cvsnt uses the <command>ssh</command> protocol to
        perform these operations, so the remote user host needs to have a
        <command>.rhosts</command> file which grants access to the local
        user.</para>

        <para>For example, suppose you are the user <command>mozart</command>
        on the local machine <command>toe.example.com</command>, and the
        server machine is <command>faun.example.org</command>. On faun, put
        the following line into the file <command>.rhosts</command> in
        <command>bach</command>'s home directory:</para>

        <para><screen>toe.example.com  mozart
</screen></para>

        <para>Then test that <command>ssh</command> is working with</para>

        <para><screen>
ssh -l bach faun.example.org 'echo $PATH'
</screen></para>

        <para>There is no need to edit <command>inetd.conf</command> or start
        a cvsnt server process.</para>

        <para><indexterm>
            <primary>:ssh:, setting up</primary>
          </indexterm>On some versions of cvsnt :ssh: protocol is available.
        This is a builtin ssh client which integrates cvs authentication with
        ssh security.</para>

        <para>At its simplest, this is used like :pserver:, as in:</para>

        <para><screen>
cvs -d :ssh:user@machine.example.org:/usr/local/cvs login
Password: *****
cvs -d :ssh:user@machine.example.org:/usr/local/cvs co myproject
</screen></para>

        <para>However you can also register your private key with cvs, which
        it will use instead of a password:</para>

        <para><screen>
cvs -d :ssh;key='c:\user.ppk':user@machine.example.org:/usr/local/cvs login
Password: ******** (if your key has no passphrase, just press enter here)
cvs -d :ssh:user@machine.example.org:/usr/local/cvs co myproject
</screen></para>

        <para>The keys should be in the putty private key format. You can use
        PuttyGen to convert an existing Openssh private key to this
        format.</para>

        <para><indexterm>
            <primary>:server:, setting up</primary>
          </indexterm><indexterm>
            <primary>:ext:, setting up</primary>
          </indexterm><indexterm>
            <primary>Kerberos, using kerberized rsh</primary>
          </indexterm><indexterm>
            <primary>ssh replacements (Kerberized RSH, &amp;c)</primary>
          </indexterm><command>:ext:</command> specifies an external ssh
        program. By default this is <command>ssh</command> but you may specify
        another program in the CVSROOT using the optional :ext:{program}
        command. You may alternatively set the <command>CVS_EXT</command>
        environment variable to invoke another program which can access the
        remote server (for example, <command>remsh</command> on HP-UX 9
        because <command>rsh</command> is something different). It must be a
        program which can transmit data to and from the server without
        modifying it</para>

        <para>Continuing our example, supposing you want to access the module
        <command>foo</command> in the repository
        <command>/usr/local/cvsroot/</command>, on machine
        <command>faun.example.org</command>, you are ready to go:</para>

        <para><screen>cvs -d :ext:bach@faun.example.org/usr/local/cvsroot checkout foo</screen></para>

        <para>(The <command>bach@</command> can be omitted if the username is
        the same on both the local and remote hosts.)</para>
      </sect2>

      <sect2 id="extnt">
        <title>Using 3rd party clients via the extnt wrapper</title>

        <para><indexterm>
            <primary>extnt.exe</primary>
          </indexterm> <indexterm>
            <primary>extnt.ini</primary>
          </indexterm> <indexterm>
            <primary>Using CVSNT protocols with 3rd party clients</primary>
          </indexterm> (Windows only at present) The extnt.exe program is a
        wrapper client which allows 3rd-party clients to use CVSNT protocols
        to access a CVSNT server. It uses the :ext: protocol on the client so
        should be compatible with all existing clients.</para>

        <para>The program takes a number of optional parameters, which may or
        may not be defined by the client. A standard cvs client will only
        usually pass the -l (username) option.<variablelist>
            <varlistentry>
              <term>-l username</term>

              <listitem>
                <para>Username to use.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-p protocol</term>

              <listitem>
                <para>protocol to use. Default comes from the protocol= line
                in extnt.ini. If that is absent uses sspi.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-d directory</term>

              <listitem>
                <para>repository directory. Default comes from the directory=
                line in extnt.ini</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-P password</term>

              <listitem>
                <para>Password to use. Default comes from the password= line
                in extnt.ini</para>
              </listitem>
            </varlistentry>
          </variablelist></para>

        <para>Unless all parameters are passed on the command line by the
        client, you need to setup extnt.ini with the correct details. This
        file is laid out as a standard windows .ini file, with the section
        name based on the hostname to connect to.<screen>[cvs.myserver.org]
protocol=sspi
directory=/cvs</screen></para>

        <para>You can define multiple connections to the same host by using
        the hostname= entry, eg:</para>

        <screen>[cvs-1]
protocol=sspi
directory=/cvs-repo-1
hostname=cvs.myserver.org

[cvs-2]
protocol=sspi
directory=/cvs-repo-2
hostname=cvs.myserver.org</screen>

        <para>Configuring the client to call extnt.exe as its :ext:
        application is client specific.</para>
      </sect2>

      <sect2 id="Password-authenticated">
        <title>Direct connection with password authentication</title>

        <para>The cvsnt client can also connect to the server using a password
        protocol. This is particularly useful if using <command>ssh</command>
        is not feasible (for example, the server is behind a firewall), and
        Kerberos also is not available.</para>

        <para>To use this method, it is necessary to make some adjustments on
        both the server and client sides.</para>

        <sect3 id="Authentication-server">
          <title>Setting up the server for Authentication</title>

          <para>First of all, you probably want to tighten the permissions on
          the <command>$CVSROOT</command> and
          <command>$CVSROOT/CVSROOT</command> directories. See <xref
          linkend="Authentication-security" />, for more details.</para>

          <para><indexterm>
              <primary>authserver</primary>
            </indexterm><indexterm>
              <primary>Remote repositories, port specification</primary>
            </indexterm><indexterm>
              <primary>Repositories, remote, port specification</primary>
            </indexterm><indexterm>
              <primary>Client/Server Operation, port specification</primary>
            </indexterm><indexterm>
              <primary>authserver (client/server connection method), port
              specification</primary>
            </indexterm><indexterm>
              <primary>port, specifying for remote repositories</primary>
            </indexterm><indexterm>
              <primary>Authenticating server, setting up</primary>
            </indexterm>On Windows NT, on the server side, you must run the
          cvsservice.exe program which calls the cvs.exe when required. Setup
          is done using the cvsnt control panel. the rest of this chapter is
          mostly Unix related.</para>

          <para>On Unix, on the server side, the file
          <command>/etc/inetd.conf</command> needs to be edited so
          <command>inetd</command> knows to run the command <command>cvs
          authserver</command> when it receives a connection on the right
          port.</para>

          <para>By default, the port number is for pserver is 2401 it would be
          different for pserver if your client were compiled with
          <command>CVS_AUTH_PORT</command> defined to something else, though.
          This can also be sepcified in the CVSROOT variable (<xref
          linkend="Remote-repositories" />) or overridden with the
          CVS_CLIENT_PORT environment variable (<xref
          linkend="Environment-variables" />), or, on NT, set in the cvsnt
          control panel.</para>

          <para>If your <command>inetd</command> allows raw port numbers in
          <command>/etc/inetd.conf</command>, then the following (all on a
          single line in <command>inetd.conf</command>) should be
          sufficient:</para>

          <para><screen>2401  stream  tcp  nowait  root  /usr/local/bin/cvs
cvs -f --allow-root=/usr/cvsroot authserver
</screen></para>

          <para>You could also use the <command>-T</command> option to specify
          a temporary directory, or, on NT set this within the cvsnt control
          panel.</para>

          <para>The <command>-allow-root</command> option specifies the
          allowable cvsroot directory. Clients which attempt to use a
          different cvsroot directory will not be allowed to connect. If there
          is more than one cvsroot directory which you want to allow, repeat
          the option. (Unfortunately, many versions of
          <command>inetd</command> have very small limits on the number of
          arguments and/or the total length of the command. Unix based CVSNT
          servers usually use the <command>/etc/cvsnt/PServer</command> file
          to store root strings, which avoids this limitation).</para>

          <para>You can also specify repository aliases in the
          <command>--allow-root</command> command (see <xref
          linkend="Repository-Alias" />) by specifying the alias after the
          real root, separated by comma.</para>

          <para>If your <command>inetd</command> wants a symbolic service name
          instead of a raw port number, then put this in
          <command>/etc/services</command>:</para>

          <para><screen>
cvspserver      2401/tcp
</screen></para>

          <para>and put <command>cvspserver</command> instead of
          <command>2401</command> or <command>8003</command> in
          <command>inetd.conf</command>.</para>

          <para>Once the above is taken care of, restart your
          <command>inetd</command>, or do whatever is necessary to force it to
          reread its initialization files.</para>

          <para>If you are having trouble setting this up, see <xref
          linkend="Connection" />.</para>

          <para><indexterm>
              <primary>CVS passwd file</primary>
            </indexterm><indexterm>
              <primary>passwd (admin file)</primary>
            </indexterm>Because the client stores and transmits passwords in
          cleartext (almost--see <xref linkend="Authentication-security" />,
          for details), a separate cvsnt password file is generally used, so
          people don't compromise their regular passwords when they access the
          repository. This file is <command>$CVSROOT/CVSROOT/passwd</command>
          (<xref linkend="Intro-administrative-files" />). It uses a
          colon-separated format, similar to <command>/etc/passwd</command> on
          Unix systems, except that it has fewer fields: cvsnt username,
          optional password, and an optional system username for cvsnt to run
          as if authentication succeeds. Here is an example
          <command>passwd</command> file with five entries:</para>

          <para><screen>
anonymous:
bach:ULtgRLXo7NRxs
spwang:1sOp854gDF3DY
melissa:tGX1fS8sun6rY:pubcvs
qproj:XR4EZcEs0szik:pubcvs
</screen></para>

          <para>(The passwords are encrypted according to the standard Unix
          <command>crypt()</command> function, so it is possible to paste in
          passwords directly from regular Unix <command>/etc/passwd</command>
          files.)</para>

          <para>The first line in the example will grant access to any cvsnt
          client attempting to authenticate as user
          <command>anonymous</command>, no matter what password they use,
          including an empty password. (This is typical for sites granting
          anonymous read-only access; for information on how to do the
          "read-only" part, see <xref linkend="Read-only-access" />.)</para>

          <para>The second and third lines will grant access to
          <command>bach</command> and <command>spwang</command> if they supply
          their respective plaintext passwords.</para>

          <para><indexterm>
              <primary>User aliases</primary>
            </indexterm>The fourth line will grant access to
          <command>melissa</command>, if she supplies the correct password,
          but her cvsnt operations will actually run on the server side under
          the system user <command>pubcvs</command>. Thus, there need not be
          any system user named <command>melissa</command>, but there
          <emphasis>must</emphasis> be one named
          <command>pubcvs</command>.</para>

          <para>The fifth line shows that system user identities can be
          shared: any client who successfully authenticates as
          <command>qproj</command> will actually run as
          <command>pubcvs</command>, just as <command>melissa</command> does.
          That way you could create a single, shared system user for each
          project in your repository, and give each developer their own line
          in the <command>$CVSROOT/CVSROOT/passwd</command> file. The cvsnt
          username on each line would be different, but the system username
          would be the same. The reason to have different cvsnt usernames is
          that cvsnt will log their actions under those names: when
          <command>melissa</command> commits a change to a project, the
          checkin is recorded in the project's history under the name
          <command>melissa</command>, not <command>pubcvs</command>. And the
          reason to have them share a system username is so that you can
          arrange permissions in the relevant area of the repository such that
          only that account has write-permission there.</para>

          <para>If the system-user field is present, all
          password-authenticated cvsnt commands run as that user; if no system
          user is specified, cvsnt simply takes the cvsnt username as the
          system username and runs commands as that user. In either case, if
          there is no such user on the system, then the cvsnt operation will
          fail (regardless of whether the client supplied a valid
          password).</para>

          <para>The password and system-user fields can both be omitted (and
          if the system-user field is omitted, then also omit the colon that
          would have separated it from the encrypted password). For example,
          this would be a valid <command>$CVSROOT/CVSROOT/passwd</command>
          file:</para>

          <para><screen>
anonymous::pubcvs
fish:rKa5jzULzmhOo:kfogel
sussman:1sOp854gDF3DY
</screen></para>

          <para>When the password field is omitted or empty, then the client's
          authentication attempt will succeed with any password, including the
          empty string. However, the colon after the cvsnt username is always
          necessary, even if the password is empty.</para>

          <para>cvsnt can also fall back to use system authentication. When
          authenticating a password, the server first checks for the user in
          the <command>$CVSROOT/CVSROOT/passwd</command> file. If it finds the
          user, it will use that entry for authentication as described above.
          But if it does not find the user, or if the cvsnt
          <command>passwd</command> file does not exist, then the server can
          try to authenticate the username and password using the operating
          system's user-lookup routines (this "fallback" behavior can be
          disabled by setting <command>SystemAuth=no</command> in the cvsnt
          <command>config</command> file, <xref linkend="config" />). Be
          aware, however, that falling back to system authentication might be
          a security risk: cvsnt operations would then be authenticated with
          that user's regular login password, and the p assword flies across
          the network in plaintext. See <xref
          linkend="Authentication-security" /> for more on this.</para>

          <para>You can setup the passwd file by logging in to cvs using
          another method (local, sserver, gserver, ssh, sspi) and using the
          cvsnt passwd command to add new users.</para>
        </sect3>

        <sect3 id="Authentication-client">
          <title>Using the client with password authentication</title>

          <para><indexterm>
              <primary>Login</primary>
            </indexterm><indexterm>
              <primary>Authenticated client, using</primary>
            </indexterm><indexterm>
              <primary>:pserver:, setting up</primary>
            </indexterm><indexterm>
              <primary>:sserver:, setting up</primary>
            </indexterm><indexterm>
              <primary>:sspi:, setting up</primary>
            </indexterm>To run a cvsnt command on a remote repository via the
          password-authenticating server, one specifies the protocol, optional
          username, repository host, an optional port number, and path to the
          repository. For example:</para>

          <para><screen>cvs -d :pserver:faun.example.org:/usr/local/cvsroot checkout someproj

cvs -d :sserver:faun.example.org:/usr/local/cvsroot checkout someproj

cvs -d :sspi:faun.example.org:/usr/local/cvsroot checkout someproj
</screen></para>

          <para>With certain protcols, unless you're connecting to a
          public-access repository (i.e., one where that username doesn't
          require a password), you'll need to supply a password or
          <firstterm>log in</firstterm> first. Logging in verifies your
          password with the repository and stores it in a file. It's done with
          the <command>login</command> command, which will prompt you
          interactively for the password if you didn't supply one as part of
          <varname>$CVSROOT</varname>:</para>

          <para><screen>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot login
CVS password:
</screen></para>

          <para>or</para>

          <para><screen>
cvs -d :pserver:bach:p4ss30rd@faun.example.org:/usr/local/cvsroot login
</screen></para>

          <para>After you enter the password, cvsnt verifies it with the
          server. If the verification succeeds, then that combination of
          username, host, repository, and password is permanently recorded, so
          future transactions with that repository won't require you to run
          <command>cvs login</command>. (If verification fails, cvsnt will
          exit complaining that the password was incorrect, and nothing will
          be recorded.)</para>

          <para>The records are stored, by default, in the file
          <command>$HOME/.cvspass</command> (Unix) or the Registry (NT). The
          format human-readable, and to a degree human-editable, but note that
          the passwords are not stored in cleartext--they are trivially
          encoded to protect them from "innocent" compromise (i.e.,
          inadvertent viewing by a system administrator or other non-malicious
          person).</para>

          <para>Once you have logged in, all cvsnt commands using that remote
          repository and username will authenticate with the stored password.
          So, for example</para>

          <para><screen>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout foo
</screen></para>

          <para>should just work (unless the password changes on the server
          side, in which case you'll have to re-run <command>cvs
          login</command>).</para>

          <para>Note that if the <command>:pserver:</command> were not present
          in the repository specification, cvsnt would assume it should use
          <command>ssh</command> to connect with the server instead (<xref
          linkend="Connecting-via-ssh" />).</para>

          <para>Of course, once you have a working copy checked out and are
          running cvsnt commands from within it, there is no longer any need
          to specify the repository explicitly, because cvsnt can deduce the
          repository from the working copy's <command>CVS</command>
          subdirectory.</para>

          <para><indexterm>
              <primary>Logout</primary>
            </indexterm>The password for a given remote repository can be
          removed from the password cache by using the <command>cvs
          logout</command> command.</para>
        </sect3>

        <sect3 id="Authentication-security">
          <title>Security considerations with password authentication</title>

          <para><indexterm>
              <primary>Security, of pserver</primary>
            </indexterm><indexterm>
              <primary>Security, of sserver</primary>
            </indexterm><indexterm>
              <primary>Security, of sspi</primary>
            </indexterm><indexterm>
              <primary>Secutiry, of ntserver</primary>
            </indexterm> With pserver and sserver, the passwords are stored on
          the client side in a trivial encoding of the cleartext and in the
          pserver case transmitted in the same encoding. The encoding is done
          only to prevent inadvertent password compromises (i.e., a system
          administrator accidentally looking at the file), and will not
          prevent even a naive attacker from gaining the password.</para>

          <para>With sserver, the client/server connection is encrypted using
          SSL, and the risk of the password being sniffed 'on the wire' is
          very low.</para>

          <para>With sspi, if cvsnt login is used to gain access to a remote
          server, the passwords are stored on the client side in the same
          manner as pserver. However the passwords are never transmitted
          insecurely over the internet.</para>

          <para>With pserver and sserver, the separate cvsnt password file
          (<xref linkend="Authentication-server" />) allows people to use a
          different password for repository access than for login access. With
          other protocols the system passwords are used and the password field
          in the passwd file is ignored.</para>

          <para>Once a user has non-read-only access to the repository, she
          can execute programs on the server system through a variety of
          means. Thus, repository access implies fairly broad system access as
          well. It might be possible to modify cvsnt to prevent that, but no
          one has done so as of this writing.</para>

          <para>Note that because the <command>$CVSROOT/CVSROOT</command>
          directory contains <command>passwd</command> and other files which
          are used to check security, you must control the permissions on this
          directory as tightly as the permissions on <command>/etc</command>.
          The same applies to the <command>$CVSROOT</command> directory itself
          and any directory above it in the tree. Anyone who has write access
          to such a directory will have the ability to become any user on the
          system. Note that these permissions are typically tighter than you
          would use if you are not using pserver.</para>

          <para>In summary, with a password server anyone who gets the
          password gets repository access (which may imply some measure of
          general system access as well).</para>

          <para>With pserver, the password is available to anyone who can
          sniff network packets or read a protected (i.e., user read-only)
          file. Other protocols do not have this problem.</para>
        </sect3>
      </sect2>

      <sect2 id="GSSAPI-authenticated">
        <title>Direct connection with GSSAPI</title>

        <para><indexterm>
            <primary>GSSAPI</primary>
          </indexterm><indexterm>
            <primary>Security, GSSAPI</primary>
          </indexterm><indexterm>
            <primary>:gserver:, setting up</primary>
          </indexterm><indexterm>
            <primary>Kerberos, using :gserver:</primary>
          </indexterm>GSSAPI is a generic interface to network security
        systems such as Kerberos 5. If you have a working GSSAPI library, you
        can have cvsnt connect via a direct tcp connection, authenticating
        with GSSAPI.</para>

        <para>To do this, cvsnt needs to be compiled with GSSAPI support; when
        configuring cvsnt it tries to detect whether GSSAPI libraries using
        kerberos version 5 are present. You can also use the
        <command>-with-gssapi</command> flag to configure.</para>

        <para>The connection is authenticated using GSSAPI, but the message
        stream is <emphasis>not</emphasis> authenticated by default. You must
        use the <command>-a</command> global option to request stream
        authentication.</para>

        <para>The data transmitted is <emphasis>not</emphasis> encrypted by
        default. Encryption support must be compiled into both the client and
        the server; use the <command>-enable-encrypt</command> configure
        option to turn it on. You must then use the <command>-x</command>
        global option to request encryption.</para>

        <para>GSSAPI connections are handled on the server side by the same
        server which handles the password authentication server; see <xref
        linkend="Authentication-server" />. If you are using a GSSAPI
        mechanism such as Kerberos which provides for strong authentication,
        you will probably want to disable the ability to authenticate via
        cleartext passwords. To do so, create an empty
        <command>CVSROOT/passwd</command> password file, and set
        <command>SystemAuth=no</command> in the config file (<xref
        linkend="config" />).</para>

        <para>The GSSAPI server uses a principal name of
        cvs/<varname>hostname</varname>, where <varname>hostname</varname> is
        the canonical name of the server host. You will have to set this up as
        required by your GSSAPI mechanism.</para>

        <para>To connect using GSSAPI, use <command>:gserver:</command>. For
        example,</para>

        <para><screen>cvs -d :gserver:faun.example.org:/usr/local/cvsroot checkout foo
</screen></para>
      </sect2>

      <sect2 id="Connecting-via-fork">
        <title>Connecting with fork</title>

        <para><indexterm>
            <primary>fork, access method</primary>
          </indexterm><indexterm>
            <primary>:fork:, setting up</primary>
          </indexterm>This access method allows you to connect to a repository
        on your local disk via the remote protocol. In other words it does
        pretty much the same thing as <command>:local:</command>, but various
        quirks, bugs and the like are those of the remote cvsnt rather than
        the local cvsnt.</para>

        <para>For day-to-day operations you might prefer either
        <command>:local:</command> or <command>:fork:</command>, depending on
        your preferences. Of course <command>:fork:</command> comes in
        particularly handy in testing or debugging <command>cvsnt</command>
        and the remote protocol. Specifically, we avoid all of the
        network-related setup/configuration, timeouts, and authentication
        inherent in the other remote access methods but still create a
        connection which uses the remote protocol.</para>

        <para>To connect using the <command>fork</command> method, use
        <command>:fork:</command> and the pathname to your local repository.
        For example:</para>

        <para><screen>cvs -d :fork:/usr/local/cvsroot checkout foo
</screen></para>
      </sect2>

      <sect2 id="Repository-Alias">
        <title>Using repository aliases</title>

        <para><indexterm>
            <primary>Repository Prefix</primary>
          </indexterm> <indexterm>
            <primary>Prefix, Repository</primary>
          </indexterm> <indexterm>
            <primary>Repository Alias</primary>
          </indexterm> <indexterm>
            <primary>Alias, Repository</primary>
          </indexterm></para>

        <para>Repository aliases hide the real paths to the repositories on
        the server behind virtual names. The server information is hidden to
        clients which increases security and means the cvs root strings are
        independent of the server architecture.</para>

        <para>Aliases are normally specified in the
        <command>/etc/cvsnt/PServer</command> file on Unix, or in the Control
        Panel on NT. Especially on NT is is recommended that aliases are used
        to avoid exposing NT drive letters to the clients.</para>
      </sect2>
    </sect1>


    <sect1 id="Replicating-a-repository">
      <title>Replicating a repository and Repository Caching</title>

      <para><indexterm>
          <primary>Repository, replicting</primary>
        </indexterm><indexterm>
          <primary>Replicating a repository</primary>
        </indexterm><indexterm>
          <primary>Caching a repository</primary>
        </indexterm> Repository replication and caching may be configured so 
      that remote locations can have fast access for read operations while 
      keeping changes stored in a master repository.  If the master repositoryy
      goes offline then people at the remote location can continue to work
      or one of the remote caches can be re-configured to be the new master.</para>

      <para>The fisrt thing to consider is whether replication and caching 
      are needed at all.  CVS was designed for networks that were much slower
      and less reliable that are available today, so even without replication
      and caching it should perform adequately for large remote teams using a
      central repository located in the same or a distant continent.  If you
      are considering repository replication and caching primarily to improve
      performance then you should instead address the causes of the performance
      issues first by contacting the CVSNT Newsgroup or purchasing commercial
      support from the project sponsor (<xref linkend="BUGS" />).</para>



      <sect2 id="Overview-Replicating-a-repository">
        <title>Overview</title>

        <para>After much analysis and discussion internally the CVSNT developers
        could not see any benefit for repository replication and caching since
        the CVSNT protocol was designed for telecommunications networks far 
        slower and less reliable that what is commonly available today.</para>

        <para>Secondly in hypotheticals about 'if we did do multi-repos' - we could
        not see any benefit in a quorum based system where the changes on
        one repository are mulitcast to several servers simultaneously, since the
        quorum needs to be tracked and the 'excluded members' of the quorum are
        just as incapable of accepting patches as is a single repository shadow.</para>

        <para>The solution we have come up with is a 'master' repository and multiple
        shadows.  If you like  you can change which is the 'master' at any time
        you like.  </para>

        <para>The CVSNT developers have been using the 2.5.04 repostiory cache feature since 2007
        internally between Manchester UK and Sydney Australia and it works very well - and if you have
        large binaries in the repository or your processes require 'fresh checkouts'
        rather than 'updates' then installng a shadow does improve performance.</para>


        <para>Changing your procedures to use 'udpate' would do the same thing and
        requires much less effort than setting up repository replication.</para>

        <para>It cannot be stressed enough just how unnecessary repository replication and
        caching is for 99.9% of organisations as teams - if you are experiencing multi
        site performance problems there are probably much 'better' ways to fix
        it that using repository replication and caching.</para>

        <para>If you want more info on repository replication please see the
        previous newsgroup posts:</para>

    <itemizedlist mark="bullet">
      <listitem>
        <para>1. <screen>http://www.cvsnt.org/pipermail/cvsnt/2008-May/030637.html</screen> And</para>
      </listitem>

      <listitem>
        <para>1. <screen>http://www.cvsnt.org/pipermail/cvsnt/2008-May/030642.html</screen> And</para>
      </listitem>

      <listitem>
        <para>1. <screen>http://www.cvsnt.org/pipermail/cvsnt/2008-May/030653.html</screen> And</para>
      </listitem>

      <listitem>
        <para>1. <screen>http://www.cvsnt.org/pipermail/cvsnt/2008-May/030655.html</screen> And</para>
      </listitem>

      <listitem>
        <para>1. <screen>http://www.cvsnt.org/pipermail/cvsnt/2008-May/030659.html</screen> .</para>
      </listitem>


    </itemizedlist>

      </sect2>

      <sect2 id="Into-Replicating-a-repository">
        <title>Introduction</title>

        <para>CVSNT provides the following specific repository replication an caching features:</para>
    <itemizedlist mark="bullet">
      <listitem>
        <para>The SYNC protocol to 'pass through' changes form a local cache to the master server, and</para>
      </listitem>

      <listitem>
        <para>The UNISON port on the Master server to allow caching clients to obtain delta copies of the repository (Unison is included in the quality assured CVS Suite only)</para>
      </listitem>

      <listitem>
        <para>Triggers to automatically activate synchronising changes from the master server back to the local cache (the quality assured CVS Suite includes a SYNC trigger)</para>
      </listitem>

        <para>It is also necessary to configure the synchronise to occur at intervals when the caching server is inactive (the quality assured CVS Suite includes a SYNC scheduler)</para>


    </itemizedlist>

      </sect2>

    </sect1>


  </chapter>

  <chapter id="Security">
    <title>Security</title>

    <para><indexterm>
        <primary>Security (intro)</primary>
      </indexterm><indexterm>
        <primary>Security, example</primary>
      </indexterm> A remote cvsnt <firstterm>repository</firstterm> can be set
    up to have its own security system outside of the standard security
    provided by the system. See also information about the chacl and chown
    commands, and the CVSROOT/admin file.</para>

    <sect1 id="Setting-up-security">
      <title>How to set up security</title>

      <para>First setup the server normally. Changing the base path as
      described in <xref linkend="Repository-Alias" /> can be very convenient.
      The command should run as the user that owns the repository (not root).
      Use the RunAsUser setting for this.</para>

      <para>On Unix systems setting a the Chroot variable is recommended
      also.</para>

      <para>To lock down the access to the repository by default set the
      AclMode setting in the CVSROOT/config to 'normal'. This will stop anyone
      accessing the any file unless they are specifically granted access by an
      access control entry</para>

      <para>On a secure system it is recommended that pserver is not used, as
      it sends its passwords in a trivially decryptable form. On Windows
      systems use encrypted SSPI, and on Unix ssh is recommended.</para>
    </sect1>

    <sect1 id="User-maintenance">
      <title>How to add and delete users<indexterm>
          <primary>Users, adding and removing</primary>
        </indexterm></title>

      <para>The <link linkend="passwd">cvs passwd</link> command can be used
      to add or delete new users. Only an administrator can do this.</para>

      <para>Note that deleting a user does not remove them from any user
      permissions.</para>
    </sect1>

    <sect1 id="Setting-permissions">
      <title>Setting permissions for files and directories<indexterm>
          <primary>Setting permissions for files and directories</primary>
        </indexterm><indexterm>
          <primary>Access control lists (ACLs)</primary>
        </indexterm></title>

      <para>CVSNT has its own access control mechanism that is aware of
      branches and other CVSNT features. There are currently 5 access that can
      be set, and 3 ways of matching the access entry.</para>

      <para>The access permissions are as follows:</para>

      <variablelist>
        <varlistentry>
          <term>read</term>

          <listitem>
            <para>User is able to read the file, or for a directory access
            files within that directory</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>write</term>

          <listitem>
            <para>User is able to commit a new revision to the file or
            directory</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>create</term>

          <listitem>
            <para>User is able to add new files to the directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>tag</term>

          <listitem>
            <para>User is able to tag the file or files within the
            directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>control</term>

          <listitem>
            <para>User is able to modify the access controls for the file or
            directory. This right is granted automatically to the file owner
            and to repository administrators.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Each access entry has 3 attributes which define which situations
      it applies to.</para>

      <variablelist>
        <varlistentry>
          <term>Username (-u)</term>

          <listitem>
            <para>Defines that this access entry applies to a single user or
            group. Where this is specified it is the most significant
            attribute.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Branch (-r)</term>

          <listitem>
            <para>Defines that this access entry applies to a single branch or
            tag. Where this is specified it is the second most significant
            attribute.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Merge (-j)</term>

          <listitem>
            <para>Defines that this access entry applies when a merge is
            attempted from the specified branch.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>There are also 3 optional attributes that may be specified for
      each access entry.</para>

      <variablelist>
        <varlistentry>
          <term>Message (-m)</term>

          <listitem>
            <para>Define a custom message displayed to the user when an action
            fails due to this entry.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Priority (-p)</term>

          <listitem>
            <para>Normally CVSNT prioritises access entries using a 'best fit'
            match, with ambguities solved as described above. In exceptional
            cases it may be necessary to override this behaviour. Specifying a
            priority over 100 is guaranteed to be higher than the caculated
            priorities, and will ensure that this ACL entry overrides all
            others.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Inheritance (-n)</term>

          <listitem>
            <para>Normally directory access control entries automatically
            inherit, which means setting an access control entry on the root
            of a module affects all directories below it, unless overriden by
            an entry further down the tree. This option supresses that
            behaviour.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Access permissions are modified using the <command>cvs
      chacl</command> command. For example:</para>

      <para><screen>cvs chacl -a read,write -u theuser dir1 dir2 dir3
</screen></para>

      <para>will grant the user named <command>theuser</command> read and
      write access to the three specified directories.</para>

      <para>To view the current permissions the cvsnt lsacl command can be
      used. It will show the owner and all the users that have permissions in
      the given directories.</para>

      <para>If the user name is not specified, those permissions will be given
      to all users of the directory, if not overriden by other entries. This
      is an easy way to give everyone read access to a directory, for
      instance.</para>

      <para>For a user to have access to a directory, they must have at least
      read access to all the directories above it. If a user has a 'no access'
      ACL on a parent directory they cannot be granted access to directories
      below it.</para>

      <para>The owner or a directory can be reassigned using the cvsnt chown
      command.</para>
    </sect1>

    <sect1 id="Setting-up-groups">
      <title>Groups of users can be assigned permissions</title>

      <para>Sometimes administrators find it easier to maintain permissions on
      groups of users instead of on individual users. That way, if a group of
      people have access to a directory, the group can be assigned rights to
      the directories and the administrator only needs to modify the members
      of the group to maintain the permissions.</para>

      <para>If <command>SystemAuth</command> is enabled CVSNT will
      automatically add all the system groups for the user to the list of
      available groups. If you don't require other groups then editing the
      <command>group</command> file is unnecessary.</para>

      <para>The <command>group</command> file in the
      <command>CVSROOT</command> directory holds a list of groups. The file
      has two fields seperated by a colon, the first is the group name, the
      second is a list of group members, separated by white space, such
      as:</para>

      <para><screen>group1: user1 user2 user3
group2: me you dognamedblue
group3: peter paul mary
</screen></para>

      <para>To set up groups, edit the <command>group</command> file in the
      CVSROOT directory in the repository and set up the permissions for the
      groups.</para>

      <para>Repository administrators are automatically made a member of the
      group 'admin'. Don't list this group in the group file.</para>
    </sect1>

    <sect1 id="Runas-User">
      <title>Running CVSNT as a nonprivileged user</title>

      <para><indexterm>
          <primary>Security, running as a nonprivileged user</primary>
        </indexterm> Under the traditional CVS execution model, the server
      runs as the user checking in the file. For some security requirements
      this is inadequate, so CVSNT also provides a RunAsUser parameter (in the
      <command>/etc/cvsnt/PServer</command> or the in the registry under
      Windows). If this is set, the server always runs as the specified user,
      who should be a nonprivileged user who has read/write access only to the
      repository files. See also <xref linkend="Chroot" />.</para>
    </sect1>

    <sect1 id="Chroot">
      <title>Running within a chroot jail</title>

      <para><indexterm>
          <primary>Security, running within a chroot jail</primary>
        </indexterm><indexterm>
          <primary>Chroot, running within</primary>
        </indexterm> On operating systems that support this operation, cvsnt
      provides the Chroot parameter (in the
      <command>/etc/cvsnt/PServer</command> file). After CVSNT has loaded it
      will perform the chroot just prior to dropping privileges and before any
      filesystem operations.</para>

      <para>The chroot jail must contain a /tmp directory for use by the
      server but does not need any binary or library directories. In the
      minimal (most secure) configuration it is impossible to run scripts of
      any kind. Adding binaries/libraries to allow script execution should be
      done with care. Never add setuid binaries to a chroot jail as it may
      allow an attacker an avenue to break out of it.</para>
    </sect1>

    <sect1 id="Passwords">
      <title>Setting and changing passwords</title>

      <indexterm>
        <primary>Changing passwords</primary>
      </indexterm>

      <para>Users can use the <link linkend="passwd">cvs passwd</link> command
      with no parameters to modify their passwords. The administrator can
      specify a user on the command line to change their password.</para>
    </sect1>

    <sect1 id="Administrators">
      <title>Repository administrators</title>

      <para><indexterm>
          <primary>Repository administrators</primary>
        </indexterm><indexterm>
          <primary>CVSROOT/admin</primary>
        </indexterm> If SystemAuth = Yes the user is considered to be an
      administrator of they are listed in the CVSROOT/admin file or if they
      are in the 'Administrators' group (NT) or 'cvsadmin' group
      (Unix).</para>

      <para>If SystemAuth = No only the CVSROOT/admin file is checked.</para>

      <para>The CVSROOT/admin file contains a list of usernames who are
      designated repository administrators, one per line. This file should
      *not* be put under cvsnt control, as that would be a security
      risk.</para>

      <para>Repository administrators are automatically made members of the
      group 'admin'.</para>
    </sect1>

    <sect1 id="Read-only-access">
      <title>Read-only repository access</title>

      <para><indexterm>
          <primary>Read-only repository access</primary>
        </indexterm><indexterm>
          <primary>readers (admin file)</primary>
        </indexterm><indexterm>
          <primary>writers (admin file)</primary>
        </indexterm> It is possible to grant read-only repository access to
      people using the password-authenticated server (<xref
      linkend="Password-authenticated" />). (The other access methods do not
      have explicit support for read-only users because those methods all
      assume login access to the repository machine anyway, and therefore the
      user can do whatever local file permissions allow her to do.)</para>

      <para>A user who has read-only access can do only those cvsnt operations
      which do not modify the repository, except for certain "administrative"
      files (such as lock files and the history file). It may be desirable to
      use this feature in conjunction with user-aliasing (<xref
      linkend="Authentication-server" />).</para>

      <para>Unlike with previous versions of cvsnt, read-only users should be
      able merely to read the repository, and not to execute programs on the
      server or otherwise gain unexpected levels of access. Or to be more
      accurate, the <emphasis>known</emphasis> holes have been plugged.
      Because this feature is new and has not received a comprehensive
      security audit, you should use whatever level of caution seems warranted
      given your attitude concerning security.</para>

      <para>There are two ways to specify read-only access for a user: by
      inclusion, and by exclusion.</para>

      <para>"Inclusion" means listing that user specifically in the
      <command>$CVSROOT/CVSROOT/readers</command> file, which is simply a
      newline-separated list of users. Here is a sample
      <command>readers</command> file:</para>

      <para><screen>melissa
splotnik
jrandom
</screen></para>

      <para>(Don't forget the newline after the last user.)</para>

      <para>"Exclusion" means explicitly listing everyone who has
      <emphasis>write</emphasis> access--if the file</para>

      <para><screen>
$CVSROOT/CVSROOT/writers
</screen></para>

      <para>exists, then only those users listed in it have write access, and
      everyone else has read-only access (of course, even the read-only users
      still need to be listed in the cvsnt <command>passwd</command> file).
      The <command>writers</command> file has the same format as the
      <command>readers</command> file.</para>

      <para>Note: if your cvsnt <command>passwd</command> file maps cvs users
      onto system users (<xref linkend="Authentication-server" />), make sure
      you deny or grant read-only access using the <emphasis>cvsnt</emphasis>
      usernames, not the system usernames. That is, the
      <command>readers</command> and <command>writers</command> files contain
      cvs usernames, which may or may not be the same as system
      usernames.</para>

      <para>Here is a complete description of the server's behavior in
      deciding whether to grant read-only or read-write access:</para>

      <para>If <command>readers</command> exists, and this user is listed in
      it, then she gets read-only access. Or if <command>writers</command>
      exists, and this user is NOT listed in it, then she also gets read-only
      access (this is true even if <command>readers</command> exists but she
      is not listed there). Otherwise, she gets full read-write access.</para>

      <para>Of course there is a conflict if the user is listed in both files.
      This is resolved in the more conservative way, it being better to
      protect the repository too much than too little: such a user gets
      read-only access.</para>
    </sect1>

    <sect1 id="Server-temporary-directory">
      <title>Temporary directories for the server</title>

      <para><indexterm>
          <primary>Temporary directories, and server</primary>
        </indexterm><indexterm>
          <primary>Server, temporary directories</primary>
        </indexterm> While running, the cvsnt server creates temporary
      directories. They are named</para>

      <para><screen>cvs-serv<varname>pid</varname>
</screen></para>

      <para>where <varname>pid</varname> is the process identification number
      of the server. They are located in the directory specified by the
      <command>TMPDIR</command> environment variable (<xref
      linkend="Environment-variables" />), the <command>-T</command> global
      option (<xref linkend="Global-options" />), or failing that
      <command>/tmp</command>.</para>

      <para>In most cases the server will remove the temporary directory when
      it is done, whether it finishes normally or abnormally. However, there
      are a few cases in which the server does not or cannot remove the
      temporary directory, for example:</para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>If the server aborts due to an internal server error, it may
          preserve the directory to aid in debugging</para>
        </listitem>

        <listitem>
          <para>If the server is killed in a way that it has no way of
          cleaning up (most notably, <command>kill -KILL</command> on
          unix).</para>
        </listitem>

        <listitem>
          <para>If the system shuts down without an orderly shutdown, which
          tells the server to clean up.</para>
        </listitem>
      </itemizedlist>

      <para>In cases such as this, you will need to manually remove the
      <command>cvs-serv<varname>pid</varname></command> directories. As long
      as there is no server running with process identification number
      <varname>pid</varname>, it is safe to do so.</para>
    </sect1>

    <sect1 id="Lockserver">
      <title>The CVSNT lockserver</title>

      <para><indexterm>
          <primary>Lockserver</primary>
        </indexterm> <indexterm>
          <primary>cvslockd</primary>
        </indexterm> <indexterm>
          <primary>Lockserver, setting up</primary>
        </indexterm> <indexterm>
          <primary>Setting up the Lockserver</primary>
        </indexterm> In all recent versions of CVSNT the lockserver is the
      primary means of handling file locking. There should normally only be
      one lockserver, which may be shared by multiple repositories. Once
      running it should require little or no maintenence.</para>

      <para>The lockserver provides file-level locking for the server, which
      allows much greater concurrency than previous versions of CVS. It also
      provides checkout atomicity which ensures that you always get a coherent
      view of the repository. The previous method of locking using directory
      locks on the filesystem is now depreciated and should not be used as it
      does not have these advantages.</para>

      <para>Setting up the lockserver under Windows is handled by the setup
      program and happens automatically. Under Unix you need to arrange to run
      the <command>cvslockd</command> on startup - this varies between
      versions.</para>
    </sect1>
  </chapter>

  <chapter id="Starting-a-new-project">
    <title>Starting a project with CVS</title>

    <para><indexterm>
        <primary>Starting a project with CVS</primary>
      </indexterm><indexterm>
        <primary>Creating a project</primary>
      </indexterm> Because renaming files and moving them between directories
    is somewhat inconvenient, the first thing you do when you start a new
    project should be to think through your file organization. It is not
    impossible to rename or move files, but it does increase the potential for
    confusion and cvsnt does have some quirks particularly in the area of
    renaming directories. <xref linkend="Moving-files" />.</para>

    <para>What to do next depends on the situation at hand.</para>

    <sect1 id="Setting-up-the-files">
      <title>Setting up the files</title>

      <para>The first step is to create the files inside the repository. This
      can be done in a couple of different ways.</para>

      <sect2 id="From-files">
        <title>Creating a directory tree from a number of files</title>

        <para><indexterm>
            <primary>Importing files</primary>
          </indexterm> When you begin using cvsnt, you will probably already
        have several projects that can be put under cvsnt control. In these
        cases the easiest way is to use the <command>import</command> command.
        An example is probably the easiest way to explain how to use it. If
        the files you want to install in cvsnt reside in
        <command><varname>wdir</varname></command>, and you want them to
        appear in the repository as
        <command>$CVSROOT/yoyodyne/<varname>rdir</varname></command>, you can
        do this:</para>

        <para><screen>$ cd <varname>wdir</varname>
$ cvs import -m "Imported sources" yoyodyne/<varname>rdir</varname> yoyo start
</screen></para>

        <para>Unless you supply a log message with the <command>-m</command>
        flag, cvsnt starts an editor and prompts for a message. The string
        <command>yoyo</command> is a <firstterm>vendor tag</firstterm>, and
        <command>start</command> is a <firstterm>release tag</firstterm>. They
        may fill no purpose in this context, but since cvsnt requires them
        they must be present. <xref linkend="Tracking-sources" />, for more
        information about them.</para>

        <para>You can now verify that it worked, and remove your original
        source directory.</para>

        <para><screen>
$ cd ..
$ cvs checkout yoyodyne/<varname>rdir</varname>       # Explanation below
$ diff -r <varname>wdir</varname> yoyodyne/<varname>rdir</varname>
$ rm -r <varname>wdir</varname>
</screen></para>

        <para>Erasing the original sources is a good idea, to make sure that
        you do not accidentally edit them in <varname>wdir</varname>,
        bypassing cvsnt. Of course, it would be wise to make sure that you
        have a backup of the sources before you remove them.</para>

        <para>The <command>checkout</command> command can either take a module
        name as argument (as it has done in all previous examples) or a path
        name relative to <command>$CVSROOT</command>, as it did in the example
        above.</para>

        <para>It is a good idea to check that the permissions cvsnt sets on
        the directories inside <command>$CVSROOT</command> are reasonable, and
        that they belong to the proper groups. <xref
        linkend="File-permissions" />.</para>

        <para>If some of the files you want to import are binary, you may want
        to use the wrappers features to specify which files are binary and
        which are not. <xref linkend="Wrappers" />.</para>
      </sect2>

      <sect2 id="From-other-version-control-systems">
        <title>Creating Files From Other Version Control Systems</title>

        <para><indexterm>
            <primary>Importing files, from other version control
            systems</primary>
          </indexterm> If you have a project which you are maintaining with
        another version control system, such as rcs, you may wish to put the
        files from that project into cvsnt, and preserve the revision history
        of the files.</para>

        <variablelist>
          <title><indexterm>
              <primary>rcs, importing files from</primary>
            </indexterm></title>

          <varlistentry>
            <term>From rcs</term>

            <listitem>
              <para>If you have been using rcs, find the rcs files--usually a
              file named <command>foo.c</command> will have its rcs file in
              <command>rcs/foo.c,v</command> (but it could be other places;
              consult the rcs documentation for details). Then create the
              appropriate directories in cvsnt if they do not already exist.
              Then copy the files into the appropriate directories in the
              cvsnt repository (the name in the repository must be the name of
              the source file with <command>,v</command> added; the files go
              directly in the appropriate directory of the repository, not in
              an <command>rcs</command> subdirectory). This is one of the few
              times when it is a good idea to access the cvsnt repository
              directly, rather than using cvsnt commands. Then you are ready
              to check out a new working directory.</para>

              <para>The rcs file should not be locked when you move it into
              cvsnt; if it is, cvsnt will have trouble letting you operate on
              it.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>From another version control system</term>

            <listitem>
              <para>Many version control systems have the ability to export
              rcs files in the standard format. If yours does, export the rcs
              files and then follow the above instructions.</para>

              <para>Failing that, probably your best bet is to write a script
              that will check out the files one revision at a time using the
              command line interface to the other system, and then check the
              revisions into cvsnt. The <command>sccs2rcs</command> script
              mentioned below may be a useful example to follow.</para>

              <para><indexterm>
                  <primary>SCCS, importing files from</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>From SCCS</term>

            <listitem>
              <para>There is a script in the <command>contrib</command>
              directory of the cvsnt source distribution called
              <command>sccs2rcs</command> which converts sccs files to rcs
              files. Note: you must run it on a machine which has both sccs
              and rcs installed, and like everything else in contrib it is
              unsupported (your mileage may vary).</para>

              <para><indexterm>
                  <primary>PVCS, importing files from</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>From PVCS</term>

            <listitem>
              <para>There is a script in the <command>contrib</command>
              directory of the cvsnt source distribution called
              <command>pvcs_to_rcs</command> which converts pvcs archives to
              rcs files. You must run it on a machine which has both pvcs and
              rcs installed, and like everything else in contrib it is
              unsupported (your mileage may vary). See the comments in the
              script for details.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="From-scratch">
        <title>Creating a directory tree from scratch</title>

        <para>For a new project, the easiest thing to do is probably to create
        an empty directory structure, like this:</para>

        <para><screen>$ mkdir tc
$ mkdir tc/man
$ mkdir tc/testing
</screen></para>

        <para>After that, you use the <command>import</command> command to
        create the corresponding (empty) directory structure inside the
        repository:</para>

        <para><screen>
$ cd tc
$ cvs import -m "Created directory structure" yoyodyne/<varname>dir</varname> yoyo start
</screen></para>

        <para>Then, use <command>add</command> to add files (and new
        directories) as they appear.</para>

        <para>Check that the permissions cvsnt sets on the directories inside
        <command>$CVSROOT</command> are reasonable.</para>
      </sect2>
    </sect1>

    <sect1 id="Defining-the-module">
      <title>Defining the module</title>

      <para><indexterm>
          <primary>Defining a module</primary>
        </indexterm><indexterm>
          <primary>Editing the modules file</primary>
        </indexterm><indexterm>
          <primary>Module, defining</primary>
        </indexterm><indexterm>
          <primary>Modules file, changing</primary>
        </indexterm> The next step is to define the module in the
      <command>modules</command> file. This is not strictly necessary, but
      modules can be convenient in grouping together related files and
      directories.</para>

      <para>In simple cases these steps are sufficient to define a
      module.</para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>Get a working copy of the modules file.</para>

          <para><screen>$ cvs checkout CVSROOT/modules
$ cd CVSROOT
</screen></para>
        </listitem>

        <listitem>
          <para>Edit the file and insert a line that defines the module. <xref
          linkend="Intro-administrative-files" />, for an introduction. <xref
          linkend="modules" />, for a full description of the modules file.
          You can use the following line to define the module
          <command>tc</command>:</para>

          <para><screen>
tc   yoyodyne/tc
</screen></para>
        </listitem>

        <listitem>
          <para>Commit your changes to the modules file.</para>

          <para><screen>
$ cvs commit -m "Added the tc module." modules
</screen></para>
        </listitem>

        <listitem>
          <para>Release the modules module.</para>

          <para><screen>
$ cd ..
$ cvs release -d CVSROOT
</screen></para>
        </listitem>
      </orderedlist>
    </sect1>
  </chapter>

  <chapter id="Revisions">
    <title>Revisions</title>

    <para>For many uses of cvsnt, one doesn't need to worry too much about
    revision numbers; cvsnt assigns numbers such as <command>1.1</command>,
    <command>1.2</command>, and so on, and that is all one needs to know.
    However, some people prefer to have more knowledge and control concerning
    how cvsnt assigns revision numbers.</para>

    <para>If one wants to keep track of a set of revisions involving more than
    one file, such as which revisions went into a particular release, one uses
    a <firstterm>tag</firstterm>, which is a symbolic revision which can be
    assigned to a numeric revision in each file.</para>

    <sect1 id="Revision-numbers">
      <title>Revision numbers</title>

      <para><indexterm>
          <primary>Revision numbers</primary>
        </indexterm><indexterm>
          <primary>Revision tree</primary>
        </indexterm><indexterm>
          <primary>Linear development</primary>
        </indexterm><indexterm>
          <primary>Number, revision-</primary>
        </indexterm><indexterm>
          <primary>Decimal revision number</primary>
        </indexterm><indexterm>
          <primary>Branch number</primary>
        </indexterm><indexterm>
          <primary>Number, branch</primary>
        </indexterm> Each version of a file has a unique <firstterm>revision
      number</firstterm>. Revision numbers look like <command>1.1</command>,
      <command>1.2</command>, <command>1.3.2.2</command> or even
      <command>1.3.2.2.4.5</command>. A revision number always has an even
      number of period-separated decimal integers. By default revision 1.1 is
      the first revision of a file. Each successive revision is given a new
      number by increasing the rightmost number by one. The following figure
      displays a few revisions, with newer revisions to the right.</para>

      <para><screen>       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</screen></para>

      <para>It is also possible to end up with numbers containing more than
      one period, for example <command>1.3.2.2</command>. Such revisions
      represent revisions on branches (<xref
      linkend="Branching-and-merging" />); such revision numbers are explained
      in detail in <xref linkend="Branches-and-revisions" />.</para>
    </sect1>

    <sect1 id="Versions-revisions-releases">
      <title>Versions, revisions and releases</title>

      <para><indexterm>
          <primary>Revisions, versions and releases</primary>
        </indexterm><indexterm>
          <primary>Versions, revisions and releases</primary>
        </indexterm><indexterm>
          <primary>Releases, revisions and versions</primary>
        </indexterm> A file can have several versions, as described above.
      Likewise, a software product can have several versions. A software
      product is often given a version number such as
      <command>4.1.1</command>.</para>

      <para>Versions in the first sense are called
      <firstterm>revisions</firstterm> in this document, and versions in the
      second sense are called <firstterm>releases</firstterm>. To avoid
      confusion, the word <firstterm>version</firstterm> is almost never used
      in this document.</para>
    </sect1>

    <sect1 id="Assigning-revisions">
      <title>Assigning revisions</title>

      <para>By default, cvsnt will assign numeric revisions by leaving the
      first number the same and incrementing the second number. For example,
      <command>1.1</command>, <command>1.2</command>, <command>1.3</command>,
      etc.</para>

      <para>When adding a new file, the second number will always be one and
      the first number will equal the highest first number of any file in that
      directory. For example, the current directory contains files whose
      highest numbered revisions are <command>1.7</command>,
      <command>3.1</command>, and <command>4.12</command>, then an added file
      will be given the numeric revision <command>4.1</command>.</para>

      <para>There is no reason to care about the revision numbers--it is
      easier to treat them as internal numbers that cvsnt maintains, and tags
      provide a better way to distinguish between things like release 1 versus
      release 2 of your product (<xref linkend="Tags" />).</para>
    </sect1>

    <sect1 id="Tags">
      <title>Tags-Symbolic revisions</title>

      <para><indexterm>
          <primary>Tags</primary>
        </indexterm> The revision numbers live a life of their own. They need
      not have anything at all to do with the release numbers of your software
      product. Depending on how you use cvsnt the revision numbers might
      change several times between two releases. As an example, some of the
      source files that make up rcs 5.6 have the following revision numbers:
      <indexterm>
          <primary>rcs revision numbers</primary>
        </indexterm> <screen>ci.c            5.21
co.c            5.9
ident.c         5.3
rcs.c           5.12
rcsbase.h       5.11
rcsdiff.c       5.10
rcsedit.c       5.11
rcsfcmp.c       5.9
rcsgen.c        5.10
rcslex.c        5.11
rcsmap.c        5.2
rcsutil.c       5.10
</screen></para>

      <para><indexterm>
          <primary>tag, command, introduction</primary>
        </indexterm><indexterm>
          <primary>Tag, symbolic name</primary>
        </indexterm><indexterm>
          <primary>Symbolic name (tag)</primary>
        </indexterm><indexterm>
          <primary>Name, symbolic (tag)</primary>
        </indexterm><indexterm>
          <primary>HEAD, as reserved tag name</primary>
        </indexterm><indexterm>
          <primary>BASE, as reserved tag name</primary>
        </indexterm>You can use the <command>tag</command> command to give a
      symbolic name to a certain revision of a file. You can use the
      <command>-v</command> flag to the <command>status</command> command to
      see all tags that a file has, and which revision numbers they represent.
      Tag names must start with an uppercase or lowercase letter and can
      contain uppercase and lowercase letters, digits, <command>-</command>,
      and <command>_</command>. The two tag names <command>BASE</command> and
      <command>HEAD</command> are reserved for use by cvsnt. It is expected
      that future names which are special to cvsnt will be specially named,
      for example by starting with <command>.</command>, rather than being
      named analogously to <command>BASE</command> and
      <command>HEAD</command>, to avoid conflicts with actual tag
      names.</para>

      <para>You'll want to choose some convention for naming tags, based on
      information such as the name of the program and the version number of
      the release. For example, one might take the name of the program,
      immediately followed by the version number with <command>.</command>
      changed to <command>-</command>, so that cvsnt 1.9 would be tagged with
      the name <command>cvs1-9</command>. If you choose a consistent
      convention, then you won't constantly be guessing whether a tag is
      <command>cvs-1-9</command> or <command>cvs1_9</command> or what. You
      might even want to consider enforcing your convention in the taginfo
      file (<xref linkend="user-defined-logging" />).</para>

      <para><indexterm>
          <primary>Adding a tag</primary>
        </indexterm><indexterm>
          <primary>Tag, example</primary>
        </indexterm>The following example shows how you can add a tag to a
      file. The commands must be issued inside your working directory. That
      is, you should issue the command in the directory where
      <command>backend.c</command> resides.</para>

      <para><screen>
$ cvs tag rel-0-4 backend.c
T backend.c
$ cvs status -v backend.c
===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    rcs Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         (none)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-0-4                     (revision: 1.4)

</screen></para>

      <para>For a complete summary of the syntax of <command>cvs
      tag</command>, including the various options, see <xref
      linkend="tag" />.</para>

      <para>There is seldom reason to tag a file in isolation. A more common
      use is to tag all the files that constitute a module with the same tag
      at strategic points in the development life-cycle, such as when a
      release is made.</para>

      <para><screen>
$ cvs tag rel-1-0 .
cvs tag: Tagging .
T Makefile
T backend.c
T driver.c
T frontend.c
T parser.c
</screen></para>

      <para>(When you give cvsnt a directory as argument, it generally applies
      the operation to all the files in that directory, and (recursively), to
      any subdirectories that it may contain. <xref
      linkend="Recursive-behavior" />.)</para>

      <para><indexterm>
          <primary>Retrieving an old revision using tags</primary>
        </indexterm><indexterm>
          <primary>Tag, retrieving old revisions</primary>
        </indexterm>The <command>checkout</command> command has a flag,
      <command>-r</command>, that lets you check out a certain revision of a
      module. This flag makes it easy to retrieve the sources that make up
      release 1.0 of the module <command>tc</command> at any time in the
      future:</para>

      <para><screen>
$ cvs checkout -r rel-1-0 tc
</screen></para>

      <para>This is useful, for instance, if someone claims that there is a
      bug in that release, but you cannot find the bug in the current working
      copy.</para>

      <para>You can also check out a module as it was at any given date. <xref
      linkend="checkout-options" />. When specifying <command>-r</command> to
      any of these commands, you will need beware of sticky tags; see <xref
      linkend="Sticky-tags" />.</para>

      <para>When you tag more than one file with the same tag you can think
      about the tag as "a curve drawn through a matrix of filename vs.
      revision number." Say we have 5 files with the following
      revisions:</para>

      <para><screen>
        file1   file2   file3   file4   file5

        1.1     1.1     1.1     1.1  /--1.1*      &lt;-*-  TAG
        1.2*-   1.2     1.2    -1.2*-
        1.3  \- 1.3*-   1.3   / 1.3
        1.4          \  1.4  /  1.4
                      \-1.5*-   1.5
                        1.6
     </screen></para>

      <para>At some time in the past, the <command>*</command> versions were
      tagged. You can think of the tag as a handle attached to the curve drawn
      through the tagged revisions. When you pull on the handle, you get all
      the tagged revisions. Another way to look at it is that you "sight"
      through a set of revisions that is "flat" along the tagged revisions,
      like this:</para>

      <para><screen>
        file1   file2   file3   file4   file5

                        1.1
                        1.2
                1.1     1.3                       _
        1.1     1.2     1.4     1.1              /
        1.2*----1.3*----1.5*----1.2*----1.1     (--- &lt;--- Look here
        1.3             1.6     1.3              \_
        1.4                     1.4
                                1.5
     </screen></para>
    </sect1>

    <sect1 id="Tagging-the-working-directory">
      <title>Specifying what to tag from the working directory</title>

      <para><indexterm>
          <primary>tag</primary>
        </indexterm>The example in the previous section demonstrates one of
      the most common ways to choose which revisions to tag. Namely, running
      the <command>cvs tag</command> command without arguments causes cvsnt to
      select the revisions which are checked out in the current working
      directory. For example, if the copy of <command>backend.c</command> in
      working directory was checked out from revision 1.4, then cvsnt will tag
      revision 1.4. Note that the tag is applied immediately to revision 1.4
      in the repository; tagging is not like modifying a file, or other
      operations in which one first modifies the working directory and then
      runs <command>cvs commit</command> to transfer that modification to the
      repository.</para>

      <para>One potentially surprising aspect of the fact that <command>cvs
      tag</command> operates on the repository is that you are tagging the
      checked-in revisions, which may differ from locally modified files in
      your working directory. If you want to avoid doing this by mistake,
      specify the <command>-c</command> option to <command>cvs tag</command>.
      If there are any locally modified files, cvsnt will abort with an error
      before it tags any files:</para>

      <para><screen>$ cvs tag -c rel-0-4
cvs tag: backend.c is locally modified
cvs [tag aborted]: correct the above errors first!
</screen></para>
    </sect1>

    <sect1 id="Tagging-by-date-tag">
      <title>Specifying what to tag by date or revision</title>

      <para><indexterm>
          <primary>rtag</primary>
        </indexterm> The <command>cvs rtag</command> command tags the
      repository as of a certain date or time (or can be used to tag the
      latest revision). <command>rtag</command> works directly on the
      repository contents (it requires no prior checkout and does not look for
      a working directory).</para>

      <para>The following options specify which date or revision to tag. See
      <xref linkend="Common-options" />, for a complete description of
      them.</para>

      <variablelist>
        <varlistentry>
          <term>-D <varname>date</varname></term>

          <listitem>
            <para>Tag the most recent revision no later than
            <varname>date</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-f</term>

          <listitem>
            <para>Only useful with the <command>-D
            <varname>date</varname></command> or <command>-r
            <varname>tag</varname></command> flags. If no matching revision is
            found, use the most recent revision (instead of ignoring the
            file).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-r <varname>tag</varname></term>

          <listitem>
            <para>Only tag those files that contain existing tag
            <varname>tag</varname>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The <command>cvs tag</command> command also allows one to specify
      files by revision or date, using the same <command>-r</command>,
      <command>-D</command>, and <command>-f</command> options. However, this
      feature is probably not what you want. The reason is that <command>cvs
      tag</command> chooses which files to tag based on the files that exist
      in the working directory, rather than the files which existed as of the
      given tag/date. Therefore, you are generally better off using
      <command>cvs rtag</command>. The exceptions might be cases like:</para>

      <para><screen>
cvs tag -r 1.4 backend.c
</screen></para>
    </sect1>

    <sect1 id="Modifying-tags">
      <title>Deleting, moving, and renaming tags</title>

      <para>Normally one does not modify tags. They exist in order to record
      the history of the repository and so deleting them or changing their
      meaning would, generally, not be what you want.</para>

      <para>However, there might be cases in which one uses a tag temporarily
      or accidentally puts one in the wrong place. Therefore, one might
      delete, move, or rename a tag. Warning: the commands in this section are
      dangerous; they permanently discard historical information and it can
      difficult or impossible to recover from errors. If you are a cvsnt
      administrator, you may consider restricting these commands with taginfo
      (<xref linkend="user-defined-logging" />).</para>

      <para><indexterm>
          <primary>Deleting tags</primary>
        </indexterm><indexterm>
          <primary>Removing tags</primary>
        </indexterm><indexterm>
          <primary>Tags, deleting</primary>
        </indexterm>To delete a tag, specify the <command>-d</command> option
      to either <command>cvs tag</command> or <command>cvs rtag</command>. For
      example:</para>

      <para><screen>cvs rtag -d rel-0-4 tc
</screen></para>

      <para>deletes the tag <command>rel-0-4</command> from the module
      <command>tc</command>.</para>

      <para><indexterm>
          <primary>Moving tags</primary>
        </indexterm><indexterm>
          <primary>Tags, moving</primary>
        </indexterm>When we say <firstterm>move</firstterm> a tag, we mean to
      make the same name point to different revisions. For example, the
      <command>stable</command> tag may currently point to revision 1.4 of
      <command>backend.c</command> and perhaps we want to make it point to
      revision 1.6. To move a tag, specify the <command>-F</command> option to
      either <command>cvs tag</command> or <command>cvs rtag</command>. For
      example, the task just mentioned might be accomplished as:</para>

      <para><screen>
cvs tag -r 1.6 -F stable backend.c
</screen></para>

      <para>By default CVS doesn't allow moving and deleting branch tags, as
      this should not be done without understanding the issues that this
      raises. To override this, specify the <command>-B</command> option on
      the command line.</para>

      <para><indexterm>
          <primary>Renaming tags</primary>
        </indexterm><indexterm>
          <primary>Tags, renaming</primary>
        </indexterm>When we say <firstterm>rename</firstterm> a tag, we mean
      to make a different name point to the same revisions as the old tag. For
      example, one may have misspelled the tag name and want to correct it
      (hopefully before others are relying on the old spelling). To rename a
      tag, first create a new tag using the <command>-r</command> option to
      <command>cvs rtag</command>, and then delete the old name. This leaves
      the new tag on exactly the same files as the old tag. For
      example:</para>

      <para><screen>
cvs rtag -r old-name-0-4 rel-0-4 tc
cvs rtag -d old-name-0-4 tc
</screen></para>
    </sect1>

    <sect1 id="Tagging-add-remove">
      <title>Tagging and adding and removing files</title>

      <para>The subject of exactly how tagging interacts with adding and
      removing files is somewhat obscure; for the most part cvsnt will keep
      track of whether files exist or not without too much fussing. By
      default, tags are applied to only files which have a revision
      corresponding to what is being tagged. Files which did not exist yet, or
      which were already removed, simply omit the tag, and cvsnt knows to
      treat the absence of a tag as meaning that the file didn't exist as of
      that tag.</para>

      <para>However, this can lose a small amount of information. For example,
      suppose a file was added and then removed. Then, if the tag is missing
      for that file, there is no way to know whether the tag refers to the
      time before the file was added, or the time after it was removed. If you
      specify the <command>-r</command> option to <command>cvs rtag</command>,
      then cvsnt tags the files which have been removed, and thereby avoids
      this problem. For example, one might specify <command>-r HEAD</command>
      to tag the head.</para>
    </sect1>

    <sect1 id="Alias-Tags">
      <title>Alias tags</title>

      <para><indexterm>
          <primary>Alias tags</primary>
        </indexterm> <indexterm>
          <primary>Tags, alias</primary>
        </indexterm></para>

      <para>Normally setting a tag equal to a branch with the
      <command>-r</command> causes the tag to be set to the revison at the
      head of the branch at that point. The <command>-A</command> option to
      tag and rtag changes this behaviour so that the new tag becomes an alias
      name for the existing branch. This allows you to switch active branches
      without having to change the clients.</para>
    </sect1>

    <sect1 id="Commit-Identifiers">
      <title>Commit identifiers</title>

      <para><indexterm>
          <primary>Commit identifiers</primary>
        </indexterm><indexterm>
          <primary>commitid</primary>
        </indexterm><indexterm>
          <primary>sessionid</primary>
        </indexterm> <indexterm>
          <primary>Changesets</primary>
        </indexterm></para>

      <para>A special 'meta-tag' is applied to each committed change to the
      repository, which uniquely identifies that commit. This is randomly
      generated string, and has no significance except that it is unique. It
      is used to group files from a single commit into a changeset.</para>

      <para>To operate on a single the command the <command>@</command> and
      <command>@&lt;</command> prefixes define the committed revision, and the
      revision before the commit respectively.</para>

      <para>For example: <screen>
$ cvs diff -r "@&lt;91c41475ddc4ad2" -r @91c41475ddc4ad2 foo.c
Index: a.txt
===================================================================
RCS file: d:/repo/test/foo.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
...
</screen></para>

      <para>Note that many shells treat the <command>&lt;</command> symbol as
      special, so that part of the command will need to be quoted.</para>
    </sect1>

    <sect1 id="Sticky-tags">
      <title>Sticky tags</title>

      <para><indexterm>
          <primary>Sticky tags</primary>
        </indexterm><indexterm>
          <primary>Tags, sticky</primary>
        </indexterm></para>

      <para>Sometimes a working copy's revision has extra data associated with
      it, for example it might be on a branch (<xref
      linkend="Branching-and-merging" />), or restricted to versions prior to
      a certain date by <command>checkout -D</command> or <command>update
      -D</command>. Because this data persists - that is, it applies to
      subsequent commands in the working copy - we refer to it as
      <firstterm>sticky</firstterm>.</para>

      <para>Most of the time, stickiness is an obscure aspect of cvsnt that
      you don't need to think about. However, even if you don't want to use
      the feature, you may need to know <emphasis>something</emphasis> about
      sticky tags (for example, how to avoid them!).</para>

      <para>You can use the <command>status</command> command to see if any
      sticky tags or dates are set:</para>

      <para><screen>$ cvs status driver.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
    rcs Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

</screen></para>

      <para><indexterm>
          <primary>Resetting sticky tags</primary>
        </indexterm><indexterm>
          <primary>Sticky tags, resetting</primary>
        </indexterm><indexterm>
          <primary>Deleting sticky tags</primary>
        </indexterm>The sticky tags will remain on your working files until
      you delete them with <command>cvs update -A</command>. The
      <command>-A</command> option retrieves the version of the file from the
      head of the trunk, and forgets any sticky tags, dates, or
      options.</para>

      <para><indexterm>
          <primary>Sticky date</primary>
        </indexterm>The most common use of sticky tags is to identify which
      branch one is working on, as described in <xref
      linkend="Accessing-branches" />. However, non-branch sticky tags have
      uses as well. For example, suppose that you want to avoid updating your
      working directory, to isolate yourself from possibly destabilizing
      changes other people are making. You can, of course, just refrain from
      running <command>cvs update</command>. But if you want to avoid updating
      only a portion of a larger tree, then sticky tags can help. If you check
      out a certain revision (such as 1.4) it will become sticky. Subsequent
      <command>cvs update</command> commands will not retrieve the latest
      revision until you reset the tag with <command>cvs update -A</command>.
      Likewise, use of the <command>-D</command> option to
      <command>update</command> or <command>checkout</command> sets a
      <firstterm>sticky date</firstterm>, which, similarly, causes that date
      to be used for future retrievals.</para>

      <para>People often want to retrieve an old version of a file without
      setting a sticky tag. This can be done with the <command>-p</command>
      option to <command>checkout</command> or <command>update</command>,
      which sends the contents of the file to standard output. For example:
      <screen>
$ cvs update -p -r 1.1 file1 &gt;file1
===================================================================
Checking out file1
rcs:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
VERS: 1.1
***************
$
</screen></para>

      <para>However, this isn't the easiest way, if you are asking how to undo
      a previous checkin (in this example, put <command>file1</command> back
      to the way it was as of revision 1.1). In that case you are better off
      using the <command>-j</command> option to <command>update</command>; for
      further discussion see <xref linkend="Merging-two-revisions" />.</para>
    </sect1>
  </chapter>

  <chapter id="Branching-and-merging">
    <title>Branching and merging</title>

    <para><indexterm>
        <primary>Branching</primary>
      </indexterm><indexterm>
        <primary>Merging</primary>
      </indexterm><indexterm>
        <primary>Copying changes</primary>
      </indexterm><indexterm>
        <primary>Main trunk and branches</primary>
      </indexterm><indexterm>
        <primary>Revision tree, making branches</primary>
      </indexterm><indexterm>
        <primary>Branches, copying changes between</primary>
      </indexterm><indexterm>
        <primary>Changes, copying between branches</primary>
      </indexterm><indexterm>
        <primary>Modifications, copying between branches</primary>
      </indexterm> cvsnt allows you to isolate changes onto a separate line of
    development, known as a <firstterm>branch</firstterm>. When you change
    files on a branch, those changes do not appear on the main trunk or other
    branches.</para>

    <para>Later you can move changes from one branch to another branch (or the
    main trunk) by <firstterm>merging</firstterm>. Merging involves first
    running <command>cvs update -j</command>, to merge the changes into the
    working directory. You can then commit that revision, and thus effectively
    copy the changes onto another branch.</para>

    <sect1 id="Branches-motivation">
      <title>What branches are good for</title>

      <para><indexterm>
          <primary>Branches motivation</primary>
        </indexterm><indexterm>
          <primary>What branches are good for</primary>
        </indexterm><indexterm>
          <primary>Motivation for branches</primary>
        </indexterm> Suppose that release 1.0 of tc has been made. You are
      continuing to develop tc, planning to create release 1.1 in a couple of
      months. After a while your customers start to complain about a fatal
      bug. You check out release 1.0 (<xref linkend="Tags" />) and find the
      bug (which turns out to have a trivial fix). However, the current
      revision of the sources are in a state of flux and are not expected to
      be stable for at least another month. There is no way to make a bugfix
      release based on the newest sources.</para>

      <para>The thing to do in a situation like this is to create a
      <firstterm>branch</firstterm> on the revision trees for all the files
      that make up release 1.0 of tc. You can then make modifications to the
      branch without disturbing the main trunk. When the modifications are
      finished you can elect to either incorporate them on the main trunk, or
      leave them on the branch.</para>
    </sect1>

    <sect1 id="Creating-a-branch">
      <title>Creating a branch</title>

      <para><indexterm>
          <primary>Creating a branch</primary>
        </indexterm><indexterm>
          <primary>Branch, creating a</primary>
        </indexterm><indexterm>
          <primary>tag, creating a branch using</primary>
        </indexterm><indexterm>
          <primary>rtag, creating a branch using</primary>
        </indexterm> You can create a branch with <command>tag -b</command>;
      for example, assuming you're in a working copy:</para>

      <para><screen>$ cvs tag -b rel-1-0-patches
</screen></para>

      <para>This splits off a branch based on the current revisions in the
      working copy, assigning that branch the name
      <command>rel-1-0-patches</command>.</para>

      <para>It is important to understand that branches get created in the
      repository, not in the working copy. Creating a branch based on current
      revisions, as the above example does, will <emphasis>not</emphasis>
      automatically switch the working copy to be on the new branch. For
      information on how to do that, see <xref
      linkend="Accessing-branches" />.</para>

      <para>You can also create a branch without reference to any working
      copy, by using <command>rtag</command>:</para>

      <para><screen>
$ cvs rtag -b -r rel-1-0 rel-1-0-patches tc
</screen></para>

      <para><command>-r rel-1-0</command> says that this branch should be
      rooted at the revision that corresponds to the tag
      <command>rel-1-0</command>. It need not be the most recent revision -
      it's often useful to split a branch off an old revision (for example,
      when fixing a bug in a past release otherwise known to be
      stable).</para>

      <para>As with <command>tag</command>, the <command>-b</command> flag
      tells <command>rtag</command> to create a branch (rather than just a
      symbolic revision name). Note that the numeric revision number that
      matches <command>rel-1-0</command> will probably be different from file
      to file.</para>

      <para>So, the full effect of the command is to create a new branch -
      named <command>rel-1-0-patches</command> - in module
      <command>tc</command>, rooted in the revision tree at the point tagged
      by <command>rel-1-0</command>.</para>
    </sect1>

    <sect1 id="Accessing-branches">
      <title>Accessing branches</title>

      <para><indexterm>
          <primary>Check out a branch</primary>
        </indexterm><indexterm>
          <primary>Retrieve a branch</primary>
        </indexterm><indexterm>
          <primary>Access a branch</primary>
        </indexterm><indexterm>
          <primary>Identifying a branch</primary>
        </indexterm><indexterm>
          <primary>Branch, check out</primary>
        </indexterm><indexterm>
          <primary>Branch, retrieving</primary>
        </indexterm><indexterm>
          <primary>Branch, accessing</primary>
        </indexterm><indexterm>
          <primary>Branch, identifying</primary>
        </indexterm> You can retrieve a branch in one of two ways: by checking
      it out fresh from the repository, or by switching an existing working
      copy over to the branch.</para>

      <para>To check out a branch from the repository, invoke
      <command>checkout</command> with the <command>-r</command> flag,
      followed by the tag name of the branch (<xref
      linkend="Creating-a-branch" />):</para>

      <para><screen>$ cvs checkout -r rel-1-0-patches tc
</screen></para>

      <para>Or, if you already have a working copy, you can switch it to a
      given branch with <command>update -r</command>:</para>

      <para><screen>
$ cvs update -r rel-1-0-patches tc
</screen></para>

      <para>or equivalently:</para>

      <para><screen>
$ cd tc
$ cvs update -r rel-1-0-patches
</screen></para>

      <para>It does not matter if the working copy was originally on the main
      trunk or on some other branch - the above command will switch it to the
      named branch. And similarly to a regular <command>update</command>
      command, <command>update -r</command> merges any changes you have made,
      notifying you of conflicts where they occur.</para>

      <para>Once you have a working copy tied to a particular branch, it
      remains there until you tell it otherwise. This means that changes
      checked in from the working copy will add new revisions on that branch,
      while leaving the main trunk and other branches unaffected.</para>

      <para><indexterm>
          <primary>Branches, sticky</primary>
        </indexterm>To find out what branch a working copy is on, you can use
      the <command>status</command> command. In its output, look for the field
      named <command>Sticky tag</command> (<xref linkend="Sticky-tags" />) -
      that's cvsnt's way of telling you the branch, if any, of the current
      working files:</para>

      <para><screen>
$ cvs status -v driver.c backend.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7     Sat Dec  5 18:25:54 1992
    rcs Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.7.2)
        rel-1-0                     (revision: 1.7)

===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    rcs Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.4.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.4.2)
        rel-1-0                     (revision: 1.4)
        rel-0-4                     (revision: 1.4)

</screen></para>

      <para>Don't be confused by the fact that the branch numbers for each
      file are different (<command>1.7.2</command> and
      <command>1.4.2</command> respectively). The branch tag is the same,
      <command>rel-1-0-patches</command>, and the files are indeed on the same
      branch. The numbers simply reflect the point in each file's revision
      history at which the branch was made. In the above example, one can
      deduce that <command>driver.c</command> had been through more changes
      than <command>backend.c</command> before this branch was created.</para>

      <para>See <xref linkend="Branches-and-revisions" /> for details about
      how branch numbers are constructed.</para>
    </sect1>

    <sect1 id="Branches-and-revisions">
      <title>Branches and revisions</title>

      <para><indexterm>
          <primary>Branch number</primary>
        </indexterm><indexterm>
          <primary>Number, branch</primary>
        </indexterm><indexterm>
          <primary>Revision numbers (branches)</primary>
        </indexterm> Ordinarily, a file's revision history is a linear series
      of increments (<xref linkend="Revision-numbers" />):</para>

      <para><screen>       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</screen></para>

      <para>However, cvsnt is not limited to linear development. The
      <firstterm>revision tree</firstterm> can be split into
      <firstterm>branches</firstterm>, where each branch is a self-maintained
      line of development. Changes made on one branch can easily be moved back
      to the main trunk.</para>

      <para>Each branch has a <firstterm>branch number</firstterm>, consisting
      of an odd number of period-separated decimal integers. The branch number
      is created by appending an integer to the revision number where the
      corresponding branch forked off. Having branch numbers allows more than
      one branch to be forked off from a certain revision.</para>

      <para>All revisions on a branch have revision numbers formed by
      appending an ordinal number to the branch number. The following figure
      illustrates branching with an example.</para>

      <para><screen>
                                                      +-------------+
                           Branch 1.2.2.3.2 -&gt;        ! 1.2.2.3.2.1 !
                                                    / +-------------+
                                                   /
                                                  /
                 +---------+    +---------+    +---------+
Branch 1.2.2 -&gt; _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
               / +---------+    +---------+    +---------+
              /
             /
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !  &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+    +---------+
Branch 1.2.4 -&gt; +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                    +---------+    +---------+    +---------+

     </screen></para>

      <para>The exact details of how the branch number is constructed is not
      something you normally need to be concerned about, but here is how it
      works: When cvsnt creates a branch number it picks the first unused even
      integer, starting with 2. So when you want to create a branch from
      revision 6.4 it will be numbered 6.4.2. All branch numbers ending in a
      zero (such as 6.4.0) are used internally by cvsnt (<xref
      linkend="Magic-branch-numbers" />). The branch 1.1.1 has a special
      meaning. <xref linkend="Tracking-sources" />.</para>
    </sect1>

    <sect1 id="Magic-branch-numbers">
      <title>Magic branch numbers</title>

      <para>This section describes a cvsnt feature called <firstterm>magic
      branches</firstterm>. For most purposes, you need not worry about magic
      branches; cvsnt handles them for you. However, they are visible to you
      in certain circumstances, so it may be useful to have some idea of how
      it works.</para>

      <para>Externally, branch numbers consist of an odd number of
      dot-separated decimal integers. <xref linkend="Revision-numbers" />.
      That is not the whole truth, however. For efficiency reasons cvsnt
      sometimes inserts an extra 0 in the second rightmost position (1.2.4
      becomes 1.2.0.4, 8.9.10.11.12 becomes 8.9.10.11.0.12 and so on).</para>

      <para>cvsnt does a pretty good job at hiding these so called magic
      branches, but in a few places the hiding is incomplete:</para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>The magic branch number appears in the output from
          <command>cvs log</command>.</para>
        </listitem>

        <listitem>
          <para>You cannot specify a symbolic branch name to <command>cvs
          admin</command>.</para>
        </listitem>
      </itemizedlist>

      <para>You can use the <command>admin</command> command to reassign a
      symbolic name to a branch the way rcs expects it to be. If
      <command>R4patches</command> is assigned to the branch 1.4.2 (magic
      branch number 1.4.0.2) in file <command>numbers.c</command> you can do
      this:</para>

      <para><screen>
$ cvs admin -NR4patches:1.4.2 numbers.c
</screen></para>

      <para>It only works if at least one revision is already committed on the
      branch. Be very careful so that you do not assign the tag to the wrong
      number. (There is no way to see how the tag was assigned
      yesterday).</para>
    </sect1>

    <sect1 id="Merging-a-branch">
      <title>Merging an entire branch</title>

      <para><indexterm>
          <primary>Merging a branch</primary>
        </indexterm><indexterm>
          <primary>-j (merging branches)</primary>
        </indexterm> You can merge changes made on a branch into your working
      copy by giving the <command>-j <varname>branchname</varname></command>
      flag to the <command>update</command> subcommand. With one <command>-j
      <varname>branchname</varname></command> option it merges the changes
      made between the point where the branch was last merged and newest
      revision on that branch (into your working copy).</para>

      <para>If you wish to revert to the older CVS behaviour of merging from
      the point the branch forked, specify the <command>-b</command>
      option.</para>

      <para>If you are updating from an Unix CVS server of older cvsnt server
      that doesn't support merge points, then the merge will always be done
      from the branch point.</para>

      <para><indexterm>
          <primary>Join</primary>
        </indexterm>The <command>-j</command> stands for "join".</para>

      <para><indexterm>
          <primary>Branch merge example</primary>
        </indexterm><indexterm>
          <primary>Example, branch merge</primary>
        </indexterm><indexterm>
          <primary>Merge, branch example</primary>
        </indexterm>Consider this revision tree:</para>

      <para><screen>+-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !      &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+
Branch R1fix -&gt; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</screen></para>

      <para>The branch 1.2.2 has been given the tag (symbolic name)
      <command>R1fix</command>. The following example assumes that the module
      <command>mod</command> contains only one file,
      <command>m.c</command>.</para>

      <para><screen>
$ cvs checkout mod               # Retrieve the latest revision, 1.4

$ cvs update -j R1fix m.c        # Merge all changes made on the branch,
                                 # i.e. the changes between revision 1.2
                                 # and 1.2.2.2, into your working copy
                                 # of the file.

$ cvs commit -m "Included R1fix" # Create revision 1.5.
</screen></para>

      <para>A conflict can result from a merge operation. If that happens, you
      should resolve it before committing the new revision. <xref
      linkend="Conflicts-example" />.</para>

      <para>If your source files contain keywords (<xref
      linkend="Keyword-substitution" />), you might be getting more conflicts
      than strictly necessary. See <xref linkend="Merging-and-keywords" />,
      for information on how to avoid this.</para>

      <para>The <command>checkout</command> command also supports the
      <command>-j <varname>branchname</varname></command> flag. The same
      effect as above could be achieved with this:</para>

      <para><screen>
$ cvs checkout -j R1fix mod
$ cvs commit -m "Included R1fix"
</screen></para>

      <para>It should be noted that <command>update -j
      <varname>tagname</varname></command> will also work but may not produce
      the desired result. <xref linkend="Merging-adds-and-removals" />, for
      more.</para>
    </sect1>

    <sect1 id="Merging-more-than-once">
      <title>Merging from a branch several times</title>

      <para>Continuing our example, the revision tree now looks like
      this:</para>

      <para><screen>+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+
Branch R1fix -&gt; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</screen></para>

      <para>where the starred line represents the merge from the
      <command>R1fix</command> branch to the main trunk, as just
      discussed.</para>

      <para>Now suppose that development continues on the
      <command>R1fix</command> branch:</para>

      <para><screen>
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+    +---------+
Branch R1fix -&gt; +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                    +---------+    +---------+    +---------+
</screen></para>

      <para>and then you want to merge those new changes onto the main trunk.
      If you just use the <command>cvs update -j R1fix m.c</command> command
      again, cvsnt will remember that you have previously merged any only
      merge the new changes. You can override this by using the <command>cvs
      update -b -j</command> command, which will attempt to merge again the
      changes which you have already merged, which can have undesirable side
      effects.</para>
    </sect1>

    <sect1 id="Merging-two-revisions">
      <title>Merging differences between any two revisions</title>

      <para><indexterm>
          <primary>Merging two revisions</primary>
        </indexterm><indexterm>
          <primary>Revisions, merging differences between</primary>
        </indexterm><indexterm>
          <primary>Differences, merging</primary>
        </indexterm> With two <command>-j
      <varname>revision</varname></command> flags, the
      <command>update</command> (and <command>checkout</command>) command can
      merge the differences between any two revisions into your working
      file.</para>

      <para><indexterm>
          <primary>Undoing a change</primary>
        </indexterm><indexterm>
          <primary>Removing a change</primary>
        </indexterm><screen>$ cvs update -j 1.5 -j 1.3 backend.c
</screen></para>

      <para>will undo all changes made between revision 1.3 and 1.5. Note the
      order of the revisions!</para>

      <para>If you try to use this option when operating on multiple files,
      remember that the numeric revisions will probably be very different
      between the various files. You almost always use symbolic tags rather
      than revision numbers when operating on multiple files.</para>

      <para><indexterm>
          <primary>Restoring old version of removed file</primary>
        </indexterm>Specifying two <command>-j</command> options can also undo
      file removals or additions. For example, suppose you have a file named
      <command>file1</command> which existed as revision 1.1, and you then
      removed it (thus adding a dead revision 1.2). Now suppose you want to
      add it again, with the same contents it had previously. Here is how to
      do it:</para>

      <para><screen>
$ cvs update -j 1.2 -j 1.1 file1
U file1
$ cvs commit -m test
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  &lt;--  file1
new revision: 1.3; previous revision: 1.2
done
$
</screen></para>
    </sect1>

    <sect1 id="Merging-adds-and-removals">
      <title>Merging can add or remove files</title>

      <para>If the changes which you are merging involve removing or adding
      some files, <command>update -j</command> will reflect such additions or
      removals.</para>

      <para>For example: <screen>cvs update -A
touch a b c
cvs add a b c ; cvs ci -m "added" a b c
cvs tag -b branchtag
cvs update -r branchtag
touch d ; cvs add d
rm a ; cvs rm a
cvs ci -m "added d, removed a"
cvs update -A
cvs update -jbranchtag
</screen></para>

      <para>After these commands are executed and a <command>cvs
      commit</command> is done, file <command>a</command> will be removed and
      file <command>d</command> added in the main branch.</para>

      <para>Note that using a single static tag (<command>-j
      <varname>tagname</varname></command>) rather than a dynamic tag
      (<command>-j <varname>branchname</varname></command>) to merge changes
      from a branch will usually not remove files which were removed on the
      branch since cvsnt does not automatically add static tags to dead
      revisions. The exception to this rule occurs when a static tag has been
      attached to a dead revision manually. Use the branch tag to merge all
      changes from the branch or use two static tags as merge endpoints to be
      sure that all intended changes are propogated in the merge.</para>
    </sect1>

    <sect1 id="Merging-and-keywords">
      <title>Merging and keywords</title>

      <para><indexterm>
          <primary>Merging, and keyword substitution</primary>
        </indexterm><indexterm>
          <primary>Keyword substitution, and merging</primary>
        </indexterm><indexterm>
          <primary>-j (merging branches), and keyword substitution</primary>
        </indexterm> If you merge files containing keywords (<xref
      linkend="Keyword-substitution" />), you will normally get numerous
      conflicts during the merge, because the keywords are expanded
      differently in the revisions which you are merging.</para>
    </sect1>
  </chapter>

  <chapter id="Recursive-behavior">
    <title>Recursive behavior</title>

    <para><indexterm>
        <primary>Recursive (directory descending)</primary>
      </indexterm><indexterm>
        <primary>Directory, descending</primary>
      </indexterm><indexterm>
        <primary>Descending directories</primary>
      </indexterm><indexterm>
        <primary>Subdirectories</primary>
      </indexterm> Almost all of the subcommands of cvsnt work recursively
    when you specify a directory as an argument. For instance, consider this
    directory structure:</para>

    <para><screen>      <command>$HOME</command>
        |
        +--<wordasword>tc</wordasword>
        |   |
            +--<wordasword>CVS</wordasword>
            |      (internal cvsnt files)
            +--<wordasword>Makefile</wordasword>
            +--<wordasword>backend.c</wordasword>
            +--<wordasword>driver.c</wordasword>
            +--<wordasword>frontend.c</wordasword>
            +--<wordasword>parser.c</wordasword>
            +--<wordasword>man</wordasword>
            |    |
            |    +--<wordasword>CVS</wordasword>
            |    |  (internal cvsnt files)
            |    +--<wordasword>tc.1</wordasword>
            |
            +--<wordasword>testing</wordasword>
                 |
                 +--<wordasword>CVS</wordasword>
                 |  (internal cvsnt files)
                 +--<wordasword>testpgm.t</wordasword>
                 +--<wordasword>test2.t</wordasword>
</screen></para>

    <para>If <command>tc</command> is the current working directory, the
    following is true:</para>

    <itemizedlist mark="bullet">
      <listitem>
        <para><command>cvs update testing</command> is equivalent to</para>

        <para><screen>cvs update testing/testpgm.t testing/test2.t
</screen></para>
      </listitem>

      <listitem>
        <para><command>cvs update testing man</command> updates all files in
        the subdirectories</para>
      </listitem>

      <listitem>
        <para><command>cvs update .</command> or just <command>cvs
        update</command> updates all files in the <command>tc</command>
        directory</para>
      </listitem>
    </itemizedlist>

    <para>If no arguments are given to <command>update</command> it will
    update all files in the current working directory and all its
    subdirectories. In other words, <command>.</command> is a default argument
    to <command>update</command>. This is also true for most of the cvsnt
    subcommands, not only the <command>update</command> command.</para>

    <para>The recursive behavior of the cvsnt subcommands can be turned off
    with the <command>-l</command> option. Conversely, the
    <command>-R</command> option can be used to force recursion if
    <command>-l</command> is specified in <command>~/.cvsrc</command> (<xref
    linkend="cvsrc" />).</para>

    <para><screen>
$ cvs update -l         # Don't update files in subdirectories
</screen></para>
  </chapter>

  <chapter id="Adding-and-removing">
    <title>Adding, removing, and renaming files and directories</title>

    <para>In the course of a project, one will often add new files. Likewise
    with removing or renaming, or with directories. The general concept to
    keep in mind in all these cases is that instead of making an irreversible
    change you want cvsnt to record the fact that a change has taken place,
    just as with modifying an existing file. The exact mechanisms to do this
    in cvsnt vary depending on the situation.</para>

    <sect1 id="Adding-files">
      <title>Adding files to a directory</title>

      <para><indexterm>
          <primary>Adding files</primary>
        </indexterm> To add a new file to a directory, follow these
      steps.</para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>You must have a working copy of the directory. <xref
          linkend="Getting-the-source" />.</para>
        </listitem>

        <listitem>
          <para>Create the new file inside your working copy of the
          directory.</para>
        </listitem>

        <listitem>
          <para>Use <command>cvs add <varname>filename</varname></command> to
          tell cvsnt that you want to version control the file. If the file
          contains binary data, specify <command>-kb</command> or
          <command>-kB</command> (<xref linkend="Binary-files" />).</para>
        </listitem>

        <listitem>
          <para>Use <command>cvs commit <varname>filename</varname></command>
          to actually check in the file into the repository. Other developers
          cannot see the file until you perform this step.</para>
        </listitem>
      </itemizedlist>

      <para>You can also use the <command>add</command> command to add a new
      directory.</para>

      <para>Unlike most other commands, the <command>add</command> command is
      not recursive. You cannot even type <command>cvs add foo/bar</command>!
      Instead, you have to</para>

      <para><screen>
$ cd foo
$ cvs add bar
</screen></para>

      <para><indexterm>
          <primary>add</primary>
        </indexterm> <function>cvs add</function> [<command>-k</command>
      kflag] [<command>-m</command> message] files ... <indexterm role="fn">
          <primary>cvs add</primary>
        </indexterm> Schedule <varname>files</varname> to be added to the
      repository. The files or directories specified with
      <command>add</command> must already exist in the current directory. To
      add a whole new directory hierarchy to the source repository (for
      example, files received from a third-party vendor), use the
      <command>import</command> command instead. <xref
      linkend="import" />.</para>

      <para>The added files are not placed in the source repository until you
      use <command>commit</command> to make the change permanent. Doing an
      <command>add</command> on a file that was removed with the
      <command>remove</command> command will undo the effect of the
      <command>remove</command>, unless a <command>commit</command> command
      intervened. <xref linkend="Removing-files" />, for an example.</para>

      <para>The <command>-k</command> option specifies the default way that
      this file will be checked out; for more information see <xref
      linkend="Substitution-modes" />.</para>

      <para>The <command>-m</command> option specifies a description for the
      file. This description appears in the history log (if it is enabled,
      <xref linkend="history-file" />). It will also be saved in the version
      history inside the repository when the file is committed. The
      <command>log</command> command displays this description. The
      description can be changed using <command>admin -t</command>. <xref
      linkend="admin" />. If you omit the <command>-m
      <varname>description</varname></command> flag, an empty string will be
      used. You will not be prompted for a description.</para>

      <para>For example, the following commands add the file
      <command>backend.c</command> to the repository:</para>

      <para><screen>
$ cvs add backend.c
$ cvs commit -m "Early version. Not yet compilable." backend.c
</screen></para>

      <para>When you add a file it is added only on the branch which you are
      working on (<xref linkend="Branching-and-merging" />). You can later
      merge the additions to another branch if you want (<xref
      linkend="Merging-adds-and-removals" />).</para>
    </sect1>

    <sect1 id="Removing-files">
      <title>Removing files</title>

      <para><indexterm>
          <primary>Removing files</primary>
        </indexterm><indexterm>
          <primary>Deleting files</primary>
        </indexterm><indexterm>
          <primary>Resurrecting old version of dead file</primary>
        </indexterm> Directories change. New files are added, and old files
      disappear. Still, you want to be able to retrieve an exact copy of old
      releases.</para>

      <para>Here is what you can do to remove a file, but remain able to
      retrieve old revisions:</para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Make sure that you have not made any uncommitted modifications
          to the file. <xref linkend="Viewing-differences" />, for one way to
          do that. You can also use the <command>status</command> or
          <command>update</command> command. If you remove the file without
          committing your changes, you will of course not be able to retrieve
          the file as it was immediately before you deleted it.</para>
        </listitem>

        <listitem>
          <para>Remove the file from your working copy of the directory. You
          can for instance use <command>rm</command>.</para>
        </listitem>

        <listitem>
          <para>Use <command>cvs remove <varname>filename</varname></command>
          to tell cvsnt that you really want to delete the file.</para>
        </listitem>

        <listitem>
          <para>Use <command>cvs commit <varname>filename</varname></command>
          to actually perform the removal of the file from the
          repository.</para>
        </listitem>
      </itemizedlist>

      <para>When you commit the removal of the file, cvsnt records the fact
      that the file no longer exists. It is possible for a file to exist on
      only some branches and not on others, or to re-add another file with the
      same name later. cvsnt will correctly create or not create the file,
      based on the <command>-r</command> and <command>-D</command> options
      specified to <command>checkout</command> or
      <command>update</command>.</para>

      <para><indexterm>
          <primary>Remove</primary>
        </indexterm> <function>cvs remove</function> [options] files ...
      <indexterm role="fn">
          <primary>cvs remove</primary>
        </indexterm> Schedule file(s) to be removed from the repository (files
      which have not already been removed from the working directory are not
      processed). This command does not actually remove the file from the
      repository until you commit the removal. For a full list of options, see
      <xref linkend="remove" />.</para>

      <para>Here is an example of removing several files:</para>

      <para><screen>
$ cd test
$ rm *.c
$ cvs remove
cvs remove: Removing .
cvs remove: scheduling a.c for removal
cvs remove: scheduling b.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
</screen></para>

      <para>As a convenience you can remove the file and <command>cvs
      remove</command> it in one step, by specifying the <command>-f</command>
      option. For example, the above example could also be done like
      this:</para>

      <para><screen>
$ cd test
$ cvs remove -f *.c
cvs remove: scheduling a.c for removal
cvs remove: scheduling b.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
</screen></para>

      <para>If you execute <command>remove</command> for a file, and then
      change your mind before you commit, you can undo the
      <command>remove</command> with an <command>add</command> command.</para>

      <para><screen>
$ ls
CVS   ja.h  oj.c
$ rm oj.c
$ cvs remove oj.c
cvs remove: scheduling oj.c for removal
cvs remove: use 'cvs commit' to remove this file permanently
$ cvs add oj.c
U oj.c
cvs add: oj.c, version 1.1.1.1, resurrected
</screen></para>

      <para>If you realize your mistake before you run the
      <command>remove</command> command you can use <command>update</command>
      to resurrect the file:</para>

      <para><screen>
$ rm oj.c
$ cvs update oj.c
cvs update: warning: oj.c was lost
U oj.c
</screen></para>

      <para>If you realize your mistake after running the
      <command>commit</command> command you can use <command>add</command> to
      resurrect the file:</para>

      <para><screen>
$ cvs remove foo.c
cvs remove: scheduling foo.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
$ cvs add foo.c
cvs add: foo.c, version 1.5, resurrected
U foo.c
cvs add: use 'cvs commit' to add this file permanently
$cvs ci -m "Oops shouldn't have deleted that..."
cvs commit: Examining .
cvs commit: Committing .
</screen></para>

      <para>When you remove a file it is removed only on the branch which you
      are working on (<xref linkend="Branching-and-merging" />). You can later
      merge the removals to another branch if you want (<xref
      linkend="Merging-adds-and-removals" />).</para>
    </sect1>

    <sect1 id="Removing-directories">
      <title>Removing directories</title>

      <para><indexterm>
          <primary>Removing directories</primary>
        </indexterm><indexterm>
          <primary>Directories, removing</primary>
        </indexterm> In concept removing directories is somewhat similar to
      removing files--you want the directory to not exist in your current
      working directories, but you also want to be able to retrieve old
      releases in which the directory existed.</para>

      <para>The way that you remove a directory is to remove all the files in
      it. You don't remove the directory itself; there is no way to do that.
      Instead you specify the <command>-P</command> option to <command>cvs
      update</command> or <command>cvs checkout</command>, which will cause
      cvsnt to remove empty directories from working directories. (Note that
      <command>cvs export</command> always removes empty directories.)
      Probably the best way to do this is to always specify
      <command>-P</command>; if you want an empty directory then put a dummy
      file (for example <command>.keepme</command>) in it to prevent
      <command>-P</command> from removing it.</para>

      <para>Note that <command>-P</command> is implied by the
      <command>-r</command> or <command>-D</command> options of
      <command>checkout</command>. This way cvsnt will be able to correctly
      create the directory or not depending on whether the particular version
      you are checking out contains any files in that directory.</para>
    </sect1>

    <sect1 id="Moving-files">
      <title>Moving and renaming files</title>

      <para><indexterm>
          <primary>Moving files</primary>
        </indexterm><indexterm>
          <primary>Renaming files</primary>
        </indexterm><indexterm>
          <primary>Files, moving</primary>
        </indexterm> Moving files to a different directory or renaming them is
      not difficult, but some of the ways in which this works may be
      non-obvious. (Moving or renaming a directory is even harder. <xref
      linkend="Moving-directories" />.).</para>

      <para>The examples below assume that the file <varname>old</varname> is
      renamed to <varname>new</varname>.</para>

      <sect2 id="Native">
        <title>The Normal way to Rename</title>

        <para>The normal way to move a file is to issue a <command>cvs
        rename</command> command.</para>

        <para><screen>
$ cvs rename <varname>old</varname> <varname>new</varname>
$ cvs commit -m "Renamed <varname>old</varname> to <varname>new</varname>"
</screen></para>

        <para>This is the simplest way to move a file. It is not error prone,
        and it preserves the history of what was done. CVSNT clients can
        retrieve the original name by checking out an older version of the
        repository.</para>

        <para>This feature is only supported on CVSNT servers 2.0.55 and
        later.</para>

        <para>Note that rename is still in testing at the time of writing, so
        if unsure use use one of the other methods below.</para>

        <para>Note that rename information is a property of the directory, not
        the file. This behaviour is slightly non-obvious when you first
        encounter it. For a rename to be stored in the repository a
        <command>cvs commit</command> must be issued at the directory level,
        and for a rename to be picked up by other clients a <command>cvs
        update</command> must be issued at the directory level.</para>

        <para>You can move a file to a different directory within a sandbox
        provided the destination directory is within the same server. In this
        case to avoid confusion it is recommended to commit both directories
        at the same time (by committing from a common parent
        directory).</para>
      </sect2>

      <sect2 id="Outside">
        <title>The old way to Rename</title>

        <para>If you are connected to a server that does not support
        versioned-renames, the way to move a file is to copy
        <varname>old</varname> to <varname>new</varname>, and then issue the
        normal cvsnt commands to remove <varname>old</varname> from the
        repository, and add <varname>new</varname> to it.</para>

        <para><screen>$ mv <varname>old</varname> <varname>new</varname>
$ cvs remove <varname>old</varname>
$ cvs add <varname>new</varname>
$ cvs commit -m "Renamed <varname>old</varname> to <varname>new</varname>" <varname>old</varname> <varname>new</varname>
</screen></para>

        <para>Note that to access the history of the file you must specify the
        old or the new name, depending on what portion of the history you are
        accessing. For example, <command>cvs log
        <varname>old</varname></command> will give the log up until the time
        of the rename.</para>

        <para>When <varname>new</varname> is committed its revision numbers
        will start again, usually at 1.1, so if that bothers you, use the
        <command>-r rev</command> option to commit. For more information see
        <xref linkend="Assigning-revisions" />.</para>
      </sect2>

      <sect2 id="Inside">
        <title>Moving the history file</title>

        <para>This method is more dangerous, since it involves moving files
        inside the repository. Read this entire section before trying it
        out!</para>

        <para><screen>$ cd $CVSROOT/<varname>dir</varname>
$ mv <varname>old</varname>,v <varname>new</varname>,v
</screen></para>

        <para>Advantages:</para>

        <itemizedlist mark="bullet">
          <listitem>
            <para>The log of changes is maintained intact.</para>
          </listitem>

          <listitem>
            <para>The revision numbers are not affected.</para>
          </listitem>
        </itemizedlist>

        <para>Disadvantages:</para>

        <itemizedlist mark="bullet">
          <listitem>
            <para>Old releases cannot easily be fetched from the repository.
            (The file will show up as <varname>new</varname> even in revisions
            from the time before it was renamed).</para>
          </listitem>

          <listitem>
            <para>There is no log information of when the file was
            renamed.</para>
          </listitem>

          <listitem>
            <para>Nasty things might happen if someone accesses the history
            file while you are moving it. Make sure no one else runs any of
            the cvsnt commands while you move it.</para>
          </listitem>
        </itemizedlist>
      </sect2>

      <sect2 id="Rename-by-copying">
        <title>Copying the history file</title>

        <para>This way also involves direct modifications to the repository.
        It is safe, but not without drawbacks.</para>

        <para><screen># Copy the rcs file inside the repository
$ cd $CVSROOT/<varname>dir</varname>
$ cp <varname>old</varname>,v <varname>new</varname>,v
# Remove the old file
$ cd ~/<varname>dir</varname>
$ rm <varname>old</varname>
$ cvs remove <varname>old</varname>
$ cvs commit <varname>old</varname>
# Remove all tags from <varname>new</varname>
$ cvs update <varname>new</varname>
$ cvs log <varname>new</varname>             # Remember the non-branch tag names
$ cvs tag -d <varname>tag1</varname> <varname>new</varname>
$ cvs tag -d <varname>tag2</varname> <varname>new</varname>
...
</screen></para>

        <para>By removing the tags you will be able to check out old
        revisions.</para>

        <para>Advantages:</para>

        <itemizedlist mark="bullet">
          <listitem>
            <para>Checking out old revisions works correctly, as long as you
            use <command>-r<varname>tag</varname></command> and not
            <command>-D<varname>date</varname></command> to retrieve the
            revisions.</para>
          </listitem>

          <listitem>
            <para>The log of changes is maintained intact.</para>
          </listitem>

          <listitem>
            <para>The revision numbers are not affected.</para>
          </listitem>
        </itemizedlist>

        <para>Disadvantages:</para>

        <itemizedlist mark="bullet">
          <listitem>
            <para>You cannot easily see the history of the file across the
            rename.</para>
          </listitem>
        </itemizedlist>
      </sect2>
    </sect1>

    <sect1 id="Moving-directories">
      <title>Moving and renaming directories</title>

      <para><indexterm>
          <primary>Moving directories</primary>
        </indexterm><indexterm>
          <primary>Renaming directories</primary>
        </indexterm><indexterm>
          <primary>Directories, moving</primary>
        </indexterm> The normal way to rename or move a directory is to rename
      or move each file within it as described in <xref linkend="Outside" />.
      Then check out with the <command>-P</command> option, as described in
      <xref linkend="Removing-directories" />.</para>

      <para>If you really want to hack the repository to rename or delete a
      directory in the repository, you can do it like this:</para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>Inform everyone who has a checked out copy of the directory
          that the directory will be renamed. They should commit all their
          changes, and remove their working copies, before you take the steps
          below.</para>
        </listitem>

        <listitem>
          <para>Rename the directory inside the repository.</para>

          <para><screen>$ cd $CVSROOT/<varname>parent-dir</varname>
$ mv <varname>old-dir</varname> <varname>new-dir</varname>
</screen></para>
        </listitem>

        <listitem>
          <para>Fix the cvsnt administrative files, if necessary (for instance
          if you renamed an entire module).</para>
        </listitem>

        <listitem>
          <para>Tell everyone that they can check out again and continue
          working.</para>
        </listitem>
      </orderedlist>

      <para>If someone had a working copy the cvsnt commands will cease to
      work for him, until he removes the directory that disappeared inside the
      repository.</para>

      <para>It is almost always better to move the files in the directory
      instead of moving the directory. If you move the directory you are
      unlikely to be able to retrieve old releases correctly, since they
      probably depend on the name of the directories.</para>
    </sect1>
  </chapter>

  <chapter id="History-browsing">
    <title>History browsing</title>

    <para><indexterm>
        <primary>History browsing</primary>
      </indexterm><indexterm>
        <primary>Traceability</primary>
      </indexterm><indexterm>
        <primary>Isolation</primary>
      </indexterm></para>

    <para>Once you have used cvsnt to store a version control history--what
    files have changed when, how, and by whom, there are a variety of
    mechanisms for looking through the history.</para>

    <sect1 id="log-messages">
      <title>Log messages</title>

      <para>Whenever you commit a file you specify a log message.</para>

      <para>To look through the log messages which have been specified for
      every revision which has been committed, use the <command>cvs
      log</command> command (<xref linkend="log" />).</para>
    </sect1>

    <sect1 id="history-database">
      <title>The history database</title>

      <para>You can use the history file (<xref linkend="history-file" />) to
      log various cvsnt actions. To retrieve the information from the history
      file, use the <command>cvs history</command> command (<xref
      linkend="history" />).</para>

      <para>Note: you can control what is logged to this file by using the
      <command>LogHistory</command> keyword in the
      <command>CVSROOT/config</command> file (<xref
      linkend="config" />).</para>
    </sect1>

    <sect1 id="user-defined-logging">
      <title>User-defined logging</title>

      <para>You can customize cvsnt to log various kinds of actions, in
      whatever manner you choose. These mechanisms operate by executing a
      script at various times. The script might append a message to a file
      listing the information and the programmer who created it, or send mail
      to a group of developers, or, perhaps, post a message to a particular
      newsgroup. To log commits, use the <command>loginfo</command> file
      (<xref linkend="loginfo" />). To log commits, checkouts, exports, and
      tags, respectively, you can also use the <command>-i</command>,
      <command>-o</command>, <command>-e</command>, and <command>-t</command>
      options in the modules file. For a more flexible way of giving
      notifications to various users, which requires less in the way of
      keeping centralized scripts up to date, use the <command>cvs watch
      add</command> command (<xref linkend="Getting-Notified" />); this
      command is useful even if you are not using <command>cvs watch
      on</command>.</para>

      <sect2 id="taginfo">
        <title>The taginfo file</title>

        <para><indexterm>
            <primary>taginfo</primary>
          </indexterm><indexterm>
            <primary>Exit status, of taginfo</primary>
          </indexterm>The <command>taginfo</command> file defines programs to
        execute when someone executes a <command>tag</command> or
        <command>rtag</command> command. The <command>taginfo</command> file
        has the standard form for administrative files (<xref
        linkend="Administrative-files" />), where each line is a regular
        expression followed by a command to execute. The arguments passed to
        the command are, in order, the <varname>tagname</varname>,
        <varname>operation</varname> (<command>add</command> for
        <command>tag</command>, <command>mov</command> for <command>tag
        -F</command>, and <command>del</command> for <command>tag
        -d</command>), <varname>repository</varname>. The standard input
        contains pairs of <varname>filename</varname>
        <varname>revision</varname>. A non-zero exit of the filter program
        will cause the tag to be aborted.</para>

        <para>Each line in the <command>taginfo</command> file consists of a
        regular expression and a command-line template. Each line can have any
        combination of the following, in addition to those listed in the
        common syntax (<xref linkend="syntax" />.)<variablelist>
            <varlistentry>
              <term>%p</term>

              <listitem>
                <para>Directory name relative to the current root.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%m</term>

              <listitem>
                <para>Message supplied on the command line.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%s</term>

              <listitem>
                <para>List of files being tagged</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%v</term>

              <listitem>
                <para>List of versions being tagged</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%b</term>

              <listitem>
                <para>tag type</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%o</term>

              <listitem>
                <para>tag operation</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%t</term>

              <listitem>
                <para>tag name</para>
              </listitem>
            </varlistentry>
          </variablelist></para>

        <para>If no other options are specified, the default format string is
        <command>%t %o %r/%p %&lt;{%s %v}</command></para>

        <para>Here is an example of using taginfo to log tag and rtag
        commands. In the taginfo file put:</para>

        <para><screen>ALL /usr/local/cvsroot/CVSROOT/loggit
</screen></para>

        <para>Where <command>/usr/local/cvsroot/CVSROOT/loggit</command>
        contains the following script:</para>

        <para><screen>
#!/bin/sh
echo "$@" &gt;&gt;/home/kingdon/cvsroot/CVSROOT/taglog
</screen></para>
      </sect2>
    </sect1>

    <sect1 id="annotate-command">
      <title>Annotate command</title>

      <para><indexterm>
          <primary>annotate</primary>
        </indexterm> <function>cvs annotate</function>
      [<command>-flR</command>] [<command>-r rev</command>|<command>-D
      date</command>] files ... <indexterm role="fn">
          <primary>cvs annotate</primary>
        </indexterm> For each file in <varname>files</varname>, print the head
      revision of the trunk, together with information on the last
      modification for each line. For example:</para>

      <para><screen>$ cvs annotate ssfile
Annotations for ssfile
***************
1.1          (mary     27-Mar-96): ssfile line 1
1.2          (joe      28-Mar-96): ssfile line 2
</screen></para>

      <para>The file <command>ssfile</command> currently contains two lines.
      The <command>ssfile line 1</command> line was checked in by
      <command>mary</command> on March 27. Then, on March 28,
      <command>joe</command> added a line <command>ssfile line 2</command>,
      without modifying the <command>ssfile line 1</command> line. This report
      doesn't tell you anything about lines which have been deleted or
      replaced; you need to use <command>cvs diff</command> for that (<xref
      linkend="diff" />).</para>

      <para>The options to <command>cvs annotate</command> are listed in <xref
      linkend="annotate" />, and can be used to select the files and revisions
      to annotate. The options are described in more detail in <xref
      linkend="Common-options" />.</para>
    </sect1>
  </chapter>

  <chapter id="Binary-files">
    <title>Handling binary files</title>

    <para><indexterm>
        <primary>Binary files</primary>
      </indexterm> The most common use for cvsnt is to store text files. With
    text files, cvsnt can merge revisions, display the differences between
    revisions in a human-visible fashion, and other such operations. However,
    if you are willing to give up a few of these abilities, cvsnt can store
    binary files. For example, one might store a web site in cvsnt including
    both text files and binary images.</para>

    <sect1 id="Binary-why">
      <title>The issues with binary files</title>

      <para>While the need to manage binary files may seem obvious if the
      files that you customarily work with are binary, putting them into
      version control does present some additional issues.</para>

      <para>One basic function of version control is to show the differences
      between two revisions. For example, if someone else checked in a new
      version of a file, you may wish to look at what they changed and
      determine whether their changes are good. For text files, cvsnt provides
      this functionality via the <command>cvs diff</command> command. For
      binary files, it may be possible to extract the two revisions and then
      compare them with a tool external to cvsnt (for example, word processing
      software often has such a feature). If there is no such tool, one must
      track changes via other mechanisms, such as urging people to write good
      log messages, and hoping that the changes they actually made were the
      changes that they intended to make.</para>

      <para>Another ability of a version control system is the ability to
      merge two revisions. For cvsnt this happens in two contexts. The first
      is when users make changes in separate working directories (<xref
      linkend="Multiple-developers" />). The second is when one merges
      explicitly with the <command>update -j</command> command (<xref
      linkend="Branching-and-merging" />).</para>

      <para>In the case of text files, cvsnt can merge changes made
      independently, and signal a conflict if the changes conflict. With
      binary files, the best that cvsnt can do is present the two different
      copies of the file, and leave it to the user to resolve the conflict.
      The user may choose one copy or the other, or may run an external merge
      tool which knows about that particular file format, if one exists. Note
      that having the user merge relies primarily on the user to not
      accidentally omit some changes, and thus is potentially error
      prone.</para>

      <para>If this process is thought to be undesirable, the best choice may
      be to avoid merging. To avoid the merges that result from separate
      working directories, see the discussion of reserved checkouts (file
      locking) in <xref linkend="Multiple-developers" />. To avoid the merges
      resulting from branches, restrict use of branches.</para>
    </sect1>

    <sect1 id="Binary-howto">
      <title>How to store binary files</title>

      <para>There are two issues with using cvsnt to store binary files. The
      first is that cvsnt by default converts line endings between the
      canonical form in which they are stored in the repository (linefeed
      only), and the form appropriate to the operating system in use on the
      client (for example, carriage return followed by line feed for Windows
      NT).</para>

      <para>The second is that a binary file might happen to contain data
      which looks like a keyword (<xref linkend="Keyword-substitution" />), so
      keyword expansion must be turned off.</para>

      <para>The third is that storing differences (deltas) between binary
      files can be very inefficient.</para>

      <para>The <command>-kb</command> option available with some cvsnt
      commands insures that neither line ending conversion nor keyword
      expansion will be done.</para>

      <para>Here is an example of how you can create a new file using the
      <command>-kb</command> flag:</para>

      <para><screen>$ echo '$Id$' &gt; kotest
$ cvs add -kb -m"A test file" kotest
$ cvs ci -m"First checkin; contains a keyword" kotest
</screen></para>

      <para>If a file accidentally gets added without <command>-kb</command>,
      one can use the <command>cvs admin</command> command to recover. For
      example:</para>

      <para><screen>
$ echo '$Id$' &gt; kotest
$ cvs add -m"A test file" kotest
$ cvs ci -m"First checkin; contains a keyword" kotest
$ cvs update -kb kotest
# For non-unix systems:
# Copy in a good copy of the file from outside CVS
$ cvs commit -fm "make it binary" kotest
</screen></para>

      <para>When you check in the file <command>kotest</command> the file is
      not preserved as a binary file, because you did not check it in as a
      binary file. The <command>cvs update -kb</command> command sets the
      current keyword substitution method for this file, but it does not alter
      the working copy of the file that you have. If you need to cope with
      line endings (that is, you are using cvsnt on a non-unix system), then
      you need to check in a new copy of the file, as shown by the
      <command>cvs commit</command> command above.</para>

      <para>Older versions of CVS/CVSNT didn't properly version control the
      expansion option, and had an <command>admin -kb</command> option.</para>

      <para>You can also set a default for whether <command>cvs add</command>
      and <command>cvs import</command> treat a file as binary based on its
      name; for example you could say that files who names end in
      <command>.exe</command> are binary. <xref linkend="Wrappers" />. There
      is currently no way to have cvsnt detect whether a file is binary based
      on its contents. The main difficulty with designing such a feature is
      that it is not clear how to distinguish between binary and non-binary
      files, and the rules to apply would vary considerably with the operating
      system.</para>

      <para>The <command>-kB</command> solves the inefficiency problem by
      using a special binary delta algorithm to store the files. The function
      is similar to <command>-kb</command> except it is more efficient, and
      some functions that rely on text deltas, such as <command>cvs
      annotate</command> do not work with it.</para>

      <para>Normally CVS assumes that every file (whether binary or not) is a
      text file of some sort. This makes sense for most files that you would
      normally use during development, and the storage of such files is highly
      efficient.</para>

      <para>However, if you are storing pure binary files (libraries, or
      perhaps Word documents) it is very inefficient to treat them as text
      files. CVSNT solves this problem with the -kB option. This tells CVSNT
      to switch to an alternate algorithm to store such files.</para>
    </sect1>
  </chapter>

  <chapter id="Multiple-developers">
    <title>Multiple developers</title>

    <para><indexterm>
        <primary>Multiple developers</primary>
      </indexterm><indexterm>
        <primary>Team of developers</primary>
      </indexterm><indexterm>
        <primary>File locking</primary>
      </indexterm><indexterm>
        <primary>Locking files</primary>
      </indexterm><indexterm>
        <primary>Working copy</primary>
      </indexterm><indexterm>
        <primary>Reserved checkouts</primary>
      </indexterm><indexterm>
        <primary>Unreserved checkouts</primary>
      </indexterm><indexterm>
        <primary>rcs-style locking</primary>
      </indexterm> When more than one person works on a software project
    things often get complicated. Often, two people try to edit the same file
    simultaneously. One solution, known as <firstterm>file locking</firstterm>
    or <firstterm>reserved checkouts</firstterm>, is to allow only one person
    to edit each file at a time. This is the only solution with some version
    control systems, including rcs and sccs. Currently the usual way to get
    reserved checkouts with cvsnt is the <command>cvs admin -l</command>
    command (<xref linkend="admin-options" />). This is not as nicely
    integrated into cvsnt as the watch features, described below, but it seems
    that most people with a need for reserved checkouts find it adequate. It
    also may be possible to use the watches features described below, together
    with suitable procedures (not enforced by software), to avoid having two
    people edit at the same time.</para>

    <para>The default model with cvsnt is known as <firstterm>unreserved
    checkouts</firstterm>. In this model, developers can edit their own
    <firstterm>working copy</firstterm> of a file simultaneously. The first
    person that commits his changes has no automatic way of knowing that
    another has started to edit it. Others will get an error message when they
    try to commit the file. They must then use cvsnt commands to bring their
    working copy up to date with the repository revision. This process is
    almost automatic.</para>

    <para>cvsnt also supports mechanisms which facilitate various kinds of
    communication, without actually enforcing rules like reserved checkouts
    do.</para>

    <para>The rest of this chapter describes how these various models work,
    and some of the issues involved in choosing between them.</para>

    <sect1 id="File-status">
      <title>File status</title>

      <para><indexterm>
          <primary>File status</primary>
        </indexterm><indexterm>
          <primary>Status of a file</primary>
        </indexterm> Based on what operations you have performed on a checked
      out file, and what operations others have performed to that file in the
      repository, one can classify a file in a number of states. The states,
      as reported by the <command>status</command> command, are:</para>

      <variablelist>
        <title><indexterm>
            <primary>Up-to-date</primary>
          </indexterm></title>

        <varlistentry>
          <term>Up-to-date</term>

          <listitem>
            <para>The file is identical with the latest revision in the
            repository for the branch in use.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Locally Modified</term>

          <listitem>
            <para><indexterm>
                <primary>Locally Modified</primary>
              </indexterm>You have edited the file, and not yet committed your
            changes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Locally Added</term>

          <listitem>
            <para><indexterm>
                <primary>Locally Added</primary>
              </indexterm>You have added the file with <command>add</command>,
            and not yet committed your changes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Locally Removed</term>

          <listitem>
            <para><indexterm>
                <primary>Locally Removed</primary>
              </indexterm>You have removed the file with
            <command>remove</command>, and not yet committed your
            changes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Needs Checkout</term>

          <listitem>
            <para><indexterm>
                <primary>Needs Checkout</primary>
              </indexterm>Someone else has committed a newer revision to the
            repository. The name is slightly misleading; you will ordinarily
            use <command>update</command> rather than
            <command>checkout</command> to get that newer revision.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Needs Patch</term>

          <listitem>
            <para><indexterm>
                <primary>Needs Patch</primary>
              </indexterm>Like Needs Checkout, but the cvsnt server will send
            a patch rather than the entire file. Sending a patch or sending an
            entire file accomplishes the same thing.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Needs Merge</term>

          <listitem>
            <para><indexterm>
                <primary>Needs Merge</primary>
              </indexterm>Someone else has committed a newer revision to the
            repository, and you have also made modifications to the
            file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>File had conflicts on merge</term>

          <listitem>
            <para><indexterm>
                <primary>File had conflicts on merge</primary>
              </indexterm>This is like Locally Modified, except that a
            previous <command>update</command> command gave a conflict. If you
            have not already done so, you need to resolve the conflict as
            described in <xref linkend="Conflicts-example" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Unknown</term>

          <listitem>
            <para><indexterm>
                <primary>Unknown</primary>
              </indexterm>cvsnt doesn't know anything about this file. For
            example, you have created a new file and have not run
            <command>add</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>To help clarify the file status, <command>status</command> also
      reports the <command>Working revision</command> which is the revision
      that the file in the working directory derives from, and the
      <command>Repository revision</command> which is the latest revision in
      the repository for the branch in use.</para>

      <para>The options to <command>status</command> are listed in <xref
      linkend="status" />. For information on its <command>Sticky
      tag</command> and <command>Sticky date</command> output, see <xref
      linkend="Sticky-tags" />. For information on its <command>Sticky
      options</command> output, see the <command>-k</command> option in <xref
      linkend="update-options" />.</para>

      <para>You can think of the <command>status</command> and
      <command>update</command> commands as somewhat complementary. You use
      <command>update</command> to bring your files up to date, and you can
      use <command>status</command> to give you some idea of what an
      <command>update</command> would do (of course, the state of the
      repository might change before you actually run
      <command>update</command>). In fact, if you want a command to display
      file status in a more brief format than is displayed by the
      <command>status</command> command, you can invoke</para>

      <para><indexterm>
          <primary>update, to display file status</primary>
        </indexterm><screen>
$ cvs -n -q update
</screen></para>

      <para>The <command>-n</command> option means to not actually do the
      update, but merely to display statuses; the <command>-q</command> option
      avoids printing the name of each directory. For more information on the
      <command>update</command> command, and these options, see <xref
      linkend="update" />.</para>
    </sect1>

    <sect1 id="Updating-a-file">
      <title>Bringing a file up to date</title>

      <para><indexterm>
          <primary>Bringing a file up to date</primary>
        </indexterm><indexterm>
          <primary>Updating a file</primary>
        </indexterm><indexterm>
          <primary>Merging a file</primary>
        </indexterm><indexterm>
          <primary>Update, introduction</primary>
        </indexterm> When you want to update or merge a file, use the
      <command>update</command> command. For files that are not up to date
      this is roughly equivalent to a <command>checkout</command> command: the
      newest revision of the file is extracted from the repository and put in
      your working directory.</para>

      <para>Your modifications to a file are never lost when you use
      <command>update</command>. If no newer revision exists, running
      <command>update</command> has no effect. If you have edited the file,
      and a newer revision is available, cvsnt will merge all changes into
      your working copy.</para>

      <para>For instance, imagine that you checked out revision 1.4 and
      started editing it. In the meantime someone else committed revision 1.5,
      and shortly after that revision 1.6. If you run
      <command>update</command> on the file now, cvsnt will incorporate all
      changes between revision 1.4 and 1.6 into your file.</para>

      <para><indexterm>
          <primary>Overlap</primary>
        </indexterm>If any of the changes between 1.4 and 1.6 were made too
      close to any of the changes you have made, an
      <firstterm>overlap</firstterm> occurs. In such cases a warning is
      printed, and the resulting file includes both versions of the lines that
      overlap, delimited by special markers. <xref linkend="update" />, for a
      complete description of the <command>update</command> command.</para>
    </sect1>

    <sect1 id="Conflicts-example">
      <title>Conflicts example</title>

      <para><indexterm>
          <primary>Merge, an example</primary>
        </indexterm><indexterm>
          <primary>Example of merge</primary>
        </indexterm><indexterm>
          <primary>driver.c (merge example)</primary>
        </indexterm> Suppose revision 1.4 of <command>driver.c</command>
      contains this:</para>

      <para><screen>#include &lt;stdio.h&gt;

void main()
{
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? 0 : 1);
}
</screen></para>

      <para>Revision 1.6 of <command>driver.c</command> contains this:</para>

      <para><screen>
#include &lt;stdio.h&gt;

int main(int argc,
         char **argv)
{
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(!!nerr);
}
</screen></para>

      <para>Your working copy of <command>driver.c</command>, based on
      revision 1.4, contains this before you run <command>cvs
      update</command>:</para>

      <para><screen>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    init_scanner();
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</screen></para>

      <para>You run <command>cvs update</command>:</para>

      <para><screen>
$ cvs update driver.c
rcs file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
retrieving revision 1.4
retrieving revision 1.6
Merging differences between 1.4 and 1.6 into driver.c
rcsmerge warning: overlaps during merge
cvs update: conflicts found in driver.c
C driver.c
</screen></para>

      <para><indexterm>
          <primary>Conflicts (merge example)</primary>
        </indexterm>cvsnt tells you that there were some conflicts. Your
      original working file is saved unmodified in
      <command>.#driver.c.1.4</command>. The new version of
      <command>driver.c</command> contains this:</para>

      <para><screen>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
&lt;&lt;&lt;&lt;&lt;&lt;&lt; driver.c
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
=======
    exit(!!nerr);
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.6
}
</screen></para>

      <para><indexterm>
          <primary>Markers, conflict</primary>
        </indexterm><indexterm>
          <primary>Conflict markers</primary>
        </indexterm><indexterm>
          <primary>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</primary>
        </indexterm><indexterm>
          <primary>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</primary>
        </indexterm><indexterm>
          <primary>=======</primary>
        </indexterm> Note how all non-overlapping modifications are
      incorporated in your working copy, and that the overlapping section is
      clearly marked with <command>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</command>,
      <command>=======</command> and
      <command>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</command>.</para>

      <para><indexterm>
          <primary>Resolving a conflict</primary>
        </indexterm><indexterm>
          <primary>Conflict resolution</primary>
        </indexterm>You resolve the conflict by editing the file, removing the
      markers and the erroneous line. Suppose you end up with this file:
      <screen>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</screen></para>

      <para>You can now go ahead and commit this as revision 1.7.</para>

      <para><screen>
$ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
Checking in driver.c;
/usr/local/cvsroot/yoyodyne/tc/driver.c,v  &lt;--  driver.c
new revision: 1.7; previous revision: 1.6
done
</screen></para>

      <para>For your protection, cvsnt will refuse to check in a file if a
      conflict occurred and you have not resolved the conflict. Currently to
      resolve a conflict, you must change the timestamp on the file. In
      previous versions of cvsnt, you also needed to insure that the file
      contains no conflict markers. Because your file may legitimately contain
      conflict markers (that is, occurrences of
      <command>&gt;&gt;&gt;&gt;&gt;&gt;&gt; </command> at the start of a line
      that don't mark a conflict), the current version of cvsnt will print a
      warning and proceed to check in the file.</para>

      <para><indexterm>
          <primary>emerge</primary>
        </indexterm>If you use release 1.04 or later of pcl-cvs (a gnu Emacs
      front-end for cvsnt) you can use an Emacs package called emerge to help
      you resolve conflicts. See the documentation for pcl-cvs.</para>
    </sect1>

    <sect1 id="Informing-others">
      <title>Informing others about commits</title>

      <para><indexterm>
          <primary>Informing others</primary>
        </indexterm><indexterm>
          <primary>Spreading information</primary>
        </indexterm><indexterm>
          <primary>Mail, automatic mail on commit</primary>
        </indexterm> It is often useful to inform others when you commit a new
      revision of a file. The <command>-i</command> option of the
      <command>modules</command> file, or the <command>loginfo</command> file,
      can be used to automate this process. <xref linkend="modules" />. <xref
      linkend="loginfo" />. You can use these features of cvsnt to, for
      instance, instruct cvsnt to mail a message to all developers, or post a
      message to a local newsgroup.</para>
    </sect1>

    <sect1 id="Concurrency">
      <title>Several developers simultaneously attempting to run CVS</title>

      <para><indexterm>
          <primary>Locks, cvs, introduction</primary>
        </indexterm>If several developers try to run cvsnt at the same time,
      one may get the following message:</para>

      <para><screen>[11:43:23] waiting for bach's lock in /usr/local/cvsroot/foo
</screen></para>

      <para><indexterm>
          <primary>#cvs.rfl, removing</primary>
        </indexterm><indexterm>
          <primary>#cvs.wfl, removing</primary>
        </indexterm><indexterm>
          <primary>#cvs.lock, removing</primary>
        </indexterm>cvsnt will try again every second, and either continue
      with the operation or print the message again, if it still needs to
      wait. If a lock seems to stick around for an undue amount of time, find
      the person holding the lock and ask them about the cvs command they are
      running. If they aren't running a cvs command, and you are not running
      the lockserver (see <xref linkend="Lockserver" />, look in the
      repository directory mentioned in the message and remove files which
      they own whose names start with <command>#cvs.rfl</command>,
      <command>#cvs.wfl</command>, or <command>#cvs.lock</command>.</para>

      <para>Note that these locks are to protect cvsnt's internal data
      structures and have no relationship to the word
      <firstterm>lock</firstterm> in the sense used by rcs--which refers to
      reserved checkouts (<xref linkend="Multiple-developers" />).</para>

      <para>Any number of people can be reading from a given repository at a
      time; only when someone is writing a file do the locks prevent other
      people from reading or writing.</para>

      <para><indexterm>
          <primary>Atomic transactions</primary>
        </indexterm><indexterm>
          <primary>Atomicity</primary>
        </indexterm> Checkouts on cvsnt are atomic which means:</para>

      <para><screen>
If someone commits some changes in one cvs command,
then an update by someone else will either get all the
changes, or none of them.
</screen></para>

      <para>By default atomic checkouts occur across an entire checkout,
      (provided the lockserver is running), but atomic commits are only atomic
      at the file level. For example, given the files</para>

      <para><screen>
a/one.c
a/two.c
b/three.c
b/four.c
</screen></para>

      <para>if someone runs</para>

      <para><screen>
cvs ci a/two.c b/three.c
</screen></para>

      <para>and someone else runs <command>cvs update</command> at the same
      time, the person running <command>update</command> will either get all
      of the changes, or none of them. If however, the person running
      <command>cvs commit</command> suffers a power failure in the middle of
      the commit, it is possible that only one of the files will be
      updated.</para>
    </sect1>

    <sect1 id="Watches">
      <title>Mechanisms to track who is editing files</title>

      <para><indexterm>
          <primary>Watches</primary>
        </indexterm> For many groups, use of cvsnt in its default mode is
      perfectly satisfactory. Users may sometimes go to check in a
      modification only to find that another modification has intervened, but
      they deal with it and proceed with their check in. Other groups prefer
      to be able to know who is editing what files, so that if two people try
      to edit the same file they can choose to talk about who is doing what
      when rather than be surprised at check in time. The features in this
      section allow such coordination, while retaining the ability of two
      developers to edit the same file at the same time.</para>

      <para>For maximum benefit developers should use <command>cvs
      edit</command> (not <command>chmod</command>) to make files read-write
      to edit them, and <command>cvs release</command> (not
      <command>rm</command>) to discard a working directory which is no longer
      in use, but cvsnt is not able to enforce this behavior.</para>

      <sect2 id="Setting-a-watch">
        <title>Setting up cooperative edits</title>

        <para><indexterm>
            <primary>watch on</primary>
          </indexterm><function>cvs watch ro</function>
        [<command>-lR</command>] files ... <indexterm role="fn">
            <primary>cvs watch ro</primary>
          </indexterm><indexterm role="fn">
            <primary>cvs watch on</primary>
          </indexterm> <indexterm>
            <primary>Read-only files, and watches</primary>
          </indexterm>Specify that developers should run <command>cvs
        edit</command> before editing <varname>files</varname>. cvsnt will
        create working copies of <varname>files</varname> read-only, to remind
        developers to run the <command>cvs edit</command> command before
        working on them.</para>

        <para>If <varname>files</varname> includes the name of a directory,
        cvsnt sets up cooperative edits for all files added to the
        corresponding repository directory, and sets a default for files added
        in the future; this allows the user to set notification policies on a
        per-directory basis. The contents of the directory are processed
        recursively, unless the <command>-l</command> option is given. The
        <command>-R</command> option can be used to force recursion if the
        <command>-l</command> option is set in <command>~/.cvsrc</command>
        (<xref linkend="cvsrc" />).</para>

        <para>If <varname>files</varname> is omitted, it defaults to the
        current directory.</para>

        <para><indexterm>
            <primary>watch rw</primary>
          </indexterm><indexterm>
            <primary>watch off</primary>
          </indexterm> <function>cvs watch rw</function>
        [<command>-lR</command>] files ... <indexterm role="fn">
            <primary>cvs watch off</primary>
          </indexterm> Do not create <varname>files</varname> read-only on
        checkout; thus, developers will not be reminded to use <command>cvs
        edit</command> and <command>cvs unedit</command>.</para>

        <para>The <varname>files</varname> and options are processed as for
        <command>cvs watch ro</command>.</para>
      </sect2>

      <sect2 id="Getting-Notified">
        <title>Telling CVS to notify you when someone modifies a file</title>

        <para>You can tell cvsnt that you want to receive notifications about
        various actions taken on a file. You can do this without using
        <command>cvs watch ro</command> for the file, however generally you
        will want to use <command>cvs watch ro</command>, so that developers
        are reminded to use the <command>cvs edit</command> command.</para>

        <para><indexterm>
            <primary>watch add</primary>
          </indexterm><function>cvs watch add</function>
        [<command>-a</command> action] [<command>-lR</command>] files ...
        <indexterm role="fn">
            <primary>cvs watch add</primary>
          </indexterm> Add the current user to the list of people to receive
        notification of work done on <varname>files</varname>.</para>

        <para>The <command>-a</command> option specifies what kinds of events
        cvsnt should notify the user about. <varname>action</varname> is one
        of the following:</para>

        <variablelist>
          <varlistentry>
            <term>edit</term>

            <listitem>
              <para>Another user has applied the <command>cvs edit</command>
              command (described below) to a file.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>unedit</term>

            <listitem>
              <para>Another user has applied the <command>cvs unedit</command>
              command (described below) or the <command>cvs release</command>
              command to a file, or has deleted the file and allowed
              <command>cvs update</command> to recreate it.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>commit</term>

            <listitem>
              <para>Another user has committed changes to a file.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>all</term>

            <listitem>
              <para>All of the above.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>none</term>

            <listitem>
              <para>None of the above. (This is useful with <command>cvs
              edit</command>, described below.)</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The <command>-a</command> option may appear more than once, or
        not at all. If omitted, the action defaults to
        <command>all</command>.</para>

        <para>The <varname>files</varname> and options are processed as for
        the <command>cvs watch</command> commands.</para>

        <para><indexterm>
            <primary>watch remove</primary>
          </indexterm> <function>cvs watch remove</function>
        [<command>-a</command> action] [<command>-lR</command>] files ...
        <indexterm role="fn">
            <primary>cvs watch remove</primary>
          </indexterm> Remove a notification request established using
        <command>cvs watch add</command>; the arguments are the same. If the
        <command>-a</command> option is present, only watches for the
        specified actions are removed.</para>

        <para><indexterm>
            <primary>notify (admin file)</primary>
          </indexterm>When the conditions exist for notification, cvsnt calls
        the <command>notify</command> administrative file. Edit
        <command>notify</command> as one edits the other administrative files
        (<xref linkend="Intro-administrative-files" />). This file follows the
        usual conventions for administrative files (<xref
        linkend="syntax" />), where each line is a regular expression followed
        by a command to execute. The command should contain a single
        occurrence of <command>%s</command> which will be replaced by the user
        to notify; the rest of the information regarding the notification will
        be supplied to the command on standard input. A common thing to put in
        the <command>notify</command> file is the single line:</para>

        <para><screen>
ALL mail %s -s "CVS notification for bug %b"
</screen></para>

        <para>This causes users to be notified by electronic mail (assuming
        the command 'mail' exists).</para>

        <para><indexterm>
            <primary>users (admin file)</primary>
          </indexterm>Note that if you set this up in the straightforward way,
        users receive notifications on the server machine. One could of course
        write a <command>notify</command> script which directed notifications
        elsewhere, but to make this easy, cvsnt allows you to associate a
        notification address for each user. To do so create a file
        <command>users</command> in <command>CVSROOT</command> with a line for
        each user in the format
        <varname>user</varname>:<varname>value</varname>. Then instead of
        passing the name of the user to be notified to
        <command>notify</command>, cvsnt will pass the
        <varname>value</varname> (normally an email address on some other
        machine).</para>

        <para>CVSNT does not notify you for your own changes. Currently this
        check is done based on whether the user name of the person taking the
        action which triggers notification matches the user name of the person
        getting notification. In fact, in general, the watches features only
        track one edit by each user. It probably would be more useful if
        watches tracked each working directory separately, so this behavior
        might be worth changing.</para>

        <para>You can also pass information about the notification to the
        script, using the following substitution variables:</para>

        <para><command>%s</command> user being notified, or email (see
        above).</para>

        <para><command>%b</command> bug being edited.</para>

        <para><command>%m</command> reason for edit as supplied by
        user.</para>

        <para><command>%d</command> date and time of edit.</para>

        <para><command>%u</command> username of user performing the unedit
        (may not be the same as %s).</para>

        <para><command>%t</command> tag or branch being edited.</para>
      </sect2>

      <sect2 id="Editing-files">
        <title>How to edit a file which is being watched</title>

        <para><indexterm>
            <primary>Checkout, as term for getting ready to edit</primary>
          </indexterm>Since a file which is being watched is checked out
        read-only, you cannot simply edit it. To make it read-write, and
        inform others that you are planning to edit it, use the <command>cvs
        edit</command> command. Some systems call this a
        <firstterm>checkout</firstterm>, but cvsnt uses that term for
        obtaining a copy of the sources (<xref
        linkend="Getting-the-source" />), an operation which those systems
        call a <firstterm>get</firstterm> or a
        <firstterm>fetch</firstterm>.</para>

        <para><indexterm>
            <primary>edit</primary>
          </indexterm><function>cvs edit</function> [options] files ...
        <indexterm role="fn">
            <primary>cvs edit</primary>
          </indexterm> Prepare to edit the working files
        <varname>files</varname>. cvsnt makes the <varname>files</varname>
        read-write, and notifies users who have requested
        <command>edit</command> notification for any of
        <varname>files</varname>.</para>

        <para>The <command>cvs edit</command> command accepts the same
        <varname>options</varname> as the <command>cvs watch add</command>
        command, and establishes a temporary watch for the user on
        <varname>files</varname>; cvsnt will remove the watch when
        <varname>files</varname> are <command>unedit</command>ed or
        <command>commit</command>ted. If the user does not wish to receive
        notifications, she should specify <command>-a none</command>.</para>

        <para>The <varname>files</varname> and options are processed as for
        the <command>cvs watch</command> commands.</para>

        <para>If the <command>-c</command> option is given, then the file is
        checked for existing editors before the edit can proceed. In this way
        a reasonable facsimile of 'reserved edits' can be achieved (note
        however this is a suboptimal way to use cvsnt).</para>

        <para>If the <command>-x</command> is given, then the edit is marked
        as exclusive on the server, and other users will be prevented from
        creating further edits. This option will also prevent commits to the
        file by their users. (Implies -c).</para>

        <para>The <command>-z</command> option stores the edited base revision
        in a compressed form. This is useful if you are using an IDE which
        tends to pick up the base revisions while searching files. Its also
        saves quite a bit of disk space on large edits.</para>

        <para>Normally edits apply only to the branch that you are currently
        using. The <command>-w</command> causes the edit to apply to all
        branches within the file (which is the behaviour for pre-2.0.55
        CVSNT).</para>

        <para>The <command>-b</command> marks this edit as belonging to a
        specific bug. This information is stored and also sent to the
        <command>CVSROOT/notify</command> script.</para>

        <para>The <command>-m</command> sets a reason message for this edit.
        This can be processed by the <command>CVSROOT/notify</command>
        script.</para>

        <para>Normally when you are done with a set of changes, you use the
        <command>cvs commit</command> command, which checks in your changes
        and returns the watched files to their usual read-only state. But if
        you instead decide to abandon your changes, or not to make any
        changes, you can use the <command>cvs unedit</command> command.</para>

        <para><indexterm>
            <primary>unedit</primary>
          </indexterm> <indexterm>
            <primary>Abandoning work</primary>
          </indexterm> <indexterm>
            <primary>Reverting to repository version</primary>
          </indexterm> <indexterm role="fn">
            <primary>cvs unedit</primary>
          </indexterm> <function>cvs unedit</function> [-lR] [-r] [-u user]
        [-w] [-b bug] [-m message] [files...]</para>

        <para>Abandon work on the working files <varname>files</varname>, and
        revert them to the repository versions on which they are based. CVSNT
        by default also makes the files read only. Use the -w option to
        override this.. CVSNT then notifies users who have requested
        <command>unedit</command> notification for any of
        <varname>files</varname>.</para>

        <para>The <varname>files</varname> and options are processed as for
        the <command>cvs watch</command> commands.</para>

        <para>If watches are not in use, the <command>unedit</command> command
        probably does not work, and the way to revert to the repository
        version is to remove the file and then use <command>cvs
        update</command> to get a new copy. The meaning is not precisely the
        same; removing and updating may also bring in some changes which have
        been made in the repository since the last time you updated.</para>

        <para>The reason message passed to this function is passed directly to
        the <command>CVSROOT/Notify</command> script. If the
        <command>-b</command> option is used then only those files edited
        under a specific bug are unedited.</para>

        <para>Repository administrators can use the 'unedit others' option
        <command>-u</command>. Only use this as a last resort as it only does
        the server side of the unedit.</para>
      </sect2>

      <sect2 id="Watch-information">
        <title>Information about who is watching and editing</title>

        <para><indexterm>
            <primary>watchers</primary>
          </indexterm><function>cvs watchers</function>
        [<command>-lR</command>] files ... <indexterm role="fn">
            <primary>cvs watchers</primary>
          </indexterm> List the users currently watching changes to
        <varname>files</varname>. The report includes the files being watched,
        and the mail address of each watcher.</para>

        <para>The <varname>files</varname> and options are processed as for
        the <command>cvs watch</command> commands.</para>

        <para><indexterm>
            <primary>editors</primary>
          </indexterm> <function>cvs editors</function>
        [<command>-lR</command>] [<command>-a</command>] files ... <indexterm
            role="fn">
            <primary>cvs editors</primary>
          </indexterm> List the users currently working on
        <varname>files</varname>. The report includes the mail address of each
        user, the time when the user began working with the file, and the host
        and path of the working directory containing the file.</para>

        <para>The <varname>files</varname> and options are processed as for
        the <command>cvs watch</command> commands.</para>
      </sect2>

      <sect2 id="Watches-Compatibility">
        <title>Using watches with old versions of CVS</title>

        <para><indexterm>
            <primary>CVS 1.6, and watches</primary>
          </indexterm>If you use the watch features on a repository, it
        creates <command>CVS</command> directories in the repository and
        stores the information about watches in that directory. If you attempt
        to use cvsnt 1.6 or earlier with the repository, you get an error
        message such as the following (all on one line):</para>

        <para><screen>cvs update: cannot open CVS/Entries for reading:
No such file or directory
</screen></para>

        <para>and your operation will likely be aborted. To use the watch
        features, you must upgrade all copies of cvsnt which use that
        repository in local or server mode. If you cannot upgrade, use the
        <command>watch off</command> and <command>watch remove</command>
        commands to remove all watches, and that will restore the repository
        to a state which cvsnt 1.6 can cope with.</para>
      </sect2>
    </sect1>

    <sect1 id="Choosing-a-model">
      <title>Choosing between reserved or unreserved checkouts</title>

      <para><indexterm>
          <primary>Choosing, reserved or unreserved checkouts</primary>
        </indexterm> Reserved and unreserved checkouts each have pros and
      cons. Let it be said that a lot of this is a matter of opinion or what
      works given different groups' working styles, but here is a brief
      description of some of the issues. There are many ways to organize a
      team of developers. cvsnt does not try to enforce a certain
      organization. It is a tool that can be used in several ways.</para>

      <para>Reserved checkouts can be very counter-productive. If two persons
      want to edit different parts of a file, there may be no reason to
      prevent either of them from doing so. Also, it is common for someone to
      take out a lock on a file, because they are planning to edit it, but
      then forget to release the lock.</para>

      <para>People, especially people who are familiar with reserved
      checkouts, often wonder how often conflicts occur if unreserved
      checkouts are used, and how difficult they are to resolve. The
      experience with many groups is that they occur rarely and usually are
      relatively straightforward to resolve.</para>

      <para>The rarity of serious conflicts may be surprising, until one
      realizes that they occur only when two developers disagree on the proper
      design for a given section of code; such a disagreement suggests that
      the team has not been communicating properly in the first place. In
      order to collaborate under <emphasis>any</emphasis> source management
      regimen, developers must agree on the general design of the system;
      given this agreement, overlapping changes are usually straightforward to
      merge.</para>

      <para>In some cases unreserved checkouts are clearly inappropriate. If
      no merge tool exists for the kind of file you are managing (for example
      word processor files or files edited by Computer Aided Design programs),
      and it is not desirable to change to a program which uses a mergeable
      data format, then resolving conflicts is going to be unpleasant enough
      that you generally will be better off to simply avoid the conflicts
      instead, by using reserved checkouts.</para>

      <para>The watches features described above in <xref linkend="Watches" />
      can be considered to be an intermediate model between reserved checkouts
      and unreserved checkouts. When you go to edit a file, it is possible to
      find out who else is editing it. And rather than having the system
      simply forbid both people editing the file, it can tell you what the
      situation is and let you figure out whether it is a problem in that
      particular case or not. Therefore, for some groups it can be considered
      the best of both the reserved checkout and unreserved checkout
      worlds.</para>
    </sect1>
  </chapter>

  <chapter id="Revision-management">
    <title>Revision management</title>

    <para><indexterm>
        <primary>Revision management</primary>
      </indexterm></para>

    <para>If you have read this far, you probably have a pretty good grasp on
    what cvsnt can do for you. This chapter talks a little about things that
    you still have to decide.</para>

    <para>If you are doing development on your own using cvsnt you could
    probably skip this chapter. The questions this chapter takes up become
    more important when more than one person is working in a
    repository.</para>

    <sect1 id="When-to-commit">
      <title>When to commit?</title>

      <para><indexterm>
          <primary>When to commit</primary>
        </indexterm><indexterm>
          <primary>Commit, when to</primary>
        </indexterm><indexterm>
          <primary>Policy</primary>
        </indexterm> Your group should decide which policy to use regarding
      commits. Several policies are possible, and as your experience with
      cvsnt grows you will probably find out what works for you.</para>

      <para>If you commit files too quickly you might commit files that do not
      even compile. If your partner updates his working sources to include
      your buggy file, he will be unable to compile the code. On the other
      hand, other persons will not be able to benefit from the improvements
      you make to the code if you commit very seldom, and conflicts will
      probably be more common.</para>

      <para>It is common to only commit files after making sure that they can
      be compiled. Some sites require that the files pass a test suite.
      Policies like this can be enforced using the commitinfo file (<xref
      linkend="commitinfo" />), but you should think twice before you enforce
      such a convention. By making the development environment too controlled
      it might become too regimented and thus counter-productive to the real
      goal, which is to get software written.</para>
    </sect1>
  </chapter>

  <chapter id="Keyword-substitution">
    <title>Keyword substitution</title>

    <para><indexterm>
        <primary>Keyword substitution</primary>
      </indexterm><indexterm>
        <primary>Keyword expansion</primary>
      </indexterm><indexterm>
        <primary>Identifying files</primary>
      </indexterm></para>

    <para>As long as you edit source files inside a working directory you can
    always find out the state of your files via <command>cvs status</command>
    and <command>cvs log</command>. But as soon as you export the files from
    your development environment it becomes harder to identify which revisions
    they are.</para>

    <para>cvsnt can use a mechanism known as <firstterm>keyword
    substitution</firstterm> (or <firstterm>keyword expansion</firstterm>) to
    help identifying the files. Embedded strings of the form
    <command>$<varname>keyword</varname>$</command> and
    <command>$<varname>keyword</varname>:...$</command> in a file are replaced
    with strings of the form
    <command>$<varname>keyword</varname>:<varname>value</varname>$</command>
    whenever you obtain a new revision of the file.</para>

    <sect1 id="Keyword-list">
      <title>Keyword List</title>

      <para><indexterm>
          <primary>Keyword List</primary>
        </indexterm></para>

      <para>This is a list of the keywords. This list may be altered or
      augmented by the use of the keywords control file (see<xref
      linkend="User-Defined-Keywords" />).</para>

      <variablelist>
        <title><indexterm>
            <primary>Author keyword</primary>
          </indexterm></title>

        <varlistentry>
          <term>$Author$</term>

          <listitem>
            <para>The login name of the user who checked in the
            revision.</para>

            <para><indexterm>
                <primary>Branch keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Branch$</term>

          <listitem>
            <para>The name of the branch that the revision is a member
            of.</para>

            <para><indexterm>
                <primary>CommitId keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$CommitId$</term>

          <listitem>
            <para>The Commit (or Session) identifier of the commit that
            generated this revision.</para>

            <para><indexterm>
                <primary>Date keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Date$</term>

          <listitem>
            <para>The date and time (UTC) the revision was checked in.</para>

            <para><indexterm>
                <primary>Header keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Header$</term>

          <listitem>
            <para>A standard header containing the full pathname of the rcs
            file, the revision number, the date (UTC), the author, the state,
            and the locker (if locked). Files will normally never be locked
            when you use cvsnt.</para>

            <para><indexterm>
                <primary>RCSHeader keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$RCSHeader$</term>

          <listitem>
            <para>A standard header containing the relative pathname of the
            rcs file, the revision number, the date (UTC), the author, the
            state, and the locker (if locked). Files will normally never be
            locked when you use cvsnt.</para>

            <para><indexterm>
                <primary>Id keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Id$</term>

          <listitem>
            <para>Same as <command>$Header$</command>, except that the rcs
            filename is without a path.</para>

            <para><indexterm>
                <primary>Name keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Name$</term>

          <listitem>
            <para>Tag name used to check out this file. The keyword is
            expanded only if one checks out with an explicit tag name. For
            example, when running the command <command>cvs co -r
            first</command>, the keyword expands to <command>Name:
            first</command>.</para>

            <para><indexterm>
                <primary>Locker keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Locker:$</term>

          <listitem>
            <para>The login name of the user who locked the revision (empty if
            not locked, which is the normal case unless <command>cvs admin
            -l</command> is in use). This keyword has little meaning under
            cvsnt.</para>

            <para><indexterm>
                <primary>Log keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Log$</term>

          <listitem>
            <para>The log message supplied during commit, preceded by a header
            containing the rcs filename, the revision number, the author, and
            the date (UTC). Existing log messages are <emphasis>not</emphasis>
            replaced. Instead, the new log message is inserted after
            <command>$Log$</command>. Each new line is prefixed with the same
            string which precedes the <command>$Log</command> keyword. For
            example, if the file contains</para>

            <para><screen>  /* Here is what people have been up to:
   *
   * $Log: foo.txt,v $
   * Revision 1.1  1997/01/03 14:23:51  joe
   * Add the superfrobnicate option
   *
   */
</screen></para>

            <para>then additional lines which are added when expanding the
            <command>$Log</command> keyword will be preceded by <command> *
            </command>. Unlike previous versions of cvsnt and rcs, the
            <firstterm>comment leader</firstterm> from the rcs file is not
            used. The <command>$Log</command> keyword is useful for
            accumulating a complete change log in a source file, but for
            several reasons it can be problematic. <xref
            linkend="Log-keyword" />.</para>

            <para><indexterm>
                <primary>rcsfile keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$rcsfile$</term>

          <listitem>
            <para>The name of the rcs file without a path.</para>

            <para><indexterm>
                <primary>Revision keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Revision$</term>

          <listitem>
            <para>The revision number assigned to the revision.</para>

            <para><indexterm>
                <primary>Source keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$Source$</term>

          <listitem>
            <para>The full pathname of the rcs file.</para>

            <para><indexterm>
                <primary>State keyword</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>$State$</term>

          <listitem>
            <para>The state assigned to the revision. States can be assigned
            with <command>cvs admin -s</command>--see <xref
            linkend="admin-options" />.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="Using-keywords">
      <title>Using keywords</title>

      <para>To include a keyword string you simply include the relevant text
      string, such as <command>$Id$</command>, inside the file, and commit the
      file. cvsnt will automatically expand the string as part of the commit
      operation.</para>

      <para>It is common to embed the <command>$Id$</command> string in the
      source files so that it gets passed through to generated files. For
      example, if you are managing computer program source code, you might
      include a variable which is initialized to contain that string. Or some
      C compilers may provide a <command>#pragma ident</command> directive. Or
      a document management system might provide a way to pass a string
      through to generated files.</para>

      <para><indexterm>
          <primary>Ident (shell command)</primary>
        </indexterm>The <command>ident</command> command (which is part of the
      rcs package) can be used to extract keywords and their values from a
      file. This can be handy for text files, but it is even more useful for
      extracting keywords from binary files.</para>

      <para><screen>$ ident samp.c
samp.c:
     $Id$
$ gcc samp.c
$ ident a.out
a.out:
     $Id: cvs.dbk,v 1.1.2.1 2004/04/16 14:14:42 tmh Exp $
</screen></para>

      <para><indexterm>
          <primary>What (shell command)</primary>
        </indexterm>Sccs is another popular revision control system. It has a
      command, <command>what</command>, which is very similar to
      <command>ident</command> and used for the same purpose. Many sites
      without rcs have sccs. Since <command>what</command> looks for the
      character sequence <command>@(#)</command> it is easy to include
      keywords that are detected by either command. Simply prefix the keyword
      with the magic sccs phrase, like this:</para>

      <para><screen>
static char *id="@(#) $Id$";
</screen></para>
    </sect1>

    <sect1 id="Avoiding-substitution">
      <title>Avoiding substitution</title>

      <para>Keyword substitution has its disadvantages. Sometimes you might
      want the literal text string <command>$Author$</command> to appear
      inside a file without cvsnt interpreting it as a keyword and expanding
      it into something like <command>$Author$</command>.</para>

      <para>There is unfortunately no way to selectively turn off keyword
      substitution. You can use <command>-ko</command> (<xref
      linkend="Substitution-modes" />) to turn off keyword substitution
      entirely.</para>

      <para>In many cases you can avoid using keywords in the source, even
      though they appear in the final product. For example, the source for
      this manual contains <command>$@asis{}Author$</command> whenever the
      text <command>$Author$</command> should appear. In
      <command>nroff</command> and <command>troff</command> you can embed the
      null-character <command>\&amp;</command> inside the keyword for a
      similar effect.</para>
    </sect1>

    <sect1 id="Substitution-modes">
      <title>Substitution modes</title>

      <para><indexterm>
          <primary>Keyword substitution, changing modes</primary>
        </indexterm><indexterm>
          <primary>-k (keyword substitution)</primary>
        </indexterm><indexterm>
          <primary>Kflag</primary>
        </indexterm> Keyword substitution modes are stored for each version of
      a file. When you commit a new revision that version will be stored
      exactly as it is in the sandbox, including the substitution mode.</para>

      <para>You can override the substitution mode by using the
      <command>-k</command> option to <command>cvs add</command>,
      <command>-k</command> or <command>-A</command> options to <command>cvs
      checkout</command> or <command>cvs update</command>. <command>cvs
      diff</command> also has a <command>-k</command> option. For some
      examples, see <xref linkend="Binary-files" />, and <xref
      linkend="Merging-and-keywords" />.</para>

      <para>The <command>cvs update</command> and <command>cvs
      checkout</command> commands allow you to modify existing substitution
      modes without overwriting the existing ones. This is done by prefixing
      the mode with '+' (for add) or '-' (for remove). For example to switch
      off keyword substitution for all files in a subtree:</para>

      <para><screen>
$ cvs update -k+o
$ cvs commit -fm "Change substitution mode"
</screen></para>

      <para>The modes available are defined by combining an optional encoding
      with a series of options.</para>

      <para>Some combinations were not available on older CVS versions so be
      careful if you want to access your repository from older clients. The
      CVSNT server will automatically downgrade some of these options if an
      older client fetches a file.</para>

      <para>Encodings:</para>

      <variablelist>
        <varlistentry>
          <term>t</term>

          <listitem>
            <para>Treat the file as a text file. This is the default setting
            if no encoding is specified.</para>

            <para>MBCS character sets that don't change the behaviour of CR/LF
            and NULL should also work in this mode. eg. Shift-JIS and
            EUC.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>b</term>

          <listitem>
            <para>Treat the file as binary. No interpretation is done of the
            contents and they are stored verbatim. Be default no keyword
            expansion is done. Binary files are considered non-mergable by
            CVS.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>B</term>

          <listitem>
            <para>Treat the file as binary. No interpretation is done of the
            contents and they are stored verbatim. Be default no keyword
            expansion is done. Binary files are considered non-mergable by
            CVS. In addition, an alternate storage algorithm is used that is
            optimised for storage of binary files.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>u</term>

          <listitem>
            <para>Treat the file as Unicode. The file will be checked in/out
            in UCS-2 (or UTF-16) encoding and internally stored as UTF-8 by
            the server.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>{...}</term>

          <listitem>
            <para>Use an extended encoding. Any encoding supported by the
            client-side iconv library can be used, however beware of
            mismatches between clients (the Win32 version does not currently
            support EBCIDIC encodings for example). The following list will
            work on all platforms that are using Unicode-capable CVSNT:</para>

            <variablelist>
              <varlistentry>
                <term>ucs2le</term>

                <term>utf16le</term>

                <listitem>
                  <para>Little-endian UCS-2 without BOM.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>ucs2be</term>

                <term>utf16be</term>

                <listitem>
                  <para>Big-endian UCS-2 without BOM.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>ucs2le_bom</term>

                <term>utf16le_bom</term>

                <listitem>
                  <para>Little-endian UCS-2 with BOM.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>ucs2be_bom</term>

                <term>utf16be_bom</term>

                <listitem>
                  <para>Big-endian UCS-2 with BOM.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Flags:</para>

      <variablelist>
        <varlistentry>
          <term>c</term>

          <listitem>
            <para>Enforce cooperative edits (edit -c) for the file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>x</term>

          <listitem>
            <para>Enforce reserved edit (edit -x) for the file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>k</term>

          <listitem>
            <para>Preserve the keyword string (default). When combined with
            the v flag this generates results using the default form, e.g.
            <command>$Revision$</command> for the <command>Revision</command>
            keyword. On its own it produces output with no keywords
            expanded.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>v</term>

          <listitem>
            <para>Generate keyword values for keyword strings. Normally paired
            with the k option. If it is used on its own the effect is to strip
            keywords from the output - for example, for the
            <command>Revision</command> keyword, generate the string
            <command>5.7</command> instead of <command>$Revision:
            1.1.2.1$</command>. This can help generate files in programming
            languages where it is hard to strip keyword delimiters like
            <command>$Revision$</command> from a string. However, further
            keyword substitution cannot be performed once the keyword names
            are removed, so this option should be used with care.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>l</term>

          <listitem>
            <para>Insert the lockers name if the given revision is currently
            locked. The locker's name is only relevant if <command>cvs admin
            -l</command> is in use.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>s</term>

          <listitem>
            <para>File is never considered modified on the client. A normal
            commit will never commit this file, unless -f is used to force it.
            Use with care, and for files that change infrequently, since local
            changes will be lost on update.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>1</term>

          <listitem>
            <para>Unversioned. Only ever keep a single revision in the
            repository. History is lost, and the file is merely kept as the
            latest copy. Only one branch (HEAD) ever exists and an update of
            any revision will return the single revision.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>L</term>

          <listitem>
            <para>When checking out, always create a file with Unix line
            endings (LF).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>D</term>

          <listitem>
            <para>Whcn checking out, always create a file with Dos/Windows
            line endings (CR/LF).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>M</term>

          <listitem>
            <para>When checking out, always create a file with Mac line
            endings (CR)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>o</term>

          <listitem>
            <para>Generate the old keyword string, present in the working file
            just before it was checked in. For example, for the
            <command>Revision</command> keyword, generate the string
            <command>$Revision: 1.1.2.1;$</command> instead of
            <command>$Revision$</command> if that is how the string appeared
            when the file was checked in.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>z</term>

          <listitem>
            <para>Compress the files and deltas when they are stored. This
            sacrifices speed for disk space - only use if disk space is at a
            premium.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="Log-keyword">
      <title>$Log$</title>

      <para>The <command>$Log$</command> keyword is somewhat controversial. As
      long as you are working on your development system the information is
      easily accessible even if you do not use the <command>$Log$</command>
      keyword--just do a <command>cvs log</command>. Once you export the file
      the history information might be useless anyhow.</para>

      <para>A more serious concern is that cvsnt is not good at handling
      <command>$Log$</command> entries when a branch is merged onto the main
      trunk. Conflicts often result from the merging operation.</para>

      <para>People also tend to "fix" the log entries in the file (correcting
      spelling mistakes and maybe even factual errors). If that is done the
      information from <command>cvs log</command> will not be consistent with
      the information inside the file. This may or may not be a problem in
      real life.</para>

      <para>It has been suggested that the <command>$Log$</command> keyword
      should be inserted <emphasis>last</emphasis> in the file, and not in the
      files header, if it is to be used at all. That way the long list of
      change messages will not interfere with everyday source file
      browsing.</para>
    </sect1>
  </chapter>

  <chapter id="Tracking-sources">
    <title>Tracking third-party sources</title>

    <para><indexterm>
        <primary>Third-party sources</primary>
      </indexterm><indexterm>
        <primary>Tracking sources</primary>
      </indexterm> If you modify a program to better fit your site, you
    probably want to include your modifications when the next release of the
    program arrives. cvsnt can help you with this task.</para>

    <para><indexterm>
        <primary>Vendor</primary>
      </indexterm><indexterm>
        <primary>Vendor branch</primary>
      </indexterm><indexterm>
        <primary>Branch, vendor-</primary>
      </indexterm>In the terminology used in cvsnt, the supplier of the
    program is called a <firstterm>vendor</firstterm>. The unmodified
    distribution from the vendor is checked in on its own branch, the
    <firstterm>vendor branch</firstterm>. cvsnt reserves branch 1.1.1 for this
    use.</para>

    <para>When you modify the source and commit it, your revision will end up
    on the main trunk. When a new release is made by the vendor, you commit it
    on the vendor branch and copy the modifications onto the main
    trunk.</para>

    <para>Use the <command>import</command> command to create and update the
    vendor branch. When you import a new file, the vendor branch is made the
    `head' revision, so anyone that checks out a copy of the file gets that
    revision. When a local modification is committed it is placed on the main
    trunk, and made the `head' revision.</para>

    <sect1 id="First-import">
      <title>Importing for the first time</title>

      <para><indexterm>
          <primary>Importing modules</primary>
        </indexterm> Use the <command>import</command> command to check in the
      sources for the first time. When you use the <command>import</command>
      command to track third-party sources, the <firstterm>vendor
      tag</firstterm> and <firstterm>release tags</firstterm> are useful. The
      <firstterm>vendor tag</firstterm> is a symbolic name for the branch
      (which is always 1.1.1, unless you use the <command>-b
      <varname>branch</varname></command> flag--see <xref
      linkend="Multiple-vendor-branches" />.). The <firstterm>release
      tags</firstterm> are symbolic names for a particular release, such as
      <command>FSF_0_04</command>.</para>

      <para><indexterm>
          <primary>wdiff (import example)</primary>
        </indexterm>Suppose you have the sources to a program called
      <command>wdiff</command> in a directory <command>wdiff-0.04</command>,
      and are going to make private modifications that you want to be able to
      use even when new releases are made in the future. You start by
      importing the source to your repository:</para>

      <para><screen>$ cd wdiff-0.04
$ cvs import -m "Import of FSF v. 0.04" fsf/wdiff FSF_DIST WDIFF_0_04
</screen></para>

      <para>The vendor tag is named <command>FSF_DIST</command> in the above
      example, and the only release tag assigned is
      <command>WDIFF_0_04</command>.</para>
    </sect1>

    <sect1 id="Update-imports">
      <title>Updating with the import command</title>

      <para>When a new release of the source arrives, you import it into the
      repository with the same <command>import</command> command that you used
      to set up the repository in the first place. The only difference is that
      you specify a different release tag this time.</para>

      <para><screen>$ tar xfz wdiff-0.05.tar.gz
$ cd wdiff-0.05
$ cvs import -m "Import of FSF v. 0.05" fsf/wdiff FSF_DIST WDIFF_0_05
</screen></para>

      <para>For files that have not been modified locally, the newly created
      revision becomes the head revision. If you have made local changes,
      <command>import</command> will warn you that you must merge the changes
      into the main trunk, and tell you to use <command>checkout -j</command>
      to do so.</para>

      <para><screen>
$ cvs checkout -jFSF_DIST:yesterday -jFSF_DIST wdiff
</screen></para>

      <para>The above command will check out the latest revision of
      <command>wdiff</command>, merging the changes made on the vendor branch
      <command>FSF_DIST</command> since yesterday into the working copy. If
      any conflicts arise during the merge they should be resolved in the
      normal way (<xref linkend="Conflicts-example" />). Then, the modified
      files may be committed.</para>

      <para>Using a date, as suggested above, assumes that you do not import
      more than one release of a product per day. If you do, you can always
      use something like this instead:</para>

      <para><screen>
$ cvs checkout -jWDIFF_0_04 -jWDIFF_0_05 wdiff
</screen></para>

      <para>In this case, the two above commands are equivalent.</para>
    </sect1>

    <sect1 id="Reverting-local-changes">
      <title>Reverting to the latest vendor release</title>

      <para>You can also revert local changes completely and return to the
      latest vendor release by changing the `head' revision back to the vendor
      branch on all files. For example, if you have a checked-out copy of the
      sources in <command>~/work.d/wdiff</command>, and you want to revert to
      the vendor's version for all the files in that directory, you would
      type:</para>

      <para><screen>$ cd ~/work.d/wdiff
$ cvs admin -bWDIFF .
</screen></para>

      <para>You must specify the <command>-bWDIFF</command> without any space
      after the <command>-b</command>. <xref
      linkend="admin-options" />.</para>
    </sect1>

    <sect1 id="Binary-files-in-imports">
      <title>How to handle binary files with cvs import</title>

      <para>Use the <command>-k</command> wrapper option to tell import which
      files are binary. <xref linkend="Wrappers" />.</para>
    </sect1>

    <sect1 id="Keywords-in-imports">
      <title>How to handle keyword substitution with cvs import</title>

      <para>The sources which you are importing may contain keywords (<xref
      linkend="Keyword-substitution" />). For example, the vendor may use
      cvsnt or some other system which uses similar keyword expansion syntax.
      If you just import the files in the default fashion, then the keyword
      expansions supplied by the vendor will be replaced by keyword expansions
      supplied by your own copy of cvsnt. It may be more convenient to
      maintain the expansions supplied by the vendor, so that this information
      can supply information about the sources that you imported from the
      vendor.</para>

      <para>To maintain the keyword expansions supplied by the vendor, supply
      the <command>-ko</command> option to <command>cvs import</command> the
      first time you import the file. This will turn off keyword expansion for
      that file entirely, so if you want to be more selective you'll have to
      think about what you want and use the <command>-k</command> option to
      <command>cvs update</command> or <command>cvs admin</command> as
      appropriate.</para>
    </sect1>

    <sect1 id="Multiple-vendor-branches">
      <title>Multiple vendor branches</title>

      <para>All the examples so far assume that there is only one vendor from
      which you are getting sources. In some situations you might get sources
      from a variety of places. For example, suppose that you are dealing with
      a project where many different people and teams are modifying the
      software. There are a variety of ways to handle this, but in some cases
      you have a bunch of source trees lying around and what you want to do
      more than anything else is just to all put them in cvsnt so that you at
      least have them in one place.</para>

      <para>For handling situations in which there may be more than one
      vendor, you may specify the <command>-b</command> option to <command>cvs
      import</command>. It takes as an argument the vendor branch to import
      to. The default is <command>-b 1.1.1</command>.</para>

      <para>For example, suppose that there are two teams, the red team and
      the blue team, that are sending you sources. You want to import the red
      team's efforts to branch 1.1.1 and use the vendor tag RED. You want to
      import the blue team's efforts to branch 1.1.3 and use the vendor tag
      BLUE. So the commands you might use are:</para>

      <para><screen>$ cvs import dir RED RED_1-0
$ cvs import -b 1.1.3 dir BLUE BLUE_1-5
</screen></para>

      <para>Note that if your vendor tag does not match your
      <command>-b</command> option, cvsnt will not detect this case! For
      example,</para>

      <para><screen>
$ cvs import -b 1.1.3 dir RED RED_1-0
</screen></para>

      <para>Be careful; this kind of mismatch is sure to sow confusion or
      worse. I can't think of a useful purpose for the ability to specify a
      mismatch here, but if you discover such a use, don't. cvsnt is likely to
      make this an error in some future release.</para>
    </sect1>
  </chapter>

  <chapter id="Builds">
    <title>How your build system interacts with CVS</title>

    <para><indexterm>
        <primary>Builds</primary>
      </indexterm><indexterm>
        <primary>make</primary>
      </indexterm> As mentioned in the introduction, cvsnt does not contain
    software for building your software from source code. This section
    describes how various aspects of your build system might interact with
    cvsnt.</para>

    <para>One common question, especially from people who are accustomed to
    rcs, is how to make their build get an up to date copy of the sources. The
    answer to this with cvsnt is two-fold. First of all, since cvsnt itself
    can recurse through directories, there is no need to modify your
    <command>Makefile</command> (or whatever configuration file your build
    tool uses) to make sure each file is up to date. Instead, just use two
    commands, first <command>cvs -q update</command> and then
    <command>make</command> or whatever the command is to invoke your build
    tool. Secondly, you do not necessarily <emphasis>want</emphasis> to get a
    copy of a change someone else made until you have finished your own work.
    One suggested approach is to first update your sources, then implement,
    build and test the change you were thinking of, and then commit your
    sources (updating first if necessary). By periodically (in between
    changes, using the approach just described) updating your entire tree, you
    ensure that your sources are sufficiently up to date.</para>

    <para><indexterm>
        <primary>Bill of materials</primary>
      </indexterm>One common need is to record which versions of which source
    files went into a particular build. This kind of functionality is
    sometimes called <firstterm>bill of materials</firstterm> or something
    similar. The best way to do this with cvsnt is to use the
    <command>tag</command> command to record which versions went into a given
    build (<xref linkend="Tags" />).</para>

    <para>Using cvsnt in the most straightforward manner possible, each
    developer will have a copy of the entire source tree which is used in a
    particular build. If the source tree is small, or if developers are
    geographically dispersed, this is the preferred solution. In fact one
    approach for larger projects is to break a project down into smaller
    separately-compiled subsystems, and arrange a way of releasing them
    internally so that each developer need check out only those subsystems
    which are they are actively working on.</para>

    <para>Another approach is to set up a structure which allows developers to
    have their own copies of some files, and for other files to access source
    files from a central location. Many people have come up with some such a
    system using features such as the symbolic link feature found in many
    operating systems, or the <command>VPATH</command> feature found in many
    versions of <command>make</command>. One build tool which is designed to
    help with this kind of thing is Odin (see
    <command>ftp://ftp.cs.colorado.edu/pub/distribs/odin</command>).</para>
  </chapter>

  <chapter id="Special-Files">
    <title>Special Files</title>

    <para><indexterm>
        <primary>Special files</primary>
      </indexterm><indexterm>
        <primary>Device nodes</primary>
      </indexterm><indexterm>
        <primary>Ownership, saving in CVS</primary>
      </indexterm><indexterm>
        <primary>Permissions, saving in CVS</primary>
      </indexterm><indexterm>
        <primary>Hard links</primary>
      </indexterm><indexterm>
        <primary>Symbolic links</primary>
      </indexterm> In normal circumstances, cvsnt works only with regular
    files. Every file in a project is assumed to be persistent; it must be
    possible to open, read and close them; and so on. cvsnt also ignores file
    permissions and ownerships, leaving such issues to be resolved by the
    developer at installation time. In other words, it is not possible to
    "check in" a device into a repository; if the device file cannot be
    opened, cvsnt will refuse to handle it. Files also lose their ownerships
    and permissions during repository transactions.</para>
  </chapter>

  <appendix id="CVS-commands">
    <title>Guide to CVS commands</title>

    <para>This appendix describes the overall structure of cvsnt commands, and
    describes some commands in detail</para>

    <sect1 id="Structure">
      <title>Overall structure of CVS commands</title>

      <para><indexterm>
          <primary>Structure</primary>
        </indexterm><indexterm>
          <primary>CVS command structure</primary>
        </indexterm><indexterm>
          <primary>Command structure</primary>
        </indexterm><indexterm>
          <primary>Format of CVS commands</primary>
        </indexterm> The overall format of all cvsnt commands is:</para>

      <para><screen>cvs [ cvs_options ] cvs_command [ command_options ] [ command_args ]
</screen></para>

      <variablelist>
        <varlistentry>
          <term>cvs</term>

          <listitem>
            <para>The name of the cvsnt program.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs_options</term>

          <listitem>
            <para>Some options that affect all sub-commands of cvsnt. These
            are described below.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs_command</term>

          <listitem>
            <para>One of several different sub-commands. Some of the commands
            have aliases that can be used instead; those aliases are noted in
            the reference manual for that command. There are only two
            situations where you may omit <command>cvs_command</command>:
            <command>cvs -H</command> elicits a list of available commands,
            and <command>cvs -v</command> displays version information on
            cvsnt itself.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>command_options</term>

          <listitem>
            <para>Options that are specific for the command.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>command_args</term>

          <listitem>
            <para>Arguments to the commands.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>There is unfortunately some confusion between
      <command>cvs_options</command> and <command>command_options</command>.
      <command>-l</command>, when given as a <command>cvs_option</command>,
      only affects some of the commands. When it is given as a
      <command>command_option</command> is has a different meaning, and is
      accepted by more commands. In other words, do not take the above
      categorization too seriously. Look at the documentation instead.</para>
    </sect1>

    <sect1 id="Exit-status">
      <title>CVS's exit status</title>

      <para><indexterm>
          <primary>Exit status, of CVS</primary>
        </indexterm> cvsnt can indicate to the calling environment whether it
      succeeded or failed by setting its <firstterm>exit status</firstterm>.
      The exact way of testing the exit status will vary from one operating
      system to another. For example in a unix shell script the
      <command>$?</command> variable will be 0 if the last command returned a
      successful exit status, or greater than 0 if the exit status indicated
      failure.</para>

      <para>If cvsnt is successful, it returns a successful status; if there
      is an error, it prints an error message and returns a failure status.
      The one exception to this is the <command>cvs diff</command> command. It
      will return a successful status if it found no differences, or a failure
      status if there were differences or if there was an error. Because this
      behavior provides no good way to detect errors, in the future it is
      possible that <command>cvs diff</command> will be changed to behave like
      the other cvsnt commands.</para>
    </sect1>

    <sect1 id="cvsrc">
      <title>Default options and the ~/.cvsrc and CVSROOT/cvsrc files</title>

      <para><indexterm>
          <primary>.cvsrc file</primary>
        </indexterm><indexterm>
          <primary>cvsrc file</primary>
        </indexterm><indexterm>
          <primary>CVSROOT/cvsrc file</primary>
        </indexterm><indexterm>
          <primary>Option defaults</primary>
        </indexterm> There are some <command>command_options</command> that
      are used so often that you might have set up an alias or some other
      means to make sure you always specify that option. One example (the one
      that drove the implementation of the <command>.cvsrc</command> support,
      actually) is that many people find the default output of the
      <command>diff</command> command to be very hard to read, and that either
      context diffs or unidiffs are much easier to understand.</para>

      <para>The <command>~/.cvsrc</command> file is a way that you can add
      default options to <command>cvs_commands</command> within cvs, instead
      of relying on aliases or other shell scripts.</para>

      <para>The format of the <command>~/.cvsrc</command> file is simple. The
      file is searched for a line that begins with the same name as the
      <command>cvs_command</command> being executed. If a match is found, then
      the remainder of the line is split up (at whitespace characters) into
      separate options and added to the command arguments
      <emphasis>before</emphasis> any options from the command line.</para>

      <para>If a command has two names (e.g., <command>checkout</command> and
      <command>co</command>), the official name, not necessarily the one used
      on the command line, will be used to match against the file. So if this
      is the contents of the user's <command>~/.cvsrc</command> file:</para>

      <para><screen>log -N
diff -u
update -P
checkout -P
</screen></para>

      <para>the command <command>cvs checkout foo</command> would have the
      <command>-P</command> option added to the arguments, as well as
      <command>cvs co foo</command>.</para>

      <para>With the example file above, the output from <command>cvs diff
      foobar</command> will be in unidiff format. <command>cvs diff -c
      foobar</command> will provide context diffs, as usual. Getting "old"
      format diffs would be slightly more complicated, because
      <command>diff</command> doesn't have an option to specify use of the
      "old" format, so you would need <command>cvs -f diff
      foobar</command>.</para>

      <para>In place of the command name you can use <command>cvsnt</command>
      to specify global options (<xref linkend="Global-options" />). For
      example the following line in <command>.cvsrc</command></para>

      <para><screen>
cvs -z6
</screen></para>

      <para>causes cvsnt to use compression level 6.</para>

      <para>The <command>CVSROOT/cvsrc</command> file on the server contains
      the default .cvsrc file that is used by all compatible clients. This is
      merged with the local .cvsrc file and the result behaves as
      normal.</para>

      <para>The CVSROOT/cvsrc file cannot contain global options (<xref
      linkend="Global-options" />) as it is parsed after the server has
      started.</para>

      <para>Older <command>cvsnt</command> clients and Unix cvs clients will
      not use the global cvsrc.</para>
    </sect1>

    <sect1 id="Global-options">
      <title>Global options</title>

      <para><indexterm>
          <primary>Options, global</primary>
        </indexterm><indexterm>
          <primary>Global options</primary>
        </indexterm><indexterm>
          <primary>Left-hand options</primary>
        </indexterm> The available <command>cvs_options</command> (that are
      given to the left of <command>cvs_command</command>) are:</para>

      <variablelist>
        <varlistentry>
          <term>-allow-root=<varname>rootdir</varname></term>

          <listitem>
            <para>Specify legal cvsroot directory. Obsolete. See <xref
            linkend="Authentication-server" />.</para>

            <para><indexterm>
                <primary>Authentication, stream</primary>
              </indexterm><indexterm>
                <primary>Stream authentication</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-a</term>

          <term>--authenticate</term>

          <listitem>
            <para>Authenticate all communication between the client and the
            server. Only has an effect on the cvsnt client. Authentication
            prevents certain sorts of attacks involving hijacking the active
            tcp connection. Enabling authentication does not enable
            encryption.</para>

            <para><indexterm>
                <primary>rcsBIN, overriding</primary>
              </indexterm><indexterm>
                <primary>Overriding rcsBIN</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-b <varname>bindir</varname></term>

          <listitem>
            <para>In CVS 1.9.18 and older, this specified that rcs programs
            are in the <varname>bindir</varname> directory. Current versions
            of cvsnt do not run rcs programs; for compatibility this option is
            accepted, but it does nothing.</para>

            <para><indexterm>
                <primary>TMPDIR, overriding</primary>
              </indexterm><indexterm>
                <primary>Overriding TMPDIR</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-T <varname>tempdir</varname></term>

          <listitem>
            <para>Use <varname>tempdir</varname> as the directory where
            temporary files are located. Overrides the setting of the
            <command>$TMPDIR</command> environment variable and any
            precompiled directory. This parameter should be specified as an
            absolute pathname.</para>

            <para><indexterm>
                <primary>CVSROOT, overriding</primary>
              </indexterm><indexterm>
                <primary>Overriding CVSROOT</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-d <varname>cvs_root_directory</varname></term>

          <listitem>
            <para>Use <varname>cvs_root_directory</varname> as the root
            directory pathname of the repository. Overrides the setting of the
            <command>$CVSROOT</command> environment variable. <xref
            linkend="Repository" />.</para>

            <para><indexterm>
                <primary>EDITOR, overriding</primary>
              </indexterm><indexterm>
                <primary>Overriding EDITOR</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-e <varname>editor</varname></term>

          <listitem>
            <para>Use <varname>editor</varname> to enter revision log
            information. Overrides the setting of the
            <command>$CVSEDITOR</command> and <command>$EDITOR</command>
            environment variables. For more information, see <xref
            linkend="Committing-your-changes" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-f</term>

          <listitem>
            <para>Do not read the <command>~/.cvsrc</command> file. This
            option is most often used because of the non-orthogonality of the
            cvsnt option set. For example, the <command>cvs log</command>
            option <command>-N</command> (turn off display of tag names) does
            not have a corresponding option to turn the display on. So if you
            have <command>-N</command> in the <command>~/.cvsrc</command>
            entry for <command>log</command>, you may need to use
            <command>-f</command> to show the tag names.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-F <varname>file</varname></term>

          <listitem>
            <para>Read the contents of <varname>file</varname> and append it
            to the supplied command line. Arguments are separated by
            whitespace, and follow normal quoting rules.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-H</term>

          <term>-help</term>

          <listitem>
            <para>Display usage information about the specified
            <command>cvs_command</command> (but do not actually execute the
            command). If you don't specify a command name, <command>cvs
            -H</command> displays overall help for cvsnt, including a list of
            other help options.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-l</term>

          <listitem>
            <para>Do not log the <command>cvs_command</command> in the command
            history (but execute it anyway). <xref linkend="history" />, for
            information on command history.</para>

            <para><indexterm>
                <primary>Read-only mode</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-n</term>

          <listitem>
            <para>Do not change any files. Attempt to execute the
            <command>cvs_command</command>, but only to issue reports; do not
            remove, update, or merge any existing files, or create any new
            files.</para>

            <para>This option has a long history and is not guaranteed to
            actually leave the sandbox in the same state that it started with.
            It is supported only for the <command>checkout</command> command
            to an empty directory, which is required by certain
            frontends.</para>

            <para>cvsnt has other commands which replace the functionality of
            this option - see <command>status -q</command> and
            <command>ls</command> commands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-N</term>

          <listitem>
            <para>Enable :local: access to a network share. Normally this is
            explicitly prohibited to discourage its use. It is recommended
            that you setup a proper server instead, as problems encountered
            using network shares will not normally be supported.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-o[locale]</term>

          <listitem>
            <para>Where supported by the server (CVSNT 2.0.57+), try to
            convert the character set of the server to that of the client.
            This allows you to store exended characters such an umlauts in the
            repository even if your machine is set to a different
            codepage/language to the server.</para>

            <para>For Win32, the codepage used is the current ANSI codepage.
            This may not render correctly in the OEM codepage used by the
            command line processor. To verify that CVSNT is doing the correct
            conversion look at the filename in Windows Explorer.</para>

            <para>As of CVSNT 2.0.59 this is the default behaviour.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-O</term>

          <listitem>
            <para>Disable client/server locale translation. If the client and
            server are not in the same locale then care must be taken not to
            use characters outside US-ASCII codepage if this option is
            used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-Q</term>

          <listitem>
            <para>Cause the command to be really quiet; the command will only
            generate output for serious problems.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-q</term>

          <listitem>
            <para>Cause the command to be somewhat quiet; informational
            messages, such as reports of recursion through subdirectories, are
            suppressed.</para>

            <para><indexterm>
                <primary>Read-only files, and -r</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-r</term>

          <listitem>
            <para>Make new working files read-only. Same effect as if the
            <command>$CVSREAD</command> environment variable is set (<xref
            linkend="Environment-variables" />). The default is to make
            working files writable, unless watches are on (<xref
            linkend="Watches" />).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--readonly</term>

          <listitem>
            <para>Make all users readonly. This is used for read only mirror
            servers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-s <varname>variable</varname>=<varname>value</varname></term>

          <listitem>
            <para>Set a user variable (<xref linkend="Variables" />).</para>

            <para><indexterm>
                <primary>Trace</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-t</term>

          <listitem>
            <para>Trace program execution; display messages showing the steps
            of cvsnt activity. Particularly useful with <command>-n</command>
            to explore the potential impact of an unfamiliar command. More
            instances of -t increase verbosity.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-v</term>

          <term>--version</term>

          <listitem>
            <para>Display version and copyright information for cvsnt.</para>

            <para><indexterm>
                <primary>CVSREAD, overriding</primary>
              </indexterm><indexterm>
                <primary>Overriding CVSREAD</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-w</term>

          <listitem>
            <para>Make new working files read-write. Overrides the setting of
            the <command>$CVSREAD</command> environment variable. Files are
            created read-write by default, unless <command>$CVSREAD</command>
            is set or <command>-r</command> is given.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-x</term>

          <term>--encrypt</term>

          <listitem>
            <para><indexterm>
                <primary>Encryption</primary>
              </indexterm>Encrypt all communication between the client and the
            server. Only has an effect on the cvsnt client. Enabling
            encryption implies that message traffic is also
            authenticated.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-z <varname>gzip-level</varname></term>

          <listitem>
            <para><indexterm>
                <primary>Compression</primary>
              </indexterm><indexterm>
                <primary>Gzip</primary>
              </indexterm>Set the compression level. Valid levels are 1 (high
            speed, low compression) to 9 (low speed, high compression), or 0
            to disable compression (the default). Only has an effect on the
            cvsnt client.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="Common-options">
      <title>Common command options</title>

      <para><indexterm>
          <primary>Common options</primary>
        </indexterm><indexterm>
          <primary>Right-hand options</primary>
        </indexterm> This section describes the
      <command>command_options</command> that are available across several
      cvsnt commands. These options are always given to the right of
      <command>cvs_command</command>. Not all commands support all of these
      options; each option is only supported for commands where it makes
      sense. However, when a command has one of these options you can almost
      always count on the same behavior of the option as in other commands.
      (Other command options, which are listed with the individual commands,
      may have different behavior from one cvsnt command to the other).</para>

      <para><emphasis>Warning:</emphasis> the <command>history</command>
      command is an exception; it supports many options that conflict even
      with these standard options.</para>

      <variablelist>
        <title><indexterm>
            <primary>Dates</primary>
          </indexterm><indexterm>
            <primary>Time</primary>
          </indexterm><indexterm>
            <primary>Specifying dates</primary>
          </indexterm></title>

        <varlistentry>
          <term>-D <varname>date_spec</varname></term>

          <listitem>
            <para>Use the most recent revision no later than
            <varname>date_spec</varname>. <varname>date_spec</varname> is a
            single argument, a date description specifying a date in the
            past.</para>

            <para>The specification is <firstterm>sticky</firstterm> when you
            use it to make a private copy of a source file; that is, when you
            get a working file using <command>-D</command>, cvsnt records the
            date you specified, so that further updates in the same directory
            will use the same date (for more information on sticky tags/dates,
            <xref linkend="Sticky-tags" />).</para>

            <para><command>-D</command> is available with the
            <command>checkout</command>, <command>diff</command>,
            <command>export</command>, <command>history</command>,
            <command>rdiff</command>, <command>rtag</command>, and
            <command>update</command> commands. (The
            <command>history</command> command uses this option in a slightly
            different way; <xref linkend="history-options" />).</para>

            <para><indexterm>
                <primary>Timezone, in input</primary>
              </indexterm><indexterm>
                <primary>Zone, time, in input</primary>
              </indexterm>A wide variety of date formats are supported by
            cvsnt. The most standard ones are ISO8601 (from the International
            Standards Organization) and the Internet e-mail standard
            (specified in RFC822 as amended by RFC1123).</para>

            <para>ISO8601 dates have many variants but a few examples
            are:</para>

            <para><screen>1972-09-24
1972-09-24 20:05
</screen></para>

            <para>There are a lot more ISO8601 date formats, and cvsnt accepts
            many of them, but you probably don't want to hear the
            <emphasis>whole</emphasis> long story :-).</para>

            <para>In addition to the dates allowed in Internet e-mail itself,
            cvsnt also allows some of the fields to be omitted. For
            example:</para>

            <para><screen>
24 Sep 1972 20:05
24 Sep
</screen></para>

            <para>The date is interpreted as being in the local timezone,
            unless a specific timezone is specified.</para>

            <para>These two date formats are preferred. However, cvsnt
            currently accepts a wide variety of other date formats. They are
            intentionally not documented here in any detail, and future
            versions of cvsnt might not accept all of them.</para>

            <para>One such format is
            <command><varname>month</varname>/<varname>day</varname>/<varname>year</varname></command>.
            This may confuse people who are accustomed to having the month and
            day in the other order; <command>1/4/96</command> is January 4,
            not April 1.</para>

            <para>Remember to quote the argument to the <command>-D</command>
            flag so that your shell doesn't interpret spaces as argument
            separators. A command using the <command>-D</command> flag can
            look like this:</para>

            <para><screen>
$ cvs diff -D "1 hour ago" cvs.texinfo
</screen></para>

            <para><indexterm>
                <primary>Forcing a tag match</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-f</term>

          <listitem>
            <para>When you specify a particular date or tag to cvsnt commands,
            they normally ignore files that do not contain the tag (or did not
            exist prior to the date) that you specified. Use the
            <command>-f</command> option if you want files retrieved even when
            there is no match for the tag or date. (The most recent revision
            of the file will be used).</para>

            <para>Note that even with <command>-f</command>, a tag that you
            specify must exist (that is, in some file, not necessary in every
            file). This is so that cvsnt will continue to give an error if you
            mistype a tag name.</para>

            <para><command>-f</command> is available with these commands:
            <command>annotate</command>, <command>checkout</command>,
            <command>export</command>, <command>rdiff</command>,
            <command>rtag</command>, and <command>update</command>.</para>

            <para><emphasis>Warning:</emphasis> The <command>commit</command>
            and <command>remove</command> commands also have a
            <command>-f</command> option, but it has a different behavior for
            those commands. See <xref linkend="commit-options" />, and <xref
            linkend="Removing-files" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-k <varname>kflag</varname></term>

          <listitem>
            <para>Alter the default processing of keywords. <xref
            linkend="Keyword-substitution" />, for the meaning of
            <varname>kflag</varname>. Your <varname>kflag</varname>
            specification is <firstterm>sticky</firstterm> when you use it to
            create a private copy of a source file; that is, when you use this
            option with the <command>checkout</command> or
            <command>update</command> commands, cvsnt associates your selected
            <varname>kflag</varname> with the file, and continues to use it
            with future update commands on the same file until you specify
            otherwise.</para>

            <para>The <command>-k</command> option is available with the
            <command>add</command>, <command>checkout</command>,
            <command>diff</command>, <command>import</command> and
            <command>update</command> commands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-l</term>

          <listitem>
            <para>Local; run only in current working directory, rather than
            recursing through subdirectories.</para>

            <para><emphasis>Warning:</emphasis> this is not the same as the
            overall <command>cvs -l</command> option, which you can specify to
            the left of a cvs command!</para>

            <para>Available with the following commands:
            <command>annotate</command>, <command>checkout</command>,
            <command>commit</command>, <command>diff</command>,
            <command>edit</command>, <command>editors</command>,
            <command>export</command>, <command>log</command>,
            <command>rdiff</command>, <command>remove</command>,
            <command>rtag</command>, <command>status</command>,
            <command>tag</command>, <command>unedit</command>,
            <command>update</command>, <command>watch</command>, and
            <command>watchers</command>.</para>

            <para><indexterm>
                <primary>Editor, avoiding invocation of</primary>
              </indexterm><indexterm>
                <primary>Avoiding editor invocation</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-m <varname>message</varname></term>

          <listitem>
            <para>Use <varname>message</varname> as log information, instead
            of invoking an editor.</para>

            <para>Available with the following commands:
            <command>add</command>, <command>commit</command> and
            <command>import</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-n</term>

          <listitem>
            <para>Do not run any checkout/commit/tag program. (A program can
            be specified to run on each of these activities, in the modules
            database (<xref linkend="modules" />); this option bypasses
            it).</para>

            <para><emphasis>Warning:</emphasis> this is not the same as the
            overall <command>cvs -n</command> option, which you can specify to
            the left of a cvs command!</para>

            <para>Available with the <command>checkout</command>,
            <command>commit</command>, <command>export</command>, and
            <command>rtag</command> commands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-P</term>

          <listitem>
            <para>Prune empty directories. See <xref
            linkend="Removing-directories" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-p</term>

          <listitem>
            <para>Pipe the files retrieved from the repository to standard
            output, rather than writing them in the current directory.
            Available with the <command>checkout</command> and
            <command>update</command> commands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-R</term>

          <listitem>
            <para>Process directories recursively. This is on by
            default.</para>

            <para>Available with the following commands:
            <command>annotate</command>, <command>checkout</command>,
            <command>commit</command>, <command>diff</command>,
            <command>edit</command>, <command>editors</command>,
            <command>export</command>, <command>rdiff</command>,
            <command>remove</command>, <command>rtag</command>,
            <command>status</command>, <command>tag</command>,
            <command>unedit</command>, <command>update</command>,
            <command>watch</command>, and <command>watchers</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-r <varname>tag</varname></term>

          <listitem>
            <para><indexterm>
                <primary>HEAD, special tag</primary>
              </indexterm><indexterm>
                <primary>BASE, special tag</primary>
              </indexterm>Use the revision specified by the
            <varname>tag</varname> argument instead of the default
            <firstterm>head</firstterm> revision. As well as arbitrary tags
            defined with the <command>tag</command> or <command>rtag</command>
            command, two special tags are always available:
            <command>HEAD</command> refers to the most recent version
            available in the repository, and <command>BASE</command> refers to
            the revision you last checked out into the current working
            directory.</para>

            <para>The tag specification is sticky when you use this with
            <command>checkout</command> or <command>update</command> to make
            your own copy of a file: cvsnt remembers the tag and continues to
            use it on future update commands, until you specify otherwise (for
            more information on sticky tags/dates, <xref
            linkend="Sticky-tags" />).</para>

            <para>The tag can be either a symbolic or numeric tag, as
            described in <xref linkend="Tags" />, or the name of a branch, as
            described in <xref linkend="Branching-and-merging" />.</para>

            <para>Specifying the <command>-q</command> global option along
            with the <command>-r</command> command option is often useful, to
            suppress the warning messages when the rcs file does not contain
            the specified tag.</para>

            <para><emphasis>Warning:</emphasis> this is not the same as the
            overall <command>cvs -r</command> option, which you can specify to
            the left of a cvsnt command!</para>

            <para><command>-r</command> is available with the
            <command>checkout</command>, <command>commit</command>,
            <command>diff</command>, <command>history</command>,
            <command>export</command>, <command>rdiff</command>,
            <command>rtag</command>, and <command>update</command>
            commands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>-W</term>

          <listitem>
            <para>Specify file names that should be filtered. You can use this
            option repeatedly. The spec can be a file name pattern of the same
            type that you can specify in the <command>.cvswrappers</command>
            file. Available with the following commands:
            <command>import</command>, and <command>update</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="add">
      <title>add--Add files to repository</title>

      <para><indexterm>
          <primary>add</primary>
        </indexterm><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonym: ad,new</para>
          </listitem>
        </itemizedlist>This adds new files to the existing working directory.
      Before any commands which operate on sandbox files can be used, they
      must be added to the list of cvs controlled files using this
      command.</para>

      <para>Directories are added immediately, and exist on all branches.
      Ordinary files must be committed before other users are able to use
      them.</para>

      <sect2>
        <title>add options</title>

        <para><variablelist>
            <varlistentry>
              <term>-b bugid</term>

              <listitem>
                <para>Mark the newly added file with a bug identifier.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-k kflag</term>

              <listitem>
                <para>Override the default expansion option for the
                file.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-m message</term>

              <listitem>
                <para>Use "message" for the message creation log.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r branch</term>

              <listitem>
                <para>Add the new file onto a different branch (default is the
                same branch as the directory).</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="admin">
      <title>admin--Administration</title>

      <para><indexterm>
          <primary>Admin</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Requires: repository, working directory.</para>
        </listitem>

        <listitem>
          <para>Changes: repository.</para>
        </listitem>

        <listitem>
          <para>Synonym: adm,rcs</para>
        </listitem>
      </itemizedlist>

      <para>This is the cvsnt interface to assorted administrative facilities.
      Some of them have questionable usefulness for cvsnt but exist for
      historical purposes. Some of the questionable options are likely to
      disappear in the future. This command <emphasis>does</emphasis> work
      recursively, so extreme care should be used.</para>

      <para>Do not use this command unless you know what you are doing. Some
      of the admin commands can have unexpected consequences.</para>

      <para><indexterm>
          <primary>cvsadmin</primary>
        </indexterm>On unix, if there is a group named
      <command>cvsadmin</command>, only members of that group can run
      <command>cvs admin</command>. This group should exist on the server, or
      any system running the non-client/server cvsnt. To disallow <command>cvs
      admin</command> for all users, create a group with no users in it. On
      NT, server administrators are able to use the admin command.</para>

      <sect2 id="admin-options">
        <title>admin options</title>

        <variablelist>
          <varlistentry>
            <term>-k<varname>subst</varname></term>

            <listitem>
              <para>This option is provided as legacy support for older
              servers and has no function under CVSNT.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l[<varname>rev</varname>]</term>

            <listitem>
              <para>Lock the revision with number <varname>rev</varname>. If a
              branch is given, lock the latest revision on that branch. If
              <varname>rev</varname> is omitted, lock the latest revision on
              the default branch. There can be no space between
              <command>-l</command> and its argument.</para>

              <para>This command is depreciated in favour of the 'edit -c'
              command, which gives pseudo reserved checkouts.</para>

              <para><indexterm>
                  <primary>Changing a log message</primary>
                </indexterm><indexterm>
                  <primary>Replacing a log message</primary>
                </indexterm><indexterm>
                  <primary>Correcting a log message</primary>
                </indexterm><indexterm>
                  <primary>Fixing a log message</primary>
                </indexterm><indexterm>
                  <primary>Log message, correcting</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-m<varname>rev</varname>:<varname>msg</varname></term>

            <listitem>
              <para>Replace the log message of revision <varname>rev</varname>
              with <varname>msg</varname>.</para>

              <para><indexterm>
                  <primary>Deleting revisions</primary>
                </indexterm><indexterm>
                  <primary>Outdating revisions</primary>
                </indexterm><indexterm>
                  <primary>Saving space</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-o<varname>range</varname></term>

            <listitem>
              <para>Deletes (<firstterm>outdates</firstterm>) the revisions
              given by <varname>range</varname>.</para>

              <para>Note that this command can be quite dangerous unless you
              know <emphasis>exactly</emphasis> what you are doing (for
              example see the warnings below about how the
              <varname>rev1</varname>:<varname>rev2</varname> syntax is
              confusing).</para>

              <para>If you are short on disc this option might help you. But
              think twice before using it--there is no way short of restoring
              the latest backup to undo this command! If you delete different
              revisions than you planned, either due to carelessness or
              (heaven forbid) a cvsnt bug, there is no opportunity to correct
              the error before the revisions are deleted. It probably would be
              a good idea to experiment on a copy of the repository
              first.</para>

              <para>Specify <varname>range</varname> in one of the following
              ways:</para>

              <variablelist>
                <varlistentry>
                  <term><varname>rev1</varname>::<varname>rev2</varname></term>

                  <listitem>
                    <para>Collapse all revisions between rev1 and rev2, so
                    that cvsnt only stores the differences associated with
                    going from rev1 to rev2, not intermediate steps. For
                    example, after <command>-o 1.3::1.5</command> one can
                    retrieve revision 1.3, revision 1.5, or the differences to
                    get from 1.3 to 1.5, but not the revision 1.4, or the
                    differences between 1.3 and 1.4. Other examples:
                    <command>-o 1.3::1.4</command> and <command>-o
                    1.3::1.3</command> have no effect, because there are no
                    intermediate revisions to remove.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>::<varname>rev</varname></term>

                  <listitem>
                    <para>Collapse revisions between the beginning of the
                    branch containing <varname>rev</varname> and
                    <varname>rev</varname> itself. The branchpoint and
                    <varname>rev</varname> are left intact. For example,
                    <command>-o ::1.3.2.6</command> deletes revision 1.3.2.1,
                    revision 1.3.2.5, and everything in between, but leaves
                    1.3 and 1.3.2.6 intact.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>rev</varname>::</term>

                  <listitem>
                    <para>Collapse revisions between <varname>rev</varname>
                    and the end of the branch containing
                    <varname>rev</varname>. Revision <varname>rev</varname> is
                    left intact but the head revision is deleted.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>rev</varname></term>

                  <listitem>
                    <para>Delete the revision <varname>rev</varname>. For
                    example, <command>-o 1.3</command> is equivalent to
                    <command>-o 1.2::1.4</command>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>rev1</varname>:<varname>rev2</varname></term>

                  <listitem>
                    <para>Delete the revisions from <varname>rev1</varname> to
                    <varname>rev2</varname>, inclusive, on the same branch.
                    One will not be able to retrieve <varname>rev1</varname>
                    or <varname>rev2</varname> or any of the revisions in
                    between. For example, the command <command>cvs admin
                    -oR_1_01:R_1_02 .</command> is rarely useful. It means to
                    delete revisions up to, and including, the tag R_1_02. But
                    beware! If there are files that have not changed between
                    R_1_02 and R_1_03 the file will have <emphasis>the
                    same</emphasis> numerical revision number assigned to the
                    tags R_1_02 and R_1_03. So not only will it be impossible
                    to retrieve R_1_02; R_1_03 will also have to be restored
                    from the tapes! In most cases you want to specify
                    <varname>rev1</varname>::<varname>rev2</varname>
                    instead.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>:<varname>rev</varname></term>

                  <listitem>
                    <para>Delete revisions from the beginning of the branch
                    containing <varname>rev</varname> up to and including
                    <varname>rev</varname>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>rev</varname>:</term>

                  <listitem>
                    <para>Delete revisions from revision
                    <varname>rev</varname>, including <varname>rev</varname>
                    itself, to the end of the branch containing
                    <varname>rev</varname>.</para>
                  </listitem>
                </varlistentry>
              </variablelist>

              <para>None of the revisions to be deleted may have branches or
              locks.</para>

              <para>If any of the revisions to be deleted have symbolic names,
              and one specifies one of the <command>::</command> syntaxes,
              then cvsnt will give an error and not delete any revisions. If
              you really want to delete both the symbolic names and the
              revisions, first delete the symbolic names with <command>cvs tag
              -d</command>, then run <command>cvs admin -o</command>. If one
              specifies the non-<command>::</command> syntaxes, then cvsnt
              will delete the revisions but leave the symbolic names pointing
              to nonexistent revisions. This behavior is preserved for
              compatibility with previous versions of cvsnt, but because it
              isn't very useful, in the future it may change to be like the
              <command>::</command> case.</para>

              <para>Due to the way cvsnt handles branches
              <varname>rev</varname> cannot be specified symbolically if it is
              a branch. <xref linkend="Magic-branch-numbers" />, for an
              explanation.</para>

              <para>Make sure that no-one has checked out a copy of the
              revision you outdate. Strange things will happen if he starts to
              edit it and tries to check it back in. For this reason, this
              option is not a good way to take back a bogus commit; commit a
              new revision undoing the bogus change instead (<xref
              linkend="Merging-two-revisions" />).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-q</term>

            <listitem>
              <para>Run quietly; do not print diagnostics.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t[<varname>file</varname>]</term>

            <listitem>
              <para>Useful with cvsnt. Write descriptive text from the
              contents of the named <varname>file</varname> into the rcs file,
              deleting the existing text. The <varname>file</varname> pathname
              may not begin with <command>-</command>. The descriptive text
              can be seen in the output from <command>cvs log</command> (<xref
              linkend="log" />). There can be no space between
              <command>-t</command> and its argument.</para>

              <para>If <varname>file</varname> is omitted, obtain the text
              from standard input, terminated by end-of-file or by a line
              containing <command>.</command> by itself. Prompt for the text
              if interaction is possible; see <command>-I</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t-<varname>string</varname></term>

            <listitem>
              <para>Similar to <command>-t<varname>file</varname></command>.
              Write descriptive text from the <varname>string</varname> into
              the rcs file, deleting the existing text. There can be no space
              between <command>-t</command> and its argument.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <sect1 id="annotate">
      <title>annotate--find out who made changes to the files</title>

      <indexterm>
        <primary>annotate</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: ann</para>
          </listitem>
        </itemizedlist>Annotate is used to discover who made changes to
      specific lines within files. The output to annotate gives the username,
      date and version number of the change.</para>

      <para>The output to annotate is similar to checkout, for example:</para>

      <screen>1.54         (tmh      28-Aug-02):      char host[NI_MAXHOST];
1.54         (tmh      28-Aug-02):
1.71         (tmh      26-Mar-03):      if(!getnameinfo((struct sockaddr*)&amp;ss,ss_len,host,NI_MAXHOST,NULL,0,flags))
1.54         (tmh      28-Aug-02):          remote_host_name = xstrdup(host);
</screen>

      <para>This information is usually enough to assign blame (or credit!)
      when tracing bugs.</para>

      <sect2>
        <title>annotate options</title>

        <para><variablelist>
            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Local directory only, no recursion</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively (default).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-f</term>

              <listitem>
                <para>Use head revision if tag is not found.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r rev</term>

              <listitem>
                <para>Annotate files for specific revision or tag.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-D date</term>

              <listitem>
                <para>Annotate files for specific date</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="chacl">
      <title>chacl--Change access control lists</title>

      <indexterm>
        <primary>chacl</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonyms: setacl, setperm</para>
          </listitem>
        </itemizedlist>Modify the access control list for a file or directory.
      See also <xref linkend="Setting-permissions" /> for more details.</para>

      <sect2>
        <title>chacl options</title>

        <para><variablelist>
            <varlistentry>
              <term>-a</term>

              <listitem>
                <para>Add access control entry - any combination of
                read,write,create,tag,control. Any of these may be prefixed by
                'no' to deny access. Also special access all or none for
                setting all permissions.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-d</term>

              <listitem>
                <para>Delete access control entry</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-j branch</term>

              <listitem>
                <para>Entry applies when merging from branch.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-m message</term>

              <listitem>
                <para>Show customised error message when access is blocked due
                to this entry.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-n</term>

              <listitem>
                <para>Stop entry from being inherited by
                subdirectories.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-p priority</term>

              <listitem>
                <para>Modify the priority that this entry has. This is an
                advanced option - the internal prioritisation is designed to
                work correctly in most circumstances.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r branch</term>

              <listitem>
                <para>This entry applies to a single branch only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Recurse into subdirectories. Note that becuase entries
                are by default recursive this option is not normally
                required.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-u user</term>

              <listitem>
                <para>This entry applies to a single user (or group)
                only.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="checkout">
      <title>checkout--Check out sources for editing</title>

      <para><indexterm>
          <primary>checkout</primary>
        </indexterm><indexterm>
          <primary>co</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: checkout [options] modules...</para>
        </listitem>

        <listitem>
          <para>Requires: repository.</para>
        </listitem>

        <listitem>
          <para>Changes: working directory.</para>
        </listitem>

        <listitem>
          <para>Synonyms: co, get</para>
        </listitem>
      </itemizedlist>

      <para>Create or update a working directory containing copies of the
      source files specified by <varname>modules</varname>. You must execute
      <command>checkout</command> before using most of the other cvsnt
      commands, since most of them operate on your working directory.</para>

      <para>The <varname>modules</varname> are either symbolic names for some
      collection of source directories and files, or paths to directories or
      files in the repository. The symbolic names are defined in the
      <command>modules</command> file. <xref linkend="modules" />.</para>

      <para>Depending on the modules you specify, <command>checkout</command>
      may recursively create directories and populate them with the
      appropriate source files. You can then edit these source files at any
      time (regardless of whether other software developers are editing their
      own copies of the sources); update them to include new changes applied
      by others to the source repository; or commit your work as a permanent
      change to the source repository.</para>

      <para>Note that <command>checkout</command> is used to create
      directories. The top-level directory created is always added to the
      directory where <command>checkout</command> is invoked, and usually has
      the same name as the specified module. In the case of a module alias,
      the created sub-directory may have a different name, but you can be sure
      that it will be a sub-directory, and that <command>checkout</command>
      will show the relative path leading to each file as it is extracted into
      your private work area (unless you specify the <command>-Q</command>
      global option).</para>

      <para>The files created by <command>checkout</command> are created
      read-write, unless the <command>-r</command> option to cvsnt (<xref
      linkend="Global-options" />) is specified, the
      <command>CVSREAD</command> environment variable is specified (<xref
      linkend="Environment-variables" />), or a watch is in effect for that
      file (<xref linkend="Watches" />).</para>

      <para>Note that running <command>checkout</command> on a directory that
      was already built by a prior <command>checkout</command> is also
      permitted. This is similar to specifying the <command>-d</command>
      option to the <command>update</command> command in the sense that new
      directories that have been created in the repository will appear in your
      work area. However, <command>checkout</command> takes a module name
      whereas <command>update</command> takes a directory name. Also to use
      <command>checkout</command> this way it must be run from the top level
      directory (where you originally ran <command>checkout</command> from),
      so before you run <command>checkout</command> to update an existing
      directory, don't forget to change your directory to the top level
      directory.</para>

      <para>For the output produced by the <command>checkout</command> command
      see <xref linkend="update-output" />.</para>

      <sect2 id="checkout-options">
        <title>checkout options</title>

        <para>These standard options are supported by
        <command>checkout</command> (<xref linkend="Common-options" />, for a
        complete description of them):</para>

        <variablelist>
          <varlistentry>
            <term>-D <varname>date</varname></term>

            <listitem>
              <para>Use the most recent revision no later than
              <varname>date</varname>. This option is sticky, and implies
              <command>-P</command>. See <xref linkend="Sticky-tags" />, for
              more information on sticky tags/dates.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>Only useful with the <command>-D
              <varname>date</varname></command> or <command>-r
              <varname>tag</varname></command> flags. If no matching revision
              is found, retrieve the most recent revision (instead of ignoring
              the file).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-k <varname>kflag</varname></term>

            <listitem>
              <para>Process keywords according to <varname>kflag</varname>.
              See <xref linkend="Keyword-substitution" />. This option is
              sticky; future updates of this file in this working directory
              will use the same <varname>kflag</varname>. The
              <command>status</command> command can be viewed to see the
              sticky options. See <xref linkend="status" />, for more
              information on the <command>status</command> command.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Local; run only in current working directory.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-n</term>

            <listitem>
              <para>Do not run any checkout program (as specified with the
              <command>-o</command> option in the modules file; <xref
              linkend="modules" />).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-P</term>

            <listitem>
              <para>Prune empty directories. See <xref
              linkend="Moving-directories" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-p</term>

            <listitem>
              <para>Pipe files to the standard output.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-R</term>

            <listitem>
              <para>Checkout directories recursively. This option is on by
              default.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r <varname>tag</varname></term>

            <listitem>
              <para>Use revision <varname>tag</varname>. This option is
              sticky, and implies <command>-P</command>. See <xref
              linkend="Sticky-tags" />, for more information on sticky
              tags/dates.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>In addition to those, you can use these special command options
        with <command>checkout</command>:</para>

        <variablelist>
          <varlistentry>
            <term>-A</term>

            <listitem>
              <para>Reset any sticky tags, dates, or <command>-k</command>
              options. See <xref linkend="Sticky-tags" />, for more
              information on sticky tags/dates.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-c</term>

            <listitem>
              <para>Copy the module file, sorted, to the standard output,
              instead of creating or modifying any files or directories in
              your working directory.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-d <varname>dir</varname></term>

            <listitem>
              <para>Create a directory called <varname>dir</varname> for the
              working files, instead of using the module name. In general,
              using this flag is equivalent to using <command>mkdir
              <varname>dir</varname>; cd <varname>dir</varname></command>
              followed by the checkout command without the
              <command>-d</command> flag.</para>

              <para>There is an important exception, however. It is very
              convenient when checking out a single item to have the output
              appear in a directory that doesn't contain empty intermediate
              directories. In this case <emphasis>only</emphasis>, cvsnt tries
              to "shorten" pathnames to avoid those empty directories.</para>

              <para>For example, given a module <command>foo</command> that
              contains the file <command>bar.c</command>, the command
              <command>cvs co -d dir foo</command> will create directory
              <command>dir</command> and place <command>bar.c</command>
              inside. Similarly, given a module <command>bar</command> which
              has subdirectory <command>baz</command> wherein there is a file
              <command>quux.c</command>, the command <command>cvs -d dir co
              bar/baz</command> will create directory <command>dir</command>
              and place <command>quux.c</command> inside.</para>

              <para>Using the <command>-N</command> flag will defeat this
              behavior. Given the same module definitions above, <command>cvs
              co -N -d dir foo</command> will create directories
              <command>dir/foo</command> and place <command>bar.c</command>
              inside, while <command>cvs co -N -d dir bar/baz</command> will
              create directories <command>dir/bar/baz</command> and place
              <command>quux.c</command> inside.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-j <varname>tag</varname></term>

            <listitem>
              <para>With two <command>-j</command> options, merge changes from
              the revision specified with the first <command>-j</command>
              option to the revision specified with the second
              <command>j</command> option, into the working directory.</para>

              <para>With one <command>-j</command> option, merge changes from
              the ancestor revision to the revision specified with the
              <command>-j</command> option, into the working directory. The
              ancestor revision is the common ancestor of the revision which
              the working directory is based on, and the revision specified in
              the <command>-j</command> option.</para>

              <para>In addition, each -j option can contain an optional date
              specification which, when used with branches, can limit the
              chosen revision to one within a specific date. An optional date
              is specified by adding a colon (:) to the tag:
              <command>-j<varname>Symbolic_Tag</varname>:<varname>Date_Specifier</varname></command>.</para>

              <para><xref linkend="Branching-and-merging" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-b</term>

            <listitem>
              <para>Perform the -j merge from the branchpoint not the last
              mergepoint. This can be useful to re-merge changes that have
              been merged before, however it likely to produce a lot of
              conflicts.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-m</term>

            <listitem>
              <para>Perform the -j merge from the last recorded mergepoint.
              This is the default.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-N</term>

            <listitem>
              <para>Only useful together with <command>-d
              <varname>dir</varname></command>. With this option, cvsnt will
              not "shorten" module paths in your working directory when you
              check out a single module. See the <command>-d</command> flag
              for examples and a discussion.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-s</term>

            <listitem>
              <para>Like <command>-c</command>, but include the status of all
              modules, and sort it by the status string. <xref
              linkend="modules" />, for info about the <command>-s</command>
              option that is used inside the modules file to set the module
              status.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-3</term>

            <listitem>
              <para>Produce 3-way conflict differences, containing the old and
              new files from the server and the edited files.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-S</term>

            <listitem>
              <para>Select between conflicting case-sensitive names on a
              case-insensitive client. This provides limited support for
              checking out repositories with such conflicts - the problem
              should really be fixed in the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t</term>

            <listitem>
              <para>Update using the last checkin time not the current time.
              This can cause issues with build systems so it is not
              recommended that this be used unless you are fully aware of the
              side-effects.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="checkout-examples">
        <title>checkout examples</title>

        <para>Get a copy of the module <command>tc</command>:</para>

        <para><screen>$ cvs checkout tc
</screen></para>

        <para>Get a copy of the module <command>tc</command> as it looked one
        day ago:</para>

        <para><screen>
$ cvs checkout -D yesterday tc
</screen></para>
      </sect2>
    </sect1>

    <sect1 id="chown">
      <title>chown--Change directory owner<indexterm>
          <primary>chown</primary>
        </indexterm></title>

      <para><itemizedlist>
          <listitem>
            <para>Requires: working directory, repository</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonyms: setowner</para>
          </listitem>
        </itemizedlist>Change the owner of a directory. The owner has
      administration rights over files within that directory, in addittion to
      the standard cvsnt administrators.</para>

      <sect2>
        <title>chown options</title>

        <para><variablelist>
            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Change directory owner recursively.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="commit">
      <title>commit--Check files into the repository</title>

      <para><indexterm>
          <primary>commit</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: commit [-lnRf] [-m 'log_message' | -F file] [-r
          revision] [files...]</para>
        </listitem>

        <listitem>
          <para>Requires: working directory, repository.</para>
        </listitem>

        <listitem>
          <para>Changes: repository.</para>
        </listitem>

        <listitem>
          <para>Synonym: ci</para>
        </listitem>
      </itemizedlist>

      <para>Use <command>commit</command> when you want to incorporate changes
      from your working source files into the source repository.</para>

      <para>If you don't specify particular files to commit, all of the files
      in your working current directory are examined.
      <command>commit</command> is careful to change in the repository only
      those files that you have really changed. By default (or if you
      explicitly specify the <command>-R</command> option), files in
      subdirectories are also examined and committed if they have changed; you
      can use the <command>-l</command> option to limit
      <command>commit</command> to the current directory only.</para>

      <para><command>commit</command> verifies that the selected files are up
      to date with the current revisions in the source repository; it will
      notify you, and exit without committing, if any of the specified files
      must be made current first with <command>update</command> (<xref
      linkend="update" />). <command>commit</command> does not call the
      <command>update</command> command for you, but rather leaves that for
      you to do when the time is right.</para>

      <para>When all is well, an editor is invoked to allow you to enter a log
      message that will be written to one or more logging programs (<xref
      linkend="modules" />, and <xref linkend="loginfo" />) and placed in the
      rcs file inside the repository. This log message can be retrieved with
      the <command>log</command> command; see <xref linkend="log" />. You can
      specify the log message on the command line with the <command>-m
      <varname>message</varname></command> option, and thus avoid the editor
      invocation, or use the <command>-F <varname>file</varname></command>
      option to specify that the argument file contains the log
      message.</para>

      <sect2 id="commit-options">
        <title>commit options</title>

        <para>These standard options are supported by
        <command>commit</command> (<xref linkend="Common-options" />, for a
        complete description of them):</para>

        <variablelist>
          <varlistentry>
            <term>-D</term>

            <listitem>
              <para>Assume all datestamps are different and send all files to
              the server for checking.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Local; run only in current working directory.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-n</term>

            <listitem>
              <para>Do not run any module program.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-R</term>

            <listitem>
              <para>Commit directories recursively. This is on by
              default.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para><command>commit</command> also supports these options:</para>

        <variablelist>
          <varlistentry>
            <term>-F <varname>file</varname></term>

            <listitem>
              <para>Read the log message from <varname>file</varname>, instead
              of invoking an editor.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>Note that this is not the standard behavior of the
              <command>-f</command> option as defined in <xref
              linkend="Common-options" />.</para>

              <para>Force cvsnt to commit a new revision even if you haven't
              made any changes to the file. If the current revision of
              <varname>file</varname> is 1.7, then the following two commands
              are equivalent:</para>

              <para><screen>$ cvs commit -f <varname>file</varname>
$ cvs commit -r 1.8 <varname>file</varname>
</screen></para>

              <para>The <command>-f</command> option disables recursion (i.e.,
              it implies <command>-l</command>). To force cvsnt to commit a
              new revision for all files in all subdirectories, you must use
              <command>-f -R</command>.</para>

              <para>This command is also used when changing
              <command>-k</command> expansion options. Unless
              <command>-f</command> is specified modified options will not be
              propogated back to the server.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-m <varname>message</varname></term>

            <listitem>
              <para>Use <varname>message</varname> as the log message, instead
              of invoking an editor.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-c</term>

            <listitem>
              <para>Check for a valid edit on the file before committing. See
              'cvs edit'.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-b <varname>bugid</varname></term>

            <listitem>
              <para>Only commit files that have been edited and marked with
              bug <varname>bugid</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-B <varname>bugid</varname></term>

            <listitem>
              <para>Mark committed files as belonging to bug
              <varname>bugid</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-e</term>

            <listitem>
              <para>Keep files edited after commit - supresses the automatic
              unedit that normally follows a commit.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-T</term>

            <listitem>
              <para>Attempt to move branches rather than create branch
              revisions where possible. Where a branch has no revisions, this
              option will compare what you are trying to commit with the
              parent branch head, and if they are identical it will move the
              branch rather than create a new revision.</para>

              <para>This option has detrimental affects on reproducability,
              for example:</para>

              <para>In branch A, a developer is working with files a (version
              1.1) and b (version 1.1.2.1). He merges from HEAD, then commits
              using this option, moving the branch A in file a to version 1.2,
              and committing a new file b version 1.1.2.2</para>

              <para>Meanwhile manager B notices that that branch A is now
              broken, and asks the developer to fix it. The developer knows
              that the revsion 1.1.2.1 file works, so he wants to test with
              the older version. He can't. Since the environment that the
              older file was written in no longer exists (as the branchpoint
              has moved), it's impossible to roll back.</para>

              <para>For this reason it is recommended that this option only be
              used where absolutely necessary, and on unrelated files
              only.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="commit-examples">
        <title>commit examples</title>

        <sect3>
          <title>Committing to a branch</title>

          <para>You can commit to a branch revision (one that has an even
          number of dots) with the <command>-r</command> option. To create a
          branch revision, use the <command>-b</command> option of the
          <command>rtag</command> or <command>tag</command> commands (<xref
          linkend="Branching-and-merging" />). Then, either
          <command>checkout</command> or <command>update</command> can be used
          to base your sources on the newly created branch. From that point
          on, all <command>commit</command> changes made within these working
          sources will be automatically added to a branch revision, thereby
          not disturbing main-line development in any way. For example, if you
          had to create a patch to the 1.2 version of the product, even though
          the 2.0 version is already under development, you might do:</para>

          <para><screen>$ cvs rtag -b -r FCS1_2 FCS1_2_Patch product_module
$ cvs checkout -r FCS1_2_Patch product_module
$ cd product_module
[[ hack away ]]
$ cvs commit
</screen></para>

          <para>This works automatically since the <command>-r</command>
          option is sticky.</para>
        </sect3>

        <sect3>
          <title>Creating the branch after editing</title>

          <para>Say you have been working on some extremely experimental
          software, based on whatever revision you happened to checkout last
          week. If others in your group would like to work on this software
          with you, but without disturbing main-line development, you could
          commit your change to a new branch. Others can then checkout your
          experimental stuff and utilize the full benefit of cvsnt conflict
          resolution. The scenario might look like:</para>

          <para><screen>
[[ hacked sources are present ]]
$ cvs tag -b EXPR1
$ cvs update -r EXPR1
$ cvs commit
</screen></para>

          <para>The <command>update</command> command will make the
          <command>-r EXPR1</command> option sticky on all files. Note that
          your changes to the files will never be removed by the
          <command>update</command> command. The <command>commit</command>
          will automatically commit to the correct branch, because the
          <command>-r</command> is sticky.</para>

          <para>To work with you on the experimental change, others would
          simply do</para>

          <para><screen>
$ cvs checkout -r EXPR1 whatever_module
</screen></para>
        </sect3>
      </sect2>
    </sect1>

    <sect1 id="diff">
      <title>diff--Show differences between revisions</title>

      <para><indexterm>
          <primary>diff</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: diff [-lR] [format_options] [[-r rev1 | -D date1]
          [-r rev2 | -D date2]] [files...]</para>
        </listitem>

        <listitem>
          <para>Requires: working directory, repository.</para>
        </listitem>

        <listitem>
          <para>Changes: nothing.</para>
        </listitem>
      </itemizedlist>

      <para>The <command>diff</command> command is used to compare different
      revisions of files. The default action is to compare your working files
      with the revisions they were based on, and report any differences that
      are found.</para>

      <para>If any file names are given, only those files are compared. If any
      directories are given, all files under them will be compared.</para>

      <para>The exit status for diff is different than for other cvsnt
      commands; for details <xref linkend="Exit-status" />.</para>

      <sect2 id="diff-options">
        <title>diff options</title>

        <para>These standard options are supported by <command>diff</command>
        (<xref linkend="Common-options" />, for a complete description of
        them):</para>

        <variablelist>
          <varlistentry>
            <term>-D <varname>date</varname></term>

            <listitem>
              <para>Use the most recent revision no later than
              <varname>date</varname>. See <command>-r</command> for how this
              affects the comparison.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-k <varname>kflag</varname></term>

            <listitem>
              <para>Process keywords according to <varname>kflag</varname>.
              See <xref linkend="Keyword-substitution" />.</para>

              <para>This option is for use when diffing two repository
              revisions - it will probably not do what you expect when diffing
              against a sandbox file.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Local; run only in current working directory.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-R</term>

            <listitem>
              <para>Examine directories recursively. This option is on by
              default.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r <varname>tag</varname></term>

            <listitem>
              <para>Compare with revision <varname>tag</varname>. Zero, one or
              two <command>-r</command> options can be present. With no
              <command>-r</command> option, the working file will be compared
              with the revision it was based on. With one
              <command>-r</command>, that revision will be compared to your
              current working file. With two <command>-r</command> options
              those two revisions will be compared (and your working file will
              not affect the outcome in any way).</para>

              <para>One or both <command>-r</command> options can be replaced
              by a <command>-D <varname>date</varname></command> option,
              described above.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The following options specify the format of the output. They
        have the same meaning as in GNU diff.</para>

        <para><screen>
-0 -1 -2 -3 -4 -5 -6 -7 -8 -9
--binary
--brief
--changed-group-format=<varname>arg</varname>
-c
  -C <varname>nlines</varname>
  --context[=<varname>lines</varname>]
-e --ed
-t --expand-tabs
-f --forward-ed
--horizon-lines=<varname>arg</varname>
--ifdef=<varname>arg</varname>
-w --ignore-all-space
-B --ignore-blank-lines
-i --ignore-case
-I <varname>regexp</varname>
   --ignore-matching-lines=<varname>regexp</varname>
-h
-b --ignore-space-change
-T --initial-tab
-L <varname>label</varname>
  --label=<varname>label</varname>
--left-column
-d --minimal
-N --new-file
--new-line-format=<varname>arg</varname>
--old-line-format=<varname>arg</varname>
--paginate
-n --rcs
-s --report-identical-files
-p
--show-c-function
-y --side-by-side
-F <varname>regexp</varname>
--show-function-line=<varname>regexp</varname>
-H --speed-large-files
--suppress-common-lines
-a --text
--unchanged-group-format=<varname>arg</varname>
-u
  -U <varname>nlines</varname>
  --unified[=<varname>lines</varname>]
-V <varname>arg</varname>
-W <varname>columns</varname>
  --width=<varname>columns</varname>
</screen></para>
      </sect2>

      <sect2 id="diff-examples">
        <title>diff examples</title>

        <para>The following line produces a Unidiff (<command>-u</command>
        flag) between revision 1.14 and 1.19 of <command>backend.c</command>.
        Due to the <command>-kk</command> flag no keywords are substituted, so
        differences that only depend on keyword substitution are
        ignored.</para>

        <para><screen>$ cvs diff -kk -u -r 1.14 -r 1.19 backend.c
</screen></para>

        <para>Suppose the experimental branch EXPR1 was based on a set of
        files tagged RELEASE_1_0. To see what has happened on that branch, the
        following can be used:</para>

        <para><screen>
$ cvs diff -r RELEASE_1_0 -r EXPR1
</screen></para>

        <para>A command like this can be used to produce a context diff
        between two releases:</para>

        <para><screen>
$ cvs diff -c -r RELEASE_1_0 -r RELEASE_1_1 &gt; diffs
</screen></para>

        <para>If you are maintaining ChangeLogs, a command like the following
        just before you commit your changes may help you write the ChangeLog
        entry. All local modifications that have not yet been committed will
        be printed.</para>

        <para><screen>
$ cvs diff -u | less
</screen></para>
      </sect2>
    </sect1>

    <sect1 id="edit">
      <title>edit--Mark files for editing</title>

      <indexterm>
        <primary>edit</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, sandbox.</para>
          </listitem>

          <listitem>
            <para>Changes: Current directory.</para>
          </listitem>

          <listitem>
            <para>Synonyms:</para>
          </listitem>
        </itemizedlist>This is command is used to mark files for editing in a
      reserved or semi-reserved scenario. When used with bug identifiers it
      also marks which users are currently working on which bugs, and which
      files are affected by those bugs.</para>

      <para>cvs is primarily designed as a cooperative system, as experience
      has shown that this is the most productive way for teams of developers
      to work. The reserved models implemented by this command do not replace
      proper configuration management processes - the correct model to use
      should be decided after due consideration of the advantages and
      disadvantages of each. See also <xref linkend="Watches" /></para>

      <para>The default working model is a cooperative multiple-editors model.
      Any number of people may be editing a file at any time and anyone may
      commit changes. This is very similar to the standard cooperative model
      except that the server keeps track of the editors.</para>

      <para>Using the <command>edit -c</command> option creates a
      semi-reserved or cooperative reserved system. The edit command checks
      that there are no editors before editing the file, however its
      cooperative nature does not prevent other users editing if they wish
      to.</para>

      <para>For a stricter model the <command>-kc</command> and
      <command>-kx</command> expansion options create a mandatory reserved
      system on individual files. Users are prevented from editing or
      committing a file unless they are the only editor of that file.</para>

      <sect2>
        <title>edit options</title>

        <para><variablelist>
            <varlistentry>
              <term>-A</term>

              <listitem>
                <para>Modify filesystem ACL on edited file (Win32 only,
                Experimental).</para>

                <para>In shared sandbox scenarios this command is designed to
                stop other users from being able to modify the edited file -
                it create an access control list that disallows write access
                to anyone but the editor.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-a</term>

              <listitem>
                <para>Specify actions for the temporary watch that is created
                during an edit. This may be one of
                edit,unedit,commit,all,none.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-b bugid</term>

              <listitem>
                <para>Mark the edited file with a bug identifier. This marks
                the editor as not only using the file, but also working on a
                particular bug on that file. Specify multiple -b options for
                multiple bugs.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-c</term>

              <listitem>
                <para>Check that working files are unedited before appying the
                edit.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-f</term>

              <listitem>
                <para>Edit even if working files are already edited by someone
                else (default).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Do not recurse into subdirectories.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-m message</term>

              <listitem>
                <para>Specify a reason for this edit. This message is made
                available as an option to the trigger libraries and notify
                script.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively (default).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-w</term>

              <listitem>
                <para>Edit the whole file, not just the current branch.
                Normally edits only apply to the branch that is current at the
                time of the edit. If you wish to stop anyone changing other
                branches then this option allow this.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-x</term>

              <listitem>
                <para>Exclusive edit. Attempt to stop other users editing the
                file even if they do not use the <command>-c</command>
                option.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-z</term>

              <listitem>
                <para>Edit creates copies of the original files in the
                <filename>CVS/Base</filename> directory. With this option
                those copies are gzip compressed, which saves disk space and
                stops the copies being found by text searches of the
                sandbox.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="editors">
      <title>editors--Find out who is editing a file</title>

      <indexterm>
        <primary>editors</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, sandbox.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms:</para>
          </listitem>
        </itemizedlist>This command queries the server for everyone editing a
      file or group of files. It can also optionally show which bugs are being
      worked on.</para>

      <para>The server only knows the last reported state of each client. In a
      controlled environment this is very likely to be accurate, however it is
      possible to leave edits on the server and not on the client (for example
      my deleting the sandbox without using commit/unedit).</para>

      <para>The normal editors output is as follows:</para>

      <para><screen>components.dir/TEST.xml   tmh   Fri Dec  3 16:15:00 2004 GMT   tucker   c:\temp\repos\components.dir
rep/version_no.h          tmh   Thu Nov  4 17:37:43 2004 GMT   tucker   D:\t\test\rep</screen></para>

      <para>If you list edits for all branches and bug identifiers you get an
      extra columns. The full output is as follows:</para>

      <para><screen>components.dir/TEST.xml   tmh   Fri Dec  3 16:15:00 2004 GMT   tucker   c:\temp\repos\components.dir   3465   HEAD
rep/version_no.h          tmh   Thu Nov  4 17:37:43 2004 GMT   tucker   D:\t\test\rep                         HEAD</screen></para>

      <para>The first output is designed to be compatible with older cvs
      versions that did not support the full cvsnt feature set.</para>

      <sect2>
        <title>editors options</title>

        <para><variablelist>
            <varlistentry>
              <term>-a</term>

              <listitem>
                <para>Show all branches, not just the current branch.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-c</term>

              <listitem>
                <para>Check whether edit on the selected files would actually
                succeed. This can be used by frontends to verify an edit
                without actually performing it.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process this directory only</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively (default).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-v</term>

              <listitem>
                <para>Show active bugs within the output.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="export">
      <title>export--Export sources from CVS, similar to checkout</title>

      <para><indexterm>
          <primary>export</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: export [-flNnR] [-r rev|-D date] [-k subst] [-d dir]
          module...</para>
        </listitem>

        <listitem>
          <para>Requires: repository.</para>
        </listitem>

        <listitem>
          <para>Changes: current directory.</para>
        </listitem>
      </itemizedlist>

      <para>This command is a variant of <command>checkout</command>; use it
      when you want a copy of the source for module without the cvsnt
      administrative directories. For example, you might use
      <command>export</command> to prepare source for shipment off-site. This
      command requires that you specify a date or tag (with
      <command>-D</command> or <command>-r</command>), so that you can count
      on reproducing the source you ship to others (and thus it always prunes
      empty directories).</para>

      <para>One often would like to use <command>-kv</command> with
      <command>cvs export</command>. This causes any keywords to be expanded
      such that an import done at some other site will not lose the keyword
      revision information. But be aware that doesn't handle an export
      containing binary files correctly. Also be aware that after having used
      <command>-kv</command>, one can no longer use the
      <command>ident</command> command (which is part of the rcs suite--see
      ident(1)) which looks for keyword strings. If you want to be able to use
      <command>ident</command> you must not use <command>-kv</command>.</para>

      <sect2 id="export-options">
        <title>export options</title>

        <para>These standard options are supported by
        <command>export</command> (<xref linkend="Common-options" />, for a
        complete description of them):</para>

        <variablelist>
          <varlistentry>
            <term>-D <varname>date</varname></term>

            <listitem>
              <para>Use the most recent revision no later than
              <varname>date</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>If no matching revision is found, retrieve the most recent
              revision (instead of ignoring the file).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Local; run only in current working directory.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-n</term>

            <listitem>
              <para>Do not run any checkout program.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-R</term>

            <listitem>
              <para>Export directories recursively. This is on by
              default.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r <varname>tag</varname></term>

            <listitem>
              <para>Use revision <varname>tag</varname>.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>In addition, these options (that are common to
        <command>checkout</command> and <command>export</command>) are also
        supported:</para>

        <variablelist>
          <varlistentry>
            <term>-d <varname>dir</varname></term>

            <listitem>
              <para>Create a directory called <varname>dir</varname> for the
              working files, instead of using the module name. <xref
              linkend="checkout-options" />, for complete details on how cvsnt
              handles this flag.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-k <varname>subst</varname></term>

            <listitem>
              <para>Set keyword expansion mode (<xref
              linkend="Substitution-modes" />).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-N</term>

            <listitem>
              <para>Only useful together with <command>-d
              <varname>dir</varname></command>. <xref
              linkend="checkout-options" />, for complete details on how cvsnt
              handles this flag.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <sect1 id="history">
      <title>history--Show status of files and users</title>

      <para><indexterm>
          <primary>history</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: history [-report] [-flags] [-options args]
          [files...]</para>
        </listitem>

        <listitem>
          <para>Requires: the file
          <command>$CVSROOT/CVSROOT/history</command></para>
        </listitem>

        <listitem>
          <para>Changes: nothing.</para>
        </listitem>
      </itemizedlist>

      <para>cvsnt can keep a history file that tracks each use of the
      <command>checkout</command>, <command>commit</command>,
      <command>rtag</command>, <command>update</command>, and
      <command>release</command> commands. You can use
      <command>history</command> to display this information in various
      formats.</para>

      <para>Logging must be enabled by creating the file
      <command>$CVSROOT/CVSROOT/history</command>.</para>

      <para><emphasis>Warning:</emphasis> <command>history</command> uses
      <command>-f</command>, <command>-l</command>, <command>-n</command>, and
      <command>-p</command> in ways that conflict with the normal use inside
      cvsnt (<xref linkend="Common-options" />).</para>

      <sect2 id="history-options">
        <title>history options</title>

        <para>Several options (shown above as <command>-report</command>)
        control what kind of report is generated:</para>

        <variablelist>
          <varlistentry>
            <term>-c</term>

            <listitem>
              <para>Report on each time commit was used (i.e., each time the
              repository was modified).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-e</term>

            <listitem>
              <para>Everything (all record types). Equivalent to specifying
              <command>-x</command> with all record types. Of course,
              <command>-e</command> will also include record types which are
              added in a future version of cvsnt; if you are writing a script
              which can only handle certain record types, you'll want to
              specify <command>-x</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-m <varname>module</varname></term>

            <listitem>
              <para>Report on a particular module. (You can meaningfully use
              <command>-m</command> more than once on the command
              line.)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-o</term>

            <listitem>
              <para>Report on checked-out modules. This is the default report
              type.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-T</term>

            <listitem>
              <para>Report on all tags.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-x <varname>type</varname></term>

            <listitem>
              <para>Extract a particular set of record types
              <varname>type</varname> from the cvsnt history. The types are
              indicated by single letters, which you may specify in
              combination.</para>

              <para>Certain commands have a single record type:</para>

              <variablelist>
                <varlistentry>
                  <term>F</term>

                  <listitem>
                    <para>release</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>O</term>

                  <listitem>
                    <para>checkout</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>E</term>

                  <listitem>
                    <para>export</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>T</term>

                  <listitem>
                    <para>rtag</para>
                  </listitem>
                </varlistentry>
              </variablelist>

              <para>One of four record types may result from an update:</para>

              <variablelist>
                <varlistentry>
                  <term>C</term>

                  <listitem>
                    <para>A merge was necessary but collisions were detected
                    (requiring manual merging).</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>G</term>

                  <listitem>
                    <para>A merge was necessary and it succeeded.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>U</term>

                  <listitem>
                    <para>A working file was copied from the
                    repository.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>W</term>

                  <listitem>
                    <para>The working copy of a file was deleted during update
                    (because it was gone from the repository).</para>
                  </listitem>
                </varlistentry>
              </variablelist>

              <para>One of three record types results from commit:</para>

              <variablelist>
                <varlistentry>
                  <term>A</term>

                  <listitem>
                    <para>A file was added for the first time.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>M</term>

                  <listitem>
                    <para>A file was modified.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>R</term>

                  <listitem>
                    <para>A file was removed.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The options shown as <command>-flags</command> constrain or
        expand the report without requiring option arguments:</para>

        <variablelist>
          <varlistentry>
            <term>-a</term>

            <listitem>
              <para>Show data for all users (the default is to show data only
              for the user executing <command>history</command>).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Show last modification only.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-w</term>

            <listitem>
              <para>Show only the records for modifications done from the same
              working directory where <command>history</command> is
              executing.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The options shown as <command>-options
        <varname>args</varname></command> constrain the report based on an
        argument:</para>

        <variablelist>
          <varlistentry>
            <term>-b <varname>str</varname></term>

            <listitem>
              <para>Show data back to a record containing the string
              <varname>str</varname> in either the module name, the file name,
              or the repository path.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-D <varname>date</varname></term>

            <listitem>
              <para>Show data since <varname>date</varname>. This is slightly
              different from the normal use of <command>-D
              <varname>date</varname></command>, which selects the newest
              revision older than <varname>date</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f <varname>file</varname></term>

            <listitem>
              <para>Show data for a particular file (you can specify several
              <command>-f</command> options on the same command line). This is
              equivalent to specifying the file on the command line.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-n <varname>module</varname></term>

            <listitem>
              <para>Show data for a particular module (you can specify several
              <command>-n</command> options on the same command line).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-p <varname>repository</varname></term>

            <listitem>
              <para>Show data for a particular source repository (you can
              specify several <command>-p</command> options on the same
              command line).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r <varname>rev</varname></term>

            <listitem>
              <para>Show records referring to revisions since the revision or
              tag named <varname>rev</varname> appears in individual rcs
              files. Each rcs file is searched for the revision or tag.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t <varname>tag</varname></term>

            <listitem>
              <para>Show records since tag <varname>tag</varname> was last
              added to the history file. This differs from the
              <command>-r</command> flag above in that it reads only the
              history file, not the rcs files, and is much faster.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-u <varname>name</varname></term>

            <listitem>
              <para>Show records for user <varname>name</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-z <varname>timezone</varname></term>

            <listitem>
              <para>Show times in the selected records using the specified
              time zone instead of UTC.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <sect1 id="import">
      <title>import--Import sources into CVS, using vendor branches</title>

      <para><indexterm>
          <primary>import</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: import [-options] repository vendortag
          releasetag...</para>
        </listitem>

        <listitem>
          <para>Requires: Repository, source distribution directory.</para>
        </listitem>

        <listitem>
          <para>Changes: repository.</para>
        </listitem>
      </itemizedlist>

      <para>Use <command>import</command> to incorporate an entire source
      distribution from an outside source (e.g., a source vendor) into your
      source repository directory. You can use this command both for initial
      creation of a repository, and for wholesale updates to the module from
      the outside source. <xref linkend="Tracking-sources" />, for a
      discussion on this subject.</para>

      <para>The <varname>repository</varname> argument gives a directory name
      (or a path to a directory) under the cvsnt root directory for
      repositories; if the directory did not exist, import creates it.</para>

      <para>When you use import for updates to source that has been modified
      in your source repository (since a prior import), it will notify you of
      any files that conflict in the two branches of development; use
      <command>checkout -j</command> to reconcile the differences, as import
      instructs you to do.</para>

      <para>If cvsnt decides a file should be ignored (<xref
      linkend="cvsignore" />), it does not import it and prints <command>I
      </command> followed by the filename (<xref linkend="import-output" />,
      for a complete description of the output).</para>

      <para>If the file <command>$CVSROOT/CVSROOT/cvswrappers</command>
      exists, any file whose names match the specifications in that file will
      be treated as packages and the appropriate filtering will be performed
      on the file/directory before being imported. <xref
      linkend="Wrappers" />.</para>

      <para>The outside source is saved in a first-level branch, by default
      1.1.1. Updates are leaves of this branch; for example, files from the
      first imported collection of source will be revision 1.1.1.1, then files
      from the first imported update will be revision 1.1.1.2, and so
      on.</para>

      <para>At least one argument is required. <varname>repository</varname>
      is needed to identify the collection of source. Normally also two other
      arguments are supplied - <varname>vendortag</varname> is a tag for the
      entire branch (e.g., for 1.1.1). You must also specify at least one
      <varname>releasetag</varname> to identify the files at the leaves
      created each time you execute <command>import</command>.</para>

      <para>Note that by default <command>import</command> does
      <emphasis>not</emphasis> change the directory in which you invoke it. In
      particular, it does not set up that directory as a cvsnt working
      directory. For initial imports the <command>-C</command> option will
      achieve this, but for vendor source imports you need to import them
      first and then check them out into a different directory (<xref
      linkend="Getting-the-source" />).</para>

      <sect2 id="import-options">
        <title>import options</title>

        <para>This standard option is supported by <command>import</command>
        (<xref linkend="Common-options" />, for a complete
        description):</para>

        <variablelist>
          <varlistentry>
            <term>-m <varname>message</varname></term>

            <listitem>
              <para>Use <varname>message</varname> as log information, instead
              of invoking an editor.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>There are the following additional special options.</para>

        <variablelist>
          <varlistentry>
            <term>-b <varname>branch</varname></term>

            <listitem>
              <para>See <xref linkend="Multiple-vendor-branches" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-k <varname>subst</varname></term>

            <listitem>
              <para>Indicate the keyword expansion mode desired. This setting
              will apply to all files created during the import, but not to
              any files that previously existed in the repository. See <xref
              linkend="Substitution-modes" />, for a list of valid
              <command>-k</command> settings.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-I <varname>name</varname></term>

            <listitem>
              <para>Specify file names that should be ignored during import.
              You can use this option repeatedly. To avoid ignoring any files
              at all (even those ignored by default), specify `-I !'.</para>

              <para><varname>name</varname> can be a file name pattern of the
              same type that you can specify in the
              <command>.cvsignore</command> file. <xref
              linkend="cvsignore" />.</para>

              <para>If you specify '-I @' the contents of .cvsigore files are
              ignored for the import.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-W <varname>spec</varname></term>

            <listitem>
              <para>Specify file names that should be filtered during import.
              You can use this option repeatedly. To override all the default
              wrappers specify '-W !'.</para>

              <para><varname>spec</varname> can be a file name pattern of the
              same type that you can specify in the
              <command>.cvswrappers</command> file. <xref
              linkend="Wrappers" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-C</term>

            <listitem>
              <para>Create CVS directories during initial import. This
              provides simplified setup of a sandbox, however as it does not
              contact the server is not suitable for vendor updates - for this
              a proper import/checkout sequence should be used.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-d</term>

            <listitem>
              <para>Use the modification time of the file as the import time
              instead of the current time.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>Overwrite any duplicate release tags within imported
              files.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-n</term>

            <listitem>
              <para>Do not require vendor or release tags. This is used for
              initial imports only, and creates a repository without a vendor
              branch. If you are not planning to use vendor source imports
              then using this option simplifies the import process.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="import-output">
        <title>import output</title>

        <para><command>import</command> keeps you informed of its progress by
        printing a line for each file, preceded by one character indicating
        the status of the file:</para>

        <variablelist>
          <varlistentry>
            <term>U <varname>file</varname></term>

            <listitem>
              <para>The file already exists in the repository and has not been
              locally modified; a new revision has been created (if
              necessary).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>N <varname>file</varname></term>

            <listitem>
              <para>The file is a new file which has been added to the
              repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>C <varname>file</varname></term>

            <listitem>
              <para>The file already exists in the repository but has been
              locally modified; you will have to merge the changes.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>I <varname>file</varname></term>

            <listitem>
              <para>The file is being ignored (<xref
              linkend="cvsignore" />).</para>

              <para><indexterm>
                  <primary>Symbolic link, importing</primary>
                </indexterm><indexterm>
                  <primary>Link, symbolic, importing</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>L <varname>file</varname></term>

            <listitem>
              <para>The file is a symbolic link; <command>cvs import</command>
              ignores symbolic links. People periodically suggest that this
              behavior should be changed, but if there is a consensus on what
              it should be changed to, it doesn't seem to be apparent.
              (Various options in the <command>modules</command> file can be
              used to recreate symbolic links on checkout, update, etc.; <xref
              linkend="modules" />.)</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="import-examples">
        <title>import examples</title>

        <para>See <xref linkend="Tracking-sources" />, and <xref
        linkend="From-files" />.</para>
      </sect2>
    </sect1>

    <sect1 id="init">
      <title>init--Initialise a new repository</title>

      <indexterm>
        <primary>init</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: local access.</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonyms:</para>
          </listitem>
        </itemizedlist>Initialises a new repository for use. This command can
      only be issued locally on the server, not remotely. See also <xref
      linkend="Creating-a-repository" /></para>

      <sect2>
        <title>init options</title>

        <para>Init can be called succesfully without any options.</para>

        <variablelist>
          <varlistentry>
            <term>-a alias</term>

            <listitem>
              <para>Define the repository alias for the new repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-d description</term>

            <listitem>
              <para>Set the repository description</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>Force overwrite of an existing repository. This doesn't
              normally make sense, so be careful with this option.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r repository</term>

            <listitem>
              <para>Remote repository creation. To successfully use this you
              must have an admin account on an existing repository, remote
              init must be initialized on the server, and the server needs the
              access rights to modify its global configuration.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-n</term>

            <listitem>
              <para>Do not attempt repository registration</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-u</term>

            <listitem>
              <para>Unregister an existing repository. For this to succeed
              remotely the same conditions must exist as in -r.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <sect1 id="info">
      <title>info--Get information about the client and server</title>

      <indexterm>
        <primary>info</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: nothing. (Repository required for server
            functions).</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: inf</para>
          </listitem>
        </itemizedlist>Return information about available protocols on the
      client or server. Also list the current cvsignore and cvswrappers
      settings.</para>

      <para>Without any parameters this lists available protocols:</para>

      <para><screen>$ cvs info
Available protocols:

local               (internal)
ext                 ext 2.0.62.1872
fork                fork 2.0.62.1872 
gserver             gserver 2.0.62.1872 (Active Directory)
ntserver            ntserver 2.0.62.1872
pserver             pserver 2.0.62.1872
server              server 2.0.62.1872
ssh                 ssh 2.0.62.1872
sspi                sspi 2.0.62.1872</screen>For information about an
      individual protocol specify the prototocol name on the command
      line.</para>

      <para><screen>$ cvs info pserver
Name:               pserver
Version:            pserver 2.0.62.1872 (Debug)
Syntax:             :pserver[;keyword=value...]:[username[:password]@]host[:port][:]/path
  Username:         Optional
  Password:         Optional
  Hostname:         Required
  Port:             Optional
Client:             Yes
Server:             Yes
Login:              Yes
Encryption:         No
Impersonation:      CVS Builtin

Keywords available:

username            Username (alias: user)
password            Password (alias: pass)
hostname            Hostname (alias: host)
port                Port
proxy               Proxy server
proxyport           Proxy server port (alias: proxy_port)
tunnel              Proxy protocol (aliases: proxyprotocol,proxy_protocol)
proxyuser           Proxy user (alias: proxy_user)
proxypassword       Proxy passsord (alias: proxy_password)</screen>The format
      is designed to be easily parsed by frontends. Its layout does not change
      between cvs versions, however lines may be added or deleted from the
      output.</para>

      <para>Specifying <command>cvswrappers</command> or
      <command>cvsignore</command> dumps out the internal state of these
      files. It is possible to have duplicates, as the list is built up of
      both the client and server contents. When parsed however the client
      always takes precedence over the server setting.</para>

      <sect2>
        <title>info options</title>

        <para><variablelist>
            <varlistentry>
              <term>-c</term>

              <listitem>
                <para>Return client-side information. Returns all protocols
                available to the client</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-s</term>

              <listitem>
                <para>Return server-side information. Returns protocols that a
                client can use to communicate with the server. This does not
                include local or external protocols.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-b</term>

              <listitem>
                <para>(Where supported) list available cvsnt servers on the
                local network. This currently requires mdns support on the
                client.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r server</term>

              <listitem>
                <para>Find out as much as possible about a remote cvsnt
                server. For this command to succeed the remote server must
                support the cvsnt enumeration protocol.</para>

                <para><screen>$ cvs info -r cvs.cvsnt.org
Server: CVSNT Public Repository
Version: Concurrent Versions System (CVSNT) 2.5.01 (Travis) Build 2010

Protocols:
  gserver
  pserver
  sserver
  sspi

Repositories:
  /usr/local/cvs                CVSNT Main repository

Anonymous username: cvs
Anonymous protocol: pserver
Default repository: /usr/local/cvs

Anonymous login: :pserver:cvs@cvs.cvsnt.org:/usr/local/cvs
Recommended login: :sspi:cvs.cvsnt.org:/usr/local/cvs</screen>The layout will
                remain the same as much as possible in future revisions to
                facilitate automatic parsing. Parsers should ignore elements
                that they do not understand.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="log">
      <title>log--Print out log information for files</title>

      <para><indexterm>
          <primary>log</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: log [options] [files...]</para>
        </listitem>

        <listitem>
          <para>Requires: repository, working directory.</para>
        </listitem>

        <listitem>
          <para>Changes: nothing.</para>
        </listitem>
      </itemizedlist>

      <para>Display log information for files. <command>log</command> used to
      call the rcs utility <command>rlog</command>. Although this is no longer
      true in the current sources, this history determines the format of the
      output and the options, which are not quite in the style of the other
      cvsnt commands.</para>

      <para><indexterm>
          <primary>Timezone, in output</primary>
        </indexterm><indexterm>
          <primary>Zone, time, in output</primary>
        </indexterm>The output includes the location of the rcs file, the
      <firstterm>head</firstterm> revision (the latest revision on the trunk),
      all symbolic names (tags) and some other things. For each revision, the
      revision number, the author, the number of lines added/deleted and the
      log message are printed. All times are displayed in Coordinated
      Universal Time (UTC). (Other parts of cvsnt print times in the local
      timezone).</para>

      <para><emphasis>Warning:</emphasis> <command>log</command> uses
      <command>-R</command> in a way that conflicts with the normal use inside
      cvsnt (<xref linkend="Common-options" />).</para>

      <sect2 id="log-options">
        <title>log options</title>

        <para>By default, <command>log</command> prints all information that
        is available. All other options restrict the output.</para>

        <variablelist>
          <varlistentry>
            <term>-B bugid</term>

            <listitem>
              <para>Only select revisions which are related to a single
              bug.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-b</term>

            <listitem>
              <para>Print information about the revisions on the default
              branch, normally the highest branch on the trunk.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-d <varname>dates</varname></term>

            <listitem>
              <para>Print information about revisions with a checkin date/time
              in the range given by the semicolon-separated list of dates. The
              date formats accepted are those accepted by the
              <command>-D</command> option to many other cvsnt commands (<xref
              linkend="Common-options" />). Dates can be combined into ranges
              as follows:</para>

              <variablelist>
                <varlistentry>
                  <term><varname>d1</varname>&lt;<varname>d2</varname></term>

                  <term><varname>d2</varname>&gt;<varname>d1</varname></term>

                  <listitem>
                    <para>Select the revisions that were deposited between
                    <varname>d1</varname> and <varname>d2</varname>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>&lt;<varname>d</varname></term>

                  <term><varname>d</varname>&gt;</term>

                  <listitem>
                    <para>Select all revisions dated <varname>d</varname> or
                    earlier.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>d</varname>&lt;</term>

                  <term>&gt;<varname>d</varname></term>

                  <listitem>
                    <para>Select all revisions dated <varname>d</varname> or
                    later.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>d</varname></term>

                  <listitem>
                    <para>Select the single, latest revision dated
                    <varname>d</varname> or earlier.</para>
                  </listitem>
                </varlistentry>
              </variablelist>

              <para>The <command>&gt;</command> or <command>&lt;</command>
              characters may be followed by <command>=</command> to indicate
              an inclusive range rather than an exclusive one.</para>

              <para>Note that the separator is a semicolon (;).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-h</term>

            <listitem>
              <para>Print only the name of the rcs file, name of the file in
              the working directory, head, default branch, access list, locks,
              symbolic names, and suffix.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Local; run only in current working directory. (Default is
              to run recursively).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-N</term>

            <listitem>
              <para>Do not print the list of tags for this file. This option
              can be very useful when your site uses a lot of tags, so rather
              than "more"'ing over 3 pages of tag information, the log
              information is presented without tags at all.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-R</term>

            <listitem>
              <para>Print only the name of the rcs file.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r<varname>revisions</varname></term>

            <listitem>
              <para>Print information about revisions given in the
              comma-separated list <varname>revisions</varname> of revisions
              and ranges. The following table explains the available range
              formats:</para>

              <variablelist>
                <varlistentry>
                  <term><varname>rev1</varname>:<varname>rev2</varname></term>

                  <listitem>
                    <para>Revisions <varname>rev1</varname> to
                    <varname>rev2</varname> (which must be on the same
                    branch).</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>rev1</varname>::<varname>rev2</varname></term>

                  <listitem>
                    <para>Revisions between, but not including,
                    <varname>rev1</varname> and
                    <varname>rev2</varname>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>:<varname>rev</varname></term>

                  <listitem>
                    <para>Revisions from the beginning of the branch up to and
                    including <varname>rev</varname>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>::<varname>rev</varname></term>

                  <listitem>
                    <para>Revisions from the beginning of the branch up to,
                    but not including, <varname>rev</varname>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>rev</varname>:</term>

                  <listitem>
                    <para>Revisions starting with <varname>rev</varname> to
                    the end of the branch containing
                    <varname>rev</varname>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>rev</varname>::</term>

                  <listitem>
                    <para>Revisions starting just after <varname>rev</varname>
                    to the end of the branch containing
                    <varname>rev</varname>.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>branch</varname></term>

                  <listitem>
                    <para>An argument that is a branch means all revisions on
                    that branch.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>branch1</varname>:<varname>branch2</varname></term>

                  <term><varname>branch1</varname>::<varname>branch2</varname></term>

                  <listitem>
                    <para>A range of branches means all revisions on the
                    branches in that range.</para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><varname>branch</varname>.</term>

                  <listitem>
                    <para>The latest revision in
                    <varname>branch</varname>.</para>
                  </listitem>
                </varlistentry>
              </variablelist>

              <para>A bare <command>-r</command> with no revisions means the
              latest revision on the default branch, normally the trunk. There
              can be no space between the <command>-r</command> option and its
              argument.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-S</term>

            <listitem>
              <para>Supress log output when no revisions are selected within a
              file.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-s <varname>states</varname></term>

            <listitem>
              <para>Print information about revisions whose state attributes
              match one of the states given in the comma-separated list
              <varname>states</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-T</term>

            <listitem>
              <para>Display dates and times in the log output in Local time
              rather than GMT.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t</term>

            <listitem>
              <para>Print the same as <command>-h</command>, plus the
              descriptive text.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-w<varname>[logins]</varname></term>

            <listitem>
              <para>Print information about revisions checked in by users with
              login names appearing in the comma-separated list
              <varname>logins</varname>. If <varname>logins</varname> is
              omitted, the user's login is assumed. There can be no space
              between the <command>-w</command> option and its
              argument.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-X</term>

            <listitem>
              <para>Supress extended information generated only by CVSNT
              servers. This can be useful with some frontends that cannot
              parse the extra output.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-x</term>

            <listitem>
              <para>Generate full output. This is the default unless
              configured otherwise on the server.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para><command>log</command> prints the intersection of the revisions
        selected with the options <command>-B</command>,<command>-d</command>,
        <command>-s</command>, and <command>-w</command>, intersected with the
        union of the revisions selected by <command>-b</command> and
        <command>-r</command>.</para>
      </sect2>

      <sect2 id="log-examples">
        <title>log examples</title>

        <para>Contributed examples are gratefully accepted.</para>
      </sect2>
    </sect1>

    <sect1 id="login">
      <title>login--Cache a client password locally</title>

      <indexterm>
        <primary>login</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository.</para>
          </listitem>

          <listitem>
            <para>Changes: local password cache.</para>
          </listitem>

          <listitem>
            <para>Synonyms: logon, lgn</para>
          </listitem>
        </itemizedlist>Cache the password required for the client locally. Not
      all protocols require this, and some do not even support it. If you are
      using a protocol that does not require this then for security reasons it
      is better not to use it, since the local cache is relatively easy to
      find and decrypt if your local account/machine is compromised.</para>

      <para>Do not make any assumptions about the storage of passwords in the
      local cache. In particular do not attempt to manipulate it manually -
      its format may change without warning.</para>

      <para>See also <xref linkend="Remote-repositories" /></para>

      <sect2>
        <title>login options</title>

        <para><variablelist>
            <varlistentry>
              <term>-p password</term>

              <listitem>
                <para>Specify the password to use (the default is to
                prompt).</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="logout">
      <title>logout--Remove the cached entry for a password</title>

      <indexterm>
        <primary>logout</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository.</para>
          </listitem>

          <listitem>
            <para>Changes: local password cache.</para>
          </listitem>

          <listitem>
            <para>Synonyms:</para>
          </listitem>
        </itemizedlist>Destroy the password cache entry for the current
      connection. See also <xref linkend="login" /></para>

      <sect2>
        <title>logout options</title>

        <para>none.</para>
      </sect2>
    </sect1>

    <sect1 id="ls">
      <title>ls--list modules, files and directories in the repository</title>

      <indexterm>
        <primary>ls</primary>
      </indexterm>

      <indexterm>
        <primary>rls</primary>
      </indexterm>

      <itemizedlist>
        <listitem>
          <para>Requires: repository.</para>
        </listitem>

        <listitem>
          <para>Changes: nothing.</para>
        </listitem>

        <listitem>
          <para>Synonyms: dir,list,rls</para>
        </listitem>
      </itemizedlist>

      <para>Lists the contents of the repository, and optionally the latest
      version information from files within the repository.</para>

      <para>Used without any parameters, it lists the toplevel directories
      (modules) in the repository. This includes directories created using the
      <command>modules2</command> file.</para>

      <para>The list is followed by the contents of the
      <command>modules</command> file, if available.</para>

      <sect2>
        <title>ls options</title>

        <para><variablelist>
            <varlistentry>
              <term>-D date</term>

              <listitem>
                <para>Show files current on a particular date.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-e</term>

              <listitem>
                <para>Display in CVS/Entries format:<screen>$ cvs ls -e CVSROOT
Listing module: CVSROOT

/checkoutlist/1.9/Wed Jan 26 19:08:06 2005/-kkv/
/commitinfo/1.10/Tue Jan 11 01:25:34 2005/-kkv/
/config/1.15/Sun Jan 23 02:15:57 2005/-kkv/</screen></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Display all details. Note that the usage of the -l
                option differs from other cvs commands. This is for
                consistency with the unix-style ls command.<screen>$ cvs ls -l CVSROOT
Listing module: CVSROOT

checkoutlist                    1.9     Wed Jan 26 19:08:06 2005 -kkv
commitinfo                      1.10    Tue Jan 11 01:25:34 2005 -kkv
config                          1.15    Sun Jan 23 02:15:57 2005 -kkv</screen></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-P</term>

              <listitem>
                <para>Ignore (Prune) empty directories.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-q</term>

              <listitem>
                <para>Quieter output. Do not print extraneous human-readable
                prompts.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Recurse into subdirectories.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r tag</term>

              <listitem>
                <para>Show files with the specified revision, tag or
                branch.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-T</term>

              <listitem>
                <para>Show timestamps in local time instead of GMT.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="lsacl">
      <title>lsacl--Show file/directory permissions</title>

      <para><indexterm>
          <primary>lsacl</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Requires: repository, sandbox.</para>
        </listitem>

        <listitem>
          <para>Changes: nothing.</para>
        </listitem>

        <listitem>
          <para>Synonyms: lsattr,listperm</para>
        </listitem>
      </itemizedlist>

      <para>List the access control lists entries for files and directories
      within the current sandbox. For directories also shows the owner.</para>

      <para>Permissions on a file or directory are also supplemented by parent
      directories, so the lack of mention of a user does not imply or deny
      access. For compatibility with older cvs versions the default is to
      grant permissions unless explicitly denied. This can be changed by
      putting an inheritable default deny permission in the repository
      root.</para>

      <sect2>
        <title>lsacl options</title>

        <para><variablelist>
            <varlistentry>
              <term>-d</term>

              <listitem>
                <para>List only directories, not files. By default both file
                and directory permisisons are listed in the output.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Recursively list permissions in all
                subdirectories.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="rlsacl">
      <title>rlsacl--Show remote file/directory permissions</title>

      <indexterm>
        <primary>rlsacl</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: rlsattr,rlistperm</para>
          </listitem>
        </itemizedlist>List permissions remotely, without reference to a local
      sandbox. See <xref linkend="lsacl" /></para>
    </sect1>

    <sect1 id="passwd">
      <title>passwd--Modify a user's password or create a user</title>

      <para><indexterm>
          <primary>passwd</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Requires: repository.</para>
        </listitem>

        <listitem>
          <para>Changes: remote password file.</para>
        </listitem>

        <listitem>
          <para>Synonyms: password, setpass.</para>
        </listitem>
      </itemizedlist>

      <para>Change the username/password information for a user. This command
      is only useful for those protocols which do not use system passwords
      (such as pserver). It does not affect the real system password of the
      user.</para>

      <para>Ordninary users are only able to change their own cvs password.
      Repository administrators can use the full funcitonality of this
      command.</para>

      <para>If invoked without a username, the current username is used. If
      invoked with a username, the repository administrator can change the
      details of another user.</para>

      <sect2>
        <title>passwd options</title>

        <para><variablelist>
            <varlistentry>
              <term>-a</term>

              <listitem>
                <para>Add user. Adds a new user entry to the password
                file.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-x</term>

              <listitem>
                <para>Disable user. Changes the password so that the user
                cannot log in.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-X</term>

              <listitem>
                <para>Delete user. Remove the user entry from the password
                file.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r user</term>

              <listitem>
                <para>Alias username to real system user. Before a virtual
                (pserver) user can log in the system needs to know which user
                account to use for that user.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Remove system alias for user.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-D domain</term>

              <listitem>
                <para>(Win32 only) Use the users' domain password instead of a
                separate password. For security reasons this is not
                recommended.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="rannotate">
      <title>rannotate--Show who made changes to remote files<indexterm>
          <primary>rannotate</primary>
        </indexterm></title>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: rann, ra</para>
          </listitem>
        </itemizedlist>Show changes on remote files within a repository. Does
      not require a sandbox. See also <xref linkend="annotate" /></para>
    </sect1>

    <sect1 id="rchacl">
      <title>rchacl--Change remote access control lists</title>

      <indexterm>
        <primary>rchacl</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository.</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonyms: rsetacl, rsetperm</para>
          </listitem>
        </itemizedlist>Change an access control list on a remote file or
      directory. Does not require a sandbox. See also <xref
      linkend="chacl" /></para>
    </sect1>

    <sect1 id="rchown">
      <title>rchown--Change owner of a remote directory</title>

      <indexterm>
        <primary>rchown</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository.</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonyms: rsetowner</para>
          </listitem>
        </itemizedlist>Change the owner of a remote directory. Does not
      require a sandbox. See also <xref linkend="chown" /></para>
    </sect1>

    <sect1 id="rdiff">
      <title>rdiff--'patch' format diffs between releases</title>

      <para><indexterm>
          <primary>rdiff</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>rdiff [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]]
          modules...</para>
        </listitem>

        <listitem>
          <para>Requires: repository.</para>
        </listitem>

        <listitem>
          <para>Changes: nothing.</para>
        </listitem>

        <listitem>
          <para>Synonyms: patch, pa</para>
        </listitem>
      </itemizedlist>

      <para>Builds a Larry Wall format patch(1) file between two releases,
      that can be fed directly into the <command>patch</command> program to
      bring an old release up-to-date with the new release. (This is one of
      the few cvsnt commands that operates directly from the repository, and
      doesn't require a prior checkout.) The diff output is sent to the
      standard output device.</para>

      <para>You can specify (using the standard <command>-r</command> and
      <command>-D</command> options) any combination of one or two revisions
      or dates. If only one revision or date is specified, the patch file
      reflects differences between that revision or date and the current head
      revisions in the rcs file.</para>

      <para>Note that if the software release affected is contained in more
      than one directory, then it may be necessary to specify the
      <command>-p</command> option to the <command>patch</command> command
      when patching the old sources, so that <command>patch</command> is able
      to find the files that are located in other directories.</para>

      <sect2 id="rdiff-options">
        <title>rdiff options</title>

        <para>These standard options are supported by <command>rdiff</command>
        (<xref linkend="Common-options" />, for a complete description of
        them):</para>

        <variablelist>
          <varlistentry>
            <term>-D <varname>date</varname></term>

            <listitem>
              <para>Use the most recent revision no later than
              <varname>date</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>If no matching revision is found, retrieve the most recent
              revision (instead of ignoring the file).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Local; don't descend subdirectories.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-R</term>

            <listitem>
              <para>Examine directories recursively. This option is on by
              default.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r <varname>tag</varname></term>

            <listitem>
              <para>Use revision <varname>tag</varname>.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>In addition to the above, these options are available:</para>

        <variablelist>
          <varlistentry>
            <term>-c</term>

            <listitem>
              <para>Use the context diff format. This is the default
              format.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-s</term>

            <listitem>
              <para>Create a summary change report instead of a patch. The
              summary includes information about files that were changed or
              added between the releases. It is sent to the standard output
              device. This is useful for finding out, for example, which files
              have changed between two dates or revisions.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t</term>

            <listitem>
              <para>A diff of the top two revisions is sent to the standard
              output device. This is most useful for seeing what the last
              change to a file was.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-u</term>

            <listitem>
              <para>Use the unidiff format for the context diffs. Remember
              that old versions of the <command>patch</command> program can't
              handle the unidiff format, so if you plan to post this patch to
              the net you should probably not use
              <command>-u</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-V <varname>vn</varname></term>

            <listitem>
              <para>Expand keywords according to the rules current in rcs
              version <varname>vn</varname> (the expansion format changed with
              rcs version 5). Note that this option is no longer accepted.
              cvsnt will always expand keywords the way that rcs version 5
              does.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="rdiff-examples">
        <title>rdiff examples</title>

        <para>Suppose you receive mail from
        <wordasword>foo@example.net</wordasword> asking for an update from
        release 1.2 to 1.4 of the tc compiler. You have no such patches on
        hand, but with cvsnt that can easily be fixed with a command such as
        this:</para>

        <para><screen>$ cvs rdiff -c -r FOO1_2 -r FOO1_4 tc | \
$$ Mail -s 'The patches you asked for' foo@example.net
</screen></para>

        <para>Suppose you have made release 1.3, and forked a branch called
        <command>R_1_3fix</command> for bugfixes. <command>R_1_3_1</command>
        corresponds to release 1.3.1, which was made some time ago. Now, you
        want to see how much development has been done on the branch. This
        command can be used:</para>

        <para><screen>
$ cvs patch -s -r R_1_3_1 -r R_1_3fix module-name
cvs rdiff: Diffing module-name
File ChangeLog,v changed from revision 1.52.2.5 to 1.52.2.6
File foo.c,v changed from revision 1.52.2.3 to 1.52.2.4
File bar.h,v changed from revision 1.29.2.1 to 1.2
</screen></para>
      </sect2>
    </sect1>

    <sect1 id="release">
      <title>release--Indicate that a Module is no longer in use</title>

      <para><indexterm>
          <primary>release</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>release [-d [-f]] [-e] [-y] directories...</para>
        </listitem>

        <listitem>
          <para>Requires: Working directory.</para>
        </listitem>

        <listitem>
          <para>Changes: Working directory, history log.</para>
        </listitem>

        <listitem>
          <para>Synonyms: re, rel</para>
        </listitem>
      </itemizedlist>

      <para>This command is meant to safely cancel the effect of <command>cvs
      checkout</command>. Since cvsnt doesn't lock files, it isn't strictly
      necessary to use this command. You can always simply delete your working
      directory, if you like; but you risk losing changes you may have
      forgotten, and you leave no trace in the cvsnt history file (<xref
      linkend="history-file" />) that you've abandoned your checkout.</para>

      <para>Use <command>cvs release</command> to avoid these problems. This
      command checks that no uncommitted changes are present; that you are
      executing it from immediately above a cvsnt working directory; and that
      the repository recorded for your files is the same as the repository
      defined in the module database.</para>

      <para>If all these conditions are true, <command>cvs release</command>
      leaves a record of its execution (attesting to your intentionally
      abandoning your checkout) in the cvsnt history log.</para>

      <sect2 id="release-options">
        <title>release options</title>

        <para>The <command>release</command> command supports the following
        command options:</para>

        <variablelist>
          <varlistentry>
            <term>-d</term>

            <listitem>
              <para>Delete your working copy of the file if the release
              succeeds. If this flag is not given your files will remain in
              your working directory.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>Must be specified with -f, above. Force the the deletion
              of the directory even if non-cvs files are present.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-e</term>

            <listitem>
              <para>Don't delete any files, just delete the cvsnt
              administrative directories. The directory is then left in a
              state as if it had just been <command>export</command>ed.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-y</term>

            <listitem>
              <para>Automatically assume 'yes' to any confirmation
              prompts.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="release-output">
        <title>release output</title>

        <para>Before <command>release</command> releases your sources it will
        print a one-line message if any file that is not up-to-date.</para>
      </sect2>

      <sect2 id="release-examples">
        <title>release examples</title>

        <para>Release the <command>tc</command> directory, and delete your
        local working copy of the files.</para>

        <para><screen>$ cd ..         # You must stand immediately above the
                # sources when you issue <command>cvs release</command>.
$ cvs release -d tc
You have [5] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': y
$
</screen></para>
      </sect2>
    </sect1>

    <sect1 id="remove">
      <title>remove--Remove files from the working directory</title>

      <indexterm>
        <primary>remove</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: working directory, repository.</para>
          </listitem>

          <listitem>
            <para>Changes: working directory.</para>
          </listitem>

          <listitem>
            <para>Synonyms: rm, delete</para>
          </listitem>
        </itemizedlist>Remove a file from the working directory, marking the
      file as 'dead' which comes into effect after the next commit.</para>

      <para>Files are never actually removed from the repository, only ever
      flagged as deleted. You can recover such a removed file by using a
      combinaiton of add and commit. See also <xref
      linkend="Removing-files" /></para>

      <para>As a safety measure this command will not do anything unless the
      physical file is already deleted or you use the -f option.</para>

      <sect2>
        <title>remove options</title>

        <para><variablelist>
            <varlistentry>
              <term>-f</term>

              <listitem>
                <para>Delete the physical file as well. Remove will not
                complete unless the file has already been deleted or this
                option is given.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process this directory only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="rename">
      <title>rename--Rename files in the repository</title>

      <para><indexterm>
          <primary>rename</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Synopsis: rename [-q] source target</para>
        </listitem>

        <listitem>
          <para>Requires: working directory, repository.</para>
        </listitem>

        <listitem>
          <para>Changes: repository.</para>
        </listitem>

        <listitem>
          <para>Synonyms: ren,mv</para>
        </listitem>
      </itemizedlist>

      <para>Use the <command>rename</command> to rename or move a file within
      the sandbox, whilst keeping the history intact.</para>

      <para>Rename is currently experimental.</para>

      <para>Rename information is held at the directory level, so the
      rename/move is not committed to the repository until <command>cvs
      commit</command> is called on the directory containing the file.</para>

      <para>If another user has the file checked out they will continue to use
      the file under its old name until they issue a <command>cvs
      update</command> at the directory level. CVSNT has no problems with this
      and both users can continue to merge each others' changes.</para>
    </sect1>

    <sect1 id="rlog">
      <title>rlog--Return log history of remote file</title>

      <indexterm>
        <primary>rlog</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: rl</para>
          </listitem>
        </itemizedlist>Return the log history of a remote file or group of
      files. Does not require a sandbox. See <xref linkend="log" /></para>
    </sect1>

    <sect1 id="rtag">
      <title>rtag--Mark a single revision over multiple files</title>

      <indexterm>
        <primary>rtag</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: rfreeze</para>
          </listitem>
        </itemizedlist>Set a tag on a group of files in a repository. Does not
      require a sandbox. See <xref linkend="tag" />, also <xref
      linkend="Tags" /></para>
    </sect1>

    <sect1 id="status">
      <title>status--Display the state of a file in the working
      directory</title>

      <indexterm>
        <primary>status</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: st,stat</para>
          </listitem>
        </itemizedlist>Display the status of a file within the working
      directory. This includes any expansion options, its version, and whether
      it is modified or may require updating.</para>

      <para>The normal output from the status command is as follows:<screen>$ cvs status cvs.dbk
===================================================================
File: cvs.dbk           Status: Up-to-date

   Working revision:    1.1.2.36
   Repository revision: 1.1.2.36        /usr/local/cvs/cvsnt/doc/cvs.dbk,v
   Expansion option:    o
   Commit Identifier:   75a042064840566c
   Sticky Tag:          CVSNT_2_0_x (branch: 1.1.2)
   Sticky Date:         (none)
   Sticky Options:      -ko
   Merge From:          (none)</screen></para>

      <para>The layout of this output will remain the same across versions,
      although information may be added or removed.</para>

      <para>A more terse form of status is produced by using the -q option, in
      which case only the checkout status is displayed:<screen>$ cvs status -q cvs.dbk
File: cvs.dbk           Status: Up-to-date</screen></para>

      <sect2>
        <title>status options</title>

        <para><variablelist>
            <varlistentry>
              <term>-v</term>

              <listitem>
                <para>Verbose format. Append the tag information for each
                selected file.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process this directory only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-q</term>

              <listitem>
                <para>Display only a quick summary of the status of each file.
                Specifying a second <command>-q</command> option reduces the
                output still further, by supressing output for up to date
                files.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-X</term>

              <listitem>
                <para>Display shorter output produced by cvs 1.x. This output
                may be required for parsing with older tools.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-x</term>

              <listitem>
                <para>Display full cvsnt status details. Default, unless
                overridden on the server.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="tag">
      <title>tag--Create a tag or branch</title>

      <indexterm>
        <primary>tag</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonyms: ta,freeze</para>
          </listitem>
        </itemizedlist>Create or modify a tag in the repository.</para>

      <para>A tag is a snapshot of a single moment in time in the repository.
      Normally a tag would be applied to entire directories, although it is
      possible to tag individual files if required. See also <xref
      linkend="Tags" /></para>

      <para>A branch is a unit of parallel development, which may or may not
      be kepy in sync with the main trunk. See also <xref
      linkend="Branching-and-merging" /></para>

      <para>Creating a tag or branch does not change the working directory. To
      create and work with a branch it is also necessary to use the cvs update
      command to move your working directory onto that branch.</para>

      <sect2>
        <title>tag options</title>

        <para><variablelist>
            <varlistentry>
              <term>-A</term>

              <listitem>
                <para>Make an alias of an existing branch (requires -r). See
                <xref linkend="Alias-Tags" /></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-b</term>

              <listitem>
                <para>Make a branch tag.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-c</term>

              <listitem>
                <para>Check that the working files are unmodified before
                tagging.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-d</term>

              <listitem>
                <para>Delete the named tag. Deletion of branches is not
                recommended.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-F</term>

              <listitem>
                <para>Move the tag if it already exists. Not recommended for
                branches.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-B</term>

              <listitem>
                <para>Allow <command>-d</command> and <command>-F</command> to
                be applied to branch tags. Use of this option is not
                recommended as it does not affect the revisions within the
                branch and can result in them being orphaned.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-f</term>

              <listitem>
                <para>Force a head revision match if the existing branch is
                not found.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process local directory only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-M</term>

              <listitem>
                <para>Create a floating, or 'magic' branch. A floating branch
                always points to the head of its parent branch, unless a
                revision is checked into it. Once a revision is added it
                becomes a normal fixed branch.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r rev</term>

              <listitem>
                <para>Select files based on existing
                tag/branch/revision.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-D date</term>

              <listitem>
                <para>Select files current on a specific date.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="unedit">
      <title>unedit--Mark edit as finished without committing</title>

      <indexterm>
        <primary>unedit</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: working directory.</para>
          </listitem>

          <listitem>
            <para>Synonyms:</para>
          </listitem>
        </itemizedlist>Discard any changes made and finish editing a file
      without committing. It may also be necessary to run an
      <command>update</command> command to retrieve the latest version of the
      file.</para>

      <para>Unediting also sends out a notification to other users if the
      server is configured to do this. It will mark the working directory file
      as read only. See also <xref linkend="Watches" /></para>

      <sect2>
        <title>unedit options</title>

        <para><variablelist>
            <varlistentry>
              <term>-b bugid</term>

              <listitem>
                <para>Unedit only files marked as edited with
                <command>bugid</command>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process local directory only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-m message</term>

              <listitem>
                <para>Specify the reason for this unedit. The message is sent
                to the <command>trigger</command> and
                <command>notify</command> programs on the server.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r</term>

              <listitem>
                <para>Revert file only. Do not perform unedit. This merely
                copies the unedited copy back onto the working copy.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-u username</term>

              <listitem>
                <para>(repository administrators only) perform an unedit for
                another user.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-w</term>

              <listitem>
                <para>Leave working directory file writable after the
                unedit.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="update">
      <title>update--Bring work tree in sync with repository</title>

      <para><indexterm>
          <primary>update</primary>
        </indexterm></para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>Requires: repository, working directory.</para>
        </listitem>

        <listitem>
          <para>Changes: working directory.</para>
        </listitem>

        <listitem>
          <para>Synonyms: up,upd</para>
        </listitem>
      </itemizedlist>

      <para>After you've run checkout to create your private copy of source
      from the common repository, other developers will continue changing the
      central source. From time to time, when it is convenient in your
      development process, you can use the <command>update</command> command
      from within your working directory to reconcile your work with any
      revisions applied to the source repository since your last checkout or
      update.</para>

      <para>It is unwise to let your local working directory become out of
      sync with others for too long. Depending on your working model it may be
      necessary to run updates daily or even hourly to keep in step. On the
      other hand if you are the only developer on a project it may not be
      necessary to update at all.</para>

      <para>If updating is left too long, then conflicts that arise get
      progressively harder to fix over time as the code diverges. On the other
      hand frequent updating may mean that there are no conflicts to deal with
      at all.</para>

      <sect2 id="update-options">
        <title>update options</title>

        <para>These standard options are available with
        <command>update</command> (<xref linkend="Common-options" />, for a
        complete description of them):</para>

        <variablelist>
          <varlistentry>
            <term>-D date</term>

            <listitem>
              <para>Use the most recent revision no later than
              <varname>date</varname>. This option is sticky, and implies
              <command>-P</command>. See <xref linkend="Sticky-tags" />, for
              more information on sticky tags/dates.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-f</term>

            <listitem>
              <para>Only useful with the <command>-D
              <varname>date</varname></command> or <command>-r
              <varname>tag</varname></command> flags. If no matching revision
              is found, retrieve the most recent revision (instead of ignoring
              the file).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-k <varname>kflag</varname></term>

            <listitem>
              <para>Process keywords according to <varname>kflag</varname>.
              See <xref linkend="Keyword-substitution" />. This option is
              sticky; future updates of this file in this working directory
              will use the same <varname>kflag</varname>. The
              <command>status</command> command can be viewed to see the
              sticky options. See <xref linkend="status" />, for more
              information on the <command>status</command> command.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-l</term>

            <listitem>
              <para>Local; run only in current working directory. <xref
              linkend="Recursive-behavior" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-P</term>

            <listitem>
              <para>Prune empty directories. See <xref
              linkend="Moving-directories" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-p</term>

            <listitem>
              <para>Pipe files to the standard output.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-R</term>

            <listitem>
              <para>Update directories recursively (default). <xref
              linkend="Recursive-behavior" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-r rev</term>

            <listitem>
              <para>Retrieve revision/tag <varname>rev</varname>. This option
              is sticky, and implies <command>-P</command>. See <xref
              linkend="Sticky-tags" />, for more information on sticky
              tags/dates.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>These special options are also available with
        <command>update</command>.</para>

        <variablelist>
          <varlistentry>
            <term>-3</term>

            <listitem>
              <para>Provide 3-way conflicts.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-A</term>

            <listitem>
              <para>Reset any sticky tags, dates, or <command>-k</command>
              options. See <xref linkend="Sticky-tags" />, for more
              information on sticky tags/dates.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-B bugid</term>

            <listitem>
              <para>Set the boundary of a -j merge to revisions marked with a
              particular bug. This is used to extract individual bug fixes
              from one branch to another.</para>

              <para>If there are other revisions unrelated to the bug required
              to merge all the differences, these will also be merged. This
              option is much more useful in quiet or controlled repositories
              where this happens infrequently.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-b</term>

            <listitem>
              <para>Perform the <command>-j</command> merge from the
              branchpoint, ignoring mergepoints.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-C</term>

            <listitem>
              <para>Overwrite locally modified files with clean copies from
              the repository (the modified file is saved in
              <command>.#<varname>file</varname>.<varname>revision</varname></command>,
              however).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-c</term>

            <listitem>
              <para>If the file is edited, update the base revision copy to
              the latest revision. If this option is not used an unedit will
              always revert to the same revision that is edited, not the
              latest revision in the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-d</term>

            <listitem>
              <para>Create any directories that exist in the repository if
              they're missing from the working directory. Normally,
              <command>update</command> acts only on directories and files
              that were already enrolled in your working directory.</para>

              <para>This is useful for updating directories that were created
              in the repository since the initial checkout; but it has an
              unfortunate side effect. If you deliberately avoided certain
              directories in the repository when you created your working
              directory (either through use of a module name or by listing
              explicitly the files and directories you wanted on the command
              line), then updating with <command>-d</command> will create
              those directories, which may not be what you want.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-I <varname>name</varname></term>

            <listitem>
              <para>Ignore files whose names match <varname>name</varname> (in
              your working directory) during the update. You can specify
              <command>-I</command> more than once on the command line to
              specify several files to ignore. Use <command>-I !</command> to
              avoid ignoring any files at all. <xref linkend="cvsignore" />,
              for other ways to make cvsnt ignore some files.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-m</term>

            <listitem>
              <para>Perform the <command>-j</command> merge based on the last
              mergepoint. This is the default.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-S</term>

            <listitem>
              <para>Perform limited selection between conflicting case
              sensitive names on a case insensitive system. This option can be
              used to checkout files with conflicting names however it is not
              a solution to the problem - the conflict should be fixed in the
              repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t</term>

            <listitem>
              <para>Update using the last checkin time of the file not the
              current time. Do not use this option if you are using a makefile
              based system as it will cause problems with the build process.
              On other systems be aware of any side effects before using this
              option.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-W<varname>spec</varname></term>

            <listitem>
              <para>Specify file names that should be filtered during update.
              You can use this option repeatedly. Use <command>-W !</command>
              avoid using the default wrappers. <varname>spec</varname> can be
              a file name pattern of the same type that you can specify in the
              <command>.cvswrappers</command> file. <xref
              linkend="Wrappers" />.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-j<varname>revision</varname></term>

            <listitem>
              <para>With two <command>-j</command> options, merge changes from
              the revision specified with the first <command>-j</command>
              option to the revision specified with the second
              <command>j</command> option, into the working directory.</para>

              <para>With one <command>-j</command> option, merge changes from
              the ancestor revision to the revision specified with the
              <command>-j</command> option, into the working directory. The
              ancestor revision is the common ancestor of the revision which
              the working directory is based on, and the revision specified in
              the <command>-j</command> option.</para>

              <para>Note that using a single <command>-j
              <varname>tagname</varname></command> option rather than
              <command>-j <varname>branchname</varname></command> to merge
              changes from a branch will often not remove files which were
              removed on the branch. <xref
              linkend="Merging-adds-and-removals" />, for more.</para>

              <para>In addition, each <command>-j</command> option can contain
              an optional date specification which, when used with branches,
              can limit the chosen revision to one within a specific date. An
              optional date is specified by adding a colon (:) to the tag:
              <command>-j<varname>Symbolic_Tag</varname>:<varname>Date_Specifier</varname></command>.</para>

              <para><xref linkend="Branching-and-merging" />.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="update-output">
        <title>update output</title>

        <para><command>update</command> and <command>checkout</command> keep
        you informed of their progress by printing a line for each file,
        preceded by one character indicating the status of the file:</para>

        <variablelist>
          <varlistentry>
            <term>U <varname>file</varname></term>

            <listitem>
              <para>The file was brought up to date with respect to the
              repository. This is done for any file that exists in the
              repository but not in your source, and for files that you
              haven't changed but are not the most recent versions available
              in the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>P <varname>file</varname></term>

            <listitem>
              <para>Like <command>U</command>, but the cvsnt server sends a
              patch instead of an entire file. These two things accomplish the
              same thing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>A <varname>file</varname></term>

            <listitem>
              <para>The file has been added to your private copy of the
              sources, and will be added to the source repository when you run
              <command>commit</command> on the file. This is a reminder to you
              that the file needs to be committed.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>R <varname>file</varname></term>

            <listitem>
              <para>The file has been removed from your private copy of the
              sources, and will be removed from the source repository when you
              run <command>commit</command> on the file. This is a reminder to
              you that the file needs to be committed.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>M <varname>file</varname></term>

            <listitem>
              <para>The file is modified in your working directory.</para>

              <para><command>M</command> can indicate one of two states for a
              file you're working on: either there were no modifications to
              the same file in the repository, so that your file remains as
              you last saw it; or there were modifications in the repository
              as well as in your copy, but they were merged successfully,
              without conflict, in your working directory.</para>

              <para>cvsnt will print some messages if it merges your work, and
              a backup copy of your working file (as it looked before you ran
              <command>update</command>) will be made. The exact name of that
              file is printed while <command>update</command> runs.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>C <varname>file</varname></term>

            <listitem>
              <para><indexterm>
                  <primary>.# files</primary>
                </indexterm><indexterm>
                  <primary>__ files (VMS)</primary>
                </indexterm>A conflict was detected while trying to merge your
              changes to <varname>file</varname> with changes from the source
              repository. <varname>file</varname> (the copy in your working
              directory) is now the result of attempting to merge the two
              revisions; an unmodified copy of your file is also in your
              working directory, with the name
              <command>.#<varname>file</varname>.<varname>revision</varname></command>
              where <varname>revision</varname> is the revision that your
              modified file started from. Resolve the conflict as described in
              <xref linkend="Conflicts-example" />. (Note that some systems
              automatically purge files that begin with <command>.#</command>
              if they have not been accessed for a few days. If you intend to
              keep a copy of your original file, it is a very good idea to
              rename it.) Under vms, the file name starts with
              <command>__</command> rather than <command>.#</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>? <varname>file</varname></term>

            <listitem>
              <para><varname>file</varname> is in your working directory, but
              does not correspond to anything in the source repository, and is
              not in the list of files for cvsnt to ignore (see the
              description of the <command>-I</command> option, and <xref
              linkend="cvsignore" />).</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <sect1 id="version">
      <title>version--Display client and server versions.</title>

      <indexterm>
        <primary>version</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: nothing.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms: ve,ver</para>
          </listitem>
        </itemizedlist>Display the version of the client in use. Also displays
      the version of the remote server if that information is
      available.</para>

      <sect2>
        <title>version options</title>

        <para><variablelist>
            <varlistentry>
              <term>-q</term>

              <listitem>
                <para>Display only the version number of the local client, not
                other information.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="watch">
      <title>watch--Watch for changes in a file</title>

      <indexterm>
        <primary>watch</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: repository.</para>
          </listitem>

          <listitem>
            <para>Synonyms:</para>
          </listitem>
        </itemizedlist>Add yourself to the list of watchers for a file.
      Watchers are notified via the <command>notify</command> script whenever
      an action they are interested in happens. See <xref
      linkend="Watches" /></para>

      <sect2>
        <title>watch options</title>

        <para><variablelist>
            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process local directory only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-a</term>

              <listitem>
                <para>Specify what actions to watch. One of
                edit,unedit,commit,all,none.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="watchers">
      <title>watchers--list watched files</title>

      <indexterm>
        <primary>watchers</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Synonyms:</para>
          </listitem>
        </itemizedlist>Display the list of files that are being watched, and
      what is being watched about them. See <xref linkend="Watches" /></para>

      <sect2>
        <title>watchers options</title>

        <para><variablelist>
            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process local directory only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>

    <sect1 id="xdiff">
      <title>xdiff--External diff</title>

      <indexterm>
        <primary>xdiff</primary>
      </indexterm>

      <para><itemizedlist>
          <listitem>
            <para>Requires: repository, working directory.</para>
          </listitem>

          <listitem>
            <para>Changes: nothing.</para>
          </listitem>

          <listitem>
            <para>Sysnonyms: xd</para>
          </listitem>
        </itemizedlist>Run an external diff defined by the
      <command>cvswrappers</command> file on the server. The output and
      options for this option vary depending on what is run on the server-side
      diff, however the common options are listed below.</para>

      <sect2>
        <title>xdiff options</title>

        <para><variablelist>
            <varlistentry>
              <term>-D date</term>

              <listitem>
                <para>Diff revision for date against working file. Specifying
                the <command>-D</command> option twice causes the diff to be
                against the two dated revisions instead of the working
                file.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-N</term>

              <listitem>
                <para>Also diff added and removed files.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-R</term>

              <listitem>
                <para>Process directories recursively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-l</term>

              <listitem>
                <para>Process local directory only.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-o xdiff-options</term>

              <listitem>
                <para>Pass extra arguments and options to the external xdiff
                program.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>-r rev</term>

              <listitem>
                <para>Diff revision or tag against working file. Specifying a
                second <command>-r</command> option causes the diff to be
                against two specified revisions instead of the working
                file.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </sect2>
    </sect1>
  </appendix>

  <appendix id="Administrative-files">
    <title>Reference manual for Administrative files</title>

    <para><indexterm>
        <primary>Administrative files (reference)</primary>
      </indexterm><indexterm>
        <primary>Files, reference manual</primary>
      </indexterm><indexterm>
        <primary>Reference manual (files)</primary>
      </indexterm><indexterm>
        <primary>CVSROOT (file)</primary>
      </indexterm> Inside the repository, in the directory
    <command>$REAL_CVSROOT/CVSROOT</command>, there are a number of supportive
    files for cvsnt. You can use cvsnt in a limited fashion without any of
    them, but if they are set up properly they can help make life easier. For
    a discussion of how to edit them, see <xref
    linkend="Intro-administrative-files" />.</para>

    <para>The most important of these files is the <command>modules</command>
    file, which defines the modules inside the repository.</para>

    <sect1 id="modules">
      <title>The modules file</title>

      <para><indexterm>
          <primary>Modules (admin file)</primary>
        </indexterm><indexterm>
          <primary>Defining modules (reference manual)</primary>
        </indexterm> The <command>modules</command> file records your
      definitions of names for collections of source code. cvsnt will use
      these definitions if you use cvsnt to update the modules file (use
      normal commands like <command>add</command>, <command>commit</command>,
      etc).</para>

      <para>The <command>modules</command> file may contain blank lines and
      comments (lines beginning with <command>#</command>) as well as module
      definitions. Long lines can be continued on the next line by specifying
      a backslash (<command>\</command>) as the last character on the
      line.</para>

      <para>There are three basic types of modules: alias modules, regular
      modules, and ampersand modules. The difference between them is the way
      that they map files in the repository to files in the working directory.
      In all of the following examples, the top-level repository contains a
      directory called <command>first-dir</command>, which contains two files,
      <command>file1</command> and <command>file2</command>, and a directory
      <command>sdir</command>. <command>first-dir/sdir</command> contains a
      file <command>sfile</command>.</para>

      <sect2 id="Alias-modules">
        <title>Alias modules</title>

        <para><indexterm>
            <primary>Alias modules</primary>
          </indexterm><indexterm>
            <primary>-a, in modules file</primary>
          </indexterm> Alias modules are the simplest kind of module:</para>

        <variablelist>
          <varlistentry>
            <term><varname>mname</varname> -a
            <varname>aliases</varname>...</term>

            <listitem>
              <para>This represents the simplest way of defining a module
              <varname>mname</varname>. The <command>-a</command> flags the
              definition as a simple alias: cvsnt will treat any use of
              <varname>mname</varname> (as a command argument) as if the list
              of names <varname>aliases</varname> had been specified instead.
              <varname>aliases</varname> may contain either other module names
              or paths. When you use paths in aliases,
              <command>checkout</command> creates all intermediate directories
              in the working directory, just as if the path had been specified
              explicitly in the cvsnt arguments.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>For example, if the modules file contains:</para>

        <para><screen>
amodule -a first-dir
</screen></para>

        <para>then the following two commands are equivalent:</para>

        <para><screen>
$ cvs co amodule
$ cvs co first-dir
</screen></para>

        <para>and they each would provide output such as:</para>

        <para><screen>
cvs checkout: Updating first-dir
U first-dir/file1
U first-dir/file2
cvs checkout: Updating first-dir/sdir
U first-dir/sdir/sfile
</screen></para>
      </sect2>

      <sect2 id="Regular-modules">
        <title>Regular modules</title>

        <para><indexterm>
            <primary>Regular modules</primary>
          </indexterm></para>

        <variablelist>
          <varlistentry>
            <term><varname>mname</varname> [ options ] <varname>dir</varname>
            [ <varname>files</varname>... ]</term>

            <listitem>
              <para>In the simplest case, this form of module definition
              reduces to <command><varname>mname</varname>
              <varname>dir</varname></command>. This defines all the files in
              directory <varname>dir</varname> as module mname.
              <varname>dir</varname> is a relative path (from
              <command>$CVSROOT</command>) to a directory of source in the
              source repository. In this case, on checkout, a single directory
              called <varname>mname</varname> is created as a working
              directory; no intermediate directory levels are used by default,
              even if <varname>dir</varname> was a path involving several
              directory levels.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>For example, if a module is defined by:</para>

        <para><screen>
regmodule first-dir
</screen></para>

        <para>then regmodule will contain the files from first-dir:</para>

        <para><screen>
$ cvs co regmodule
cvs checkout: Updating regmodule
U regmodule/file1
U regmodule/file2
cvs checkout: Updating regmodule/sdir
U regmodule/sdir/sfile
$
</screen></para>

        <para>By explicitly specifying files in the module definition after
        <varname>dir</varname>, you can select particular files from directory
        <varname>dir</varname>. Here is an example:</para>

        <para><screen>
regfiles first-dir/sdir sfile
</screen></para>

        <para>With this definition, getting the regfiles module will create a
        single working directory <command>regfiles</command> containing the
        file listed, which comes from a directory deeper in the cvsnt source
        repository:</para>

        <para><screen>
$ cvs co regfiles
U regfiles/sfile
$
</screen></para>
      </sect2>

      <sect2 id="Ampersand-modules">
        <title>Ampersand modules</title>

        <para><indexterm>
            <primary>Ampersand modules</primary>
          </indexterm><indexterm>
            <primary>&amp;, in modules file</primary>
          </indexterm> A module definition can refer to other modules by
        including <command>&amp;<varname>module</varname></command> in its
        definition. <screen><varname>mname</varname> [ options ] <varname>&amp;module</varname>...
</screen></para>

        <para>Then getting the module creates a subdirectory for each such
        module, in the directory containing the module. For example, if
        modules contains</para>

        <para><screen>
ampermod &amp;first-dir
</screen></para>

        <para>then a checkout will create an <command>ampermod</command>
        directory which contains a directory called
        <command>first-dir</command>, which in turns contains all the
        directories and files which live there. For example, the
        command</para>

        <para><screen>
$ cvs co ampermod
</screen></para>

        <para>will create the following files:</para>

        <para><screen>
ampermod/first-dir/file1
ampermod/first-dir/file2
ampermod/first-dir/sdir/sfile
</screen></para>

        <para>There is one quirk/bug: the messages that cvsnt prints omit the
        <command>ampermod</command>, and thus do not correctly display the
        location to which it is checking out the files:</para>

        <para><screen>
$ cvs co ampermod
cvs checkout: Updating first-dir
U first-dir/file1
U first-dir/file2
cvs checkout: Updating first-dir/sdir
U first-dir/sdir/sfile
$
</screen></para>

        <para>Do not rely on this buggy behavior; it may get fixed in a future
        release of cvsnt.</para>
      </sect2>

      <sect2 id="Excluding-directories">
        <title>Excluding directories</title>

        <para><indexterm>
            <primary>Excluding directories, in modules file</primary>
          </indexterm><indexterm>
            <primary>!, in modules file</primary>
          </indexterm> An alias module may exclude particular directories from
        other modules by using an exclamation mark (<command>!</command>)
        before the name of each directory to be excluded.</para>

        <para>For example, if the modules file contains:</para>

        <para><screen>exmodule -a !first-dir/sdir first-dir
</screen></para>

        <para>then checking out the module <command>exmodule</command> will
        check out everything in <command>first-dir</command> except any files
        in the subdirectory <command>first-dir/sdir</command>.</para>
      </sect2>

      <sect2 id="Module-options">
        <title>Module options</title>

        <para><indexterm>
            <primary>Options, in modules file</primary>
          </indexterm> Either regular modules or ampersand modules can contain
        options, which supply additional information concerning the
        module.</para>

        <variablelist>
          <title><indexterm>
              <primary>-d, in modules file</primary>
            </indexterm></title>

          <varlistentry>
            <term>-d <varname>name</varname></term>

            <listitem>
              <para>Name the working directory something other than the module
              name.</para>

              <para><indexterm>
                  <primary>Export program</primary>
                </indexterm><indexterm>
                  <primary>-e, in modules file</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-e <varname>prog</varname></term>

            <listitem>
              <para>Specify a program <varname>prog</varname> to run whenever
              files in a module are exported. <varname>prog</varname> runs
              with a single argument, the module name.</para>

              <para><indexterm>
                  <primary>Checkin program</primary>
                </indexterm><indexterm>
                  <primary>-i, in modules file</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-i <varname>prog</varname></term>

            <listitem>
              <para>Specify a program <varname>prog</varname> to run whenever
              files in a module are committed. <varname>prog</varname> runs
              with a single argument, the full pathname of the affected
              directory in a source repository. The
              <command>commitinfo</command>, <command>loginfo</command>, and
              <command>verifymsg</command> files provide other ways to call a
              program on commit.</para>

              <para><indexterm>
                  <primary>Checkout program</primary>
                </indexterm><indexterm>
                  <primary>-o, in modules file</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-o <varname>prog</varname></term>

            <listitem>
              <para>Specify a program <varname>prog</varname> to run whenever
              files in a module are checked out. <varname>prog</varname> runs
              with a single argument, the module name.</para>

              <para><indexterm>
                  <primary>Status of a module</primary>
                </indexterm><indexterm>
                  <primary>Module status</primary>
                </indexterm><indexterm>
                  <primary>-s, in modules file</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-s <varname>status</varname></term>

            <listitem>
              <para>Assign a status to the module. When the module file is
              printed with <command>cvs checkout -s</command> the modules are
              sorted according to primarily module status, and secondarily
              according to the module name. This option has no other meaning.
              You can use this option for several things besides status: for
              instance, list the person that is responsible for this
              module.</para>

              <para><indexterm>
                  <primary>Tag program</primary>
                </indexterm><indexterm>
                  <primary>-t, in modules file</primary>
                </indexterm></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-t <varname>prog</varname></term>

            <listitem>
              <para>Specify a program <varname>prog</varname> to run whenever
              files in a module are tagged with <command>rtag</command>.
              <varname>prog</varname> runs with two arguments: the module name
              and the symbolic tag specified to <command>rtag</command>. It is
              not run when <command>tag</command> is executed. Generally you
              will find that taginfo is a better solution (<xref
              linkend="user-defined-logging" />).</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2 id="Module-program-options">
        <title>How the modules file "program options" programs are run</title>

        <para><indexterm>
            <primary>Modules file program options</primary>
          </indexterm><indexterm>
            <primary>-u, in modules file</primary>
          </indexterm><indexterm>
            <primary>-t, in modules file</primary>
          </indexterm><indexterm>
            <primary>-o, in modules file</primary>
          </indexterm><indexterm>
            <primary>-i, in modules file</primary>
          </indexterm><indexterm>
            <primary>-e, in modules file</primary>
          </indexterm></para>

        <para>For checkout, rtag, and export, the program is server-based, and
        as such the following applies:-</para>

        <para>If using remote access methods (pserver, ext, etc.), cvsnt will
        execute this program on the server from a temporary directory. The
        path is searched for this program.</para>

        <para>If using "local access" (on a local or remote NFS filesystem,
        i.e. repository set just to a path), the program will be executed from
        the newly checked-out tree, if found there, or alternatively searched
        for in the path if not.</para>

        <para>The programs are all run after the operation has effectively
        completed.</para>
      </sect2>
    </sect1>

    <sect1 id="modules2">
      <title>The modules2 file</title>

      <para><indexterm>
          <primary>modules2 (admin file)</primary>
        </indexterm> The <command>modules2</command> file provides a lower
      level definition of modules than the <command>modules</command> file.
      Clients see the <command>modules2</command> structure as if it existed
      physically on the server.</para>

      <sect2 id="modules2-comparison">
        <title>How the modules2 file differs from the modules file</title>

        <para><indexterm>
            <primary>modules2, compared to modules</primary>
          </indexterm> The <command>modules</command> provides different types
        of module, which are 'high level', in that checking out a module is
        equivalent to calling checkout multiple times on different
        directories. This approach works well for simple cases, but breaks
        down in the more complex cases, causing unwanted interactions with the
        <command>update</command> command for example.</para>

        <para>The <command>modules2</command> has only one way of describing a
        module, but operates on a much lower level. Clients are unaware that
        the directory structure that they are checking out does not actually
        exist, and all cvs commands behave as normal. A file or directory
        defined by modules2 may have a completely different name to its real
        name, and updates/merging will be handled correctly even if multiple
        clients checkout under different names.</para>

        <para>Which file you choose depends on your requirements. It isn't
        recommend that usage is mixed between the two files as they both serve
        a similar function and it would get confusing.</para>
      </sect2>

      <sect2 id="modules2-usage">
        <title>Modules2 syntax</title>

        <para><indexterm>
            <primary>modules2, syntax</primary>
          </indexterm> The <command>modules2</command> file is structured in a
        similar way to the familiar Windows .ini file. Each section defines a
        module, and within each section is a description of the files and
        directories within that module.</para>

        <para>An example modules2 file is:</para>

        <para><screen>
  [pets]
  dog
  cat

  [people]
  brother
  sister

  [household]
  pets
  people
</screen></para>

        <para>Checking out 'household' will create the directory
        structure:</para>

        <para><screen>
  household
    pets
      dog
      cat
    people
      brother
      sister
</screen></para>

        <para>In this example the 'household', 'pets', and 'people'
        directories don't have any files in them - they're just containers.
        However let's say we want to put the files listing pet food in the
        pets directory, above all the pet specific directories.</para>

        <para>Modules2 lets you override what goes in the root of a module, to
        overlay another module in it:</para>

        <para><screen>
  [pets]
  / = !petfood
  dog
  cat

  [people]
  brother
  sister

  [household]
  pets
  people
</screen></para>

        <para>Now when we checkout we get the same directory structure as
        above, but the pets directory contains the contents of 'petfood'. Note
        also we said that we don't want any subdirectories of petfood, using
        the '!' prefix. This makes sure that the directory is never recursed
        into, even during an update -d. We still get the 'dog' and 'cat'
        directory of course.</para>

        <para>You can simply rename an entire directory tree using this
        method. The following:</para>

        <para><screen>
  [project1]
  / = myproject

  [project2]
  / = myproject
  junk =
  total_junk =
  project/old_project = myproject/junk
</screen></para>

        <para>project1 will checkout the entire myproject tree. project2 is
        the same, except the 'junk' directory is removed, and moved to
        project/oldproject. The total_junk directory is hidden
        completely.</para>

        <para>You can also mask certain files within a directory, or certain
        subdirectories using an extended regular expression.</para>

        <para><screen>
  [project1]
  / = myproject

  [project2]
  / = myproject (*\.cpp$|*\.[ch]$|*/$)
  junk =
  total_junk =
  project/old_project = myproject/junk
</screen></para>

        <para>Directories are subject to the same filtering, except they have
        a '/' directory separator after their name. If you just want to filter
        some files and allow subdirectories then add '|*/$' as an
        option.</para>

        <para>(need to be more verbose here: FIXME)</para>

        <para>The '+' prefix stops processing, so that entries that would be
        potentially recursive can be defined to be nonrecursive.</para>

        <para>Spaces can be used in the file, delimited by quotes or using
        backslash escapes. File separators must always be forward
        slashes.</para>

        <para>Comments are on a line beginning '#'</para>
      </sect2>
    </sect1>

    <sect1 id="Wrappers">
      <title>The cvswrappers file</title>

      <para><indexterm>
          <primary>cvswrappers</primary>
        </indexterm><indexterm>
          <primary>CVSWRAPPERS, environment variable</primary>
        </indexterm><indexterm>
          <primary>Wrappers</primary>
        </indexterm></para>

      <para>Wrappers refers to a cvsnt feature which lets you control certain
      settings based on the name of the file which is being operated on. The
      settings are <command>-k</command> for binary files,
      <command>-x</command> to define xdiff wrappers, <command>-t</command> to
      override default mime types, and <command>-m</command> for nonmergeable
      text files.</para>

      <para>The basic format of the file <command>cvswrappers</command>
      is:</para>

      <para><screen>wildcard     [option value][option value]...

where option is one of
-m           update methodology      value: MERGE or COPY
-k           keyword expansion       value: expansion mode
-x           xdiff specification     value: name of xdiff DLL, plus options.
-t           mime type               value: new mime type

and value is a single-quote delimited value.</screen></para>

      <para>For example, the following command imports a directory, treating
      files whose name ends in <command>.exe</command> as binary:</para>

      <para><screen>cvs import -I ! -W "*.exe -kb" first-dir vendortag reltag</screen></para>

      <para>The <command>-m</command> option specifies the merge methodology
      that should be used when a non-binary file is updated.
      <command>MERGE</command> means the usual cvsnt behavior: try to merge
      the files. <command>COPY</command> means that <command>cvs
      update</command> will refuse to merge files, as it also does for files
      specified as binary with <command>-kb</command> (but if the file is
      specified as binary, there is no need to specify <command>-m
      'COPY'</command>). cvsnt will provide the user with the two versions of
      the files, and require the user using mechanisms outside cvsnt, to
      insert any necessary changes. <emphasis>WARNING</emphasis>: do not use
      <command>COPY</command> with cvsnt 1.9 or earlier-such versions of cvsnt
      will copy one version of your file over the other, wiping out the
      previous contents. The <command>-m</command> wrapper option only affects
      behavior when merging is done on update; it does not affect how files
      are stored. See <xref linkend="Binary-files" />, for more on binary
      files.</para>

      <para>The -x option specifies the external diff program used when the
      cvs xdiff command is used. It is followed by the name of the xdiff
      library (which must always be relative to the predefined library root),
      and any optional parameters that the xdiff library requires. For
      example, to pass all .txt files through GNU diff:</para>

      <screen>*.txt -x "ext_xdiff diff -u --label \"%label1%\" \"%file1%\" \"%file2%\""</screen>

      <sect2>
        <title>default wrappers</title>

        <para>There are some kinds of files which are nearly always binary,
        and these have been given default wrappers of <command>-kb</command>
        within cvs. You can override these wrappers using <command>-W
        !</command> on the command line or specifying <command>!</command> in
        the first line of your cvswrappers files. If you do override these be
        sure to warn your users, who may be expecting default
        behaviour.<screen>*.a   *.avi  *.bin  *.bmp  *.bz2  *.class  *.dll  *.exe  *.gif 
*.gz  *.hqx  *.ilk  *.lib  *.jar  *.jpg    *.jpeg *.mpg  *.mpeg 
*.mov *.mp3  *.ncb  *.o    *.ogg  *.obj    *.pdb  *.pdf  *.png 
*.ppt *.res  *.rpm  *.sit  *.so   *.tar    *.tgz  *.tif  *.tiff 
*.wmv *.xls  *.zip</screen></para>

        <para>In addition, a file pattern of <command>*.*</command> or just
        <command>*</command> will be used as a default where no wrappers
        exist. This pattern may also contain addive or subtractive wrapper
        options (eg -k+x), in which case it will always be applied.</para>
      </sect2>
    </sect1>

    <sect1 id="commit-files">
      <title>The commit support files</title>

      <para><indexterm>
          <primary>Commit files</primary>
        </indexterm> The <command>-i</command> flag in the
      <command>modules</command> file can be used to run a certain program
      whenever files are committed (<xref linkend="modules" />). The files
      described in this section provide other, more flexible, ways to run
      programs whenever something is committed.</para>

      <para>There are three kind of programs that can be run on commit. They
      are specified in files in the repository, as described below. The
      following table summarizes the file names and the purpose of the
      corresponding programs.</para>

      <variablelist>
        <varlistentry>
          <term>triggers</term>

          <listitem>
            <para>This is the main control file that cvs uses. Most of the
            other commit support files are implemented through a trigger
            (known as the default trigger).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>commitinfo</term>

          <listitem>
            <para>The program is responsible for checking that the commit is
            allowed. If it exits with a non-zero exit status the commit will
            be aborted.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>verifymsg</term>

          <listitem>
            <para>The specified program is used to evaluate the log message,
            and possibly verify that it contains all required fields. This is
            most useful in combination with the <command>rcsinfo</command>
            file, which can hold a log message template (<xref
            linkend="rcsinfo" />).</para>

            <para>The verifymsg script may or may be able to change the log
            message depending on the value of the RereadLogAfterVerify setting
            in the <command>config</command> file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>loginfo</term>

          <listitem>
            <para>The specified program is called when the commit is complete.
            It receives the log message and some additional information and
            can store the log message in a file, or mail it to appropriate
            persons, or maybe post it to a local newsgroup, or... Your
            imagination is the limit!</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>precommand</term>

          <listitem>
            <para>The specified program is called prior to command execution,
            and is passed the list of arguments supplied to the command.
            Returning an error from this script will terminate command
            execution.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>postcommand</term>

          <listitem>
            <para>The specified program is called when the command is
            complete, and all locks have been released from the repository
            prior to returning to the user. This is useful to maintain
            checked-out copies of repositories and to perform cvs actions
            after a commit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>premodule</term>

          <listitem>
            <para>The specified program is called prior to entering a module.
            It is passed the repository, command and module name. Returning an
            error from this script will terminate command execution.</para>

            <para>Not all commands use the premodule/postmodule scripts, only
            those which take modules as arguments, eg. checkout, repository
            commands such as rlog, rtag, etc.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>postmodule</term>

          <listitem>
            <para>The specified program is called when module processing is
            complete. It is passed the repository, command and module
            name.</para>

            <para>Not all commands use the premodule/postmodule scripts, only
            those which take modules as arguments, eg. checkout, repository
            commands such as rlog, rtag, etc.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>postcommit</term>

          <listitem>
            <para>The specified program is called when a commit is complete,
            and all locks have been released from the repository prior to
            returning to the user. This is useful to maintain checked-out
            copies of repositories and to perform cvs actions after a
            commit.</para>

            <para>This script has been largely superceded by the
            <command>postcommand</command> script.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>historyinfo</term>

          <listitem>
            <para>This is called when any action which causes an entry in the
            history file is initiated. Its standard input receives the line to
            be written to the history log, in a semi-compressed format.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>notify</term>

          <listitem>
            <para>When required this file is called durin a commit, and also
            during edit/unedit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>keywords</term>

          <listitem>
            <para>Define non-standard or user defined keyword mappings</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>script.vbs, script.js, script.pl, script.py, script.rb</term>

          <listitem>
            <para>(Win32 only) ActiveScript trigger file. Implemented through
            the script trigger library (script_trigger.dll).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>shadow</term>

          <listitem>
            <para>Define shadow or checked-out workspaces on the server.
            Implemented by the checkout trigger library.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>commit_email</term>

          <listitem>
            <para>Define templates for automatic sending of emails during
            commit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>tag_email</term>

          <listitem>
            <para>Define templates for automatic sending of emails during
            tag</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>notify_email</term>

          <listitem>
            <para>Define templates for automatic sending of emails during
            notify</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <sect2 id="syntax">
        <title>The common syntax</title>

        <para><indexterm>
            <primary>Info files (syntax)</primary>
          </indexterm><indexterm>
            <primary>Syntax of info files</primary>
          </indexterm><indexterm>
            <primary>Common syntax of info files</primary>
          </indexterm></para>

        <para>The administrative files such as <command>commitinfo</command>,
        <command>loginfo</command>, <command>rcsinfo</command>,
        <command>verifymsg</command>, etc., all have a common format. The
        purpose of the files are described later on. The common syntax is
        described here.</para>

        <para><indexterm>
            <primary>Regular expression syntax</primary>
          </indexterm>Each line contains the following:</para>

        <itemizedlist mark="bullet">
          <listitem>
            <para>A regular expression. This uses Perl-Compatible regular
            expression syntax (PCRE). On case insensitive servers this
            expression is also case insensitive.</para>
          </listitem>

          <listitem>
            <para>A whitespace separator--one or more spaces and/or
            tabs.</para>
          </listitem>

          <listitem>
            <para><command>shell command</command> the commonest form, invokes
            a shell script using the parameters described below.</para>
          </listitem>
        </itemizedlist>

        <para>Blank lines are ignored. Lines that start with the character
        <command>#</command> are treated as comments. Long lines unfortunately
        can <emphasis>not</emphasis> be broken in two parts in any way.</para>

        <para>Each regular expression that matches the current directory name
        in the repository is considered for use. The first match will be used,
        followed by any matching lines that are prefixed by '+'. The rest of
        the line after the regular expression is used as a file name or
        command-line as appropriate.</para>

        <para>Directory and filename separators must use Unix conventions
        (forward slashes) on all platforms.</para>

        <para>All files have a set of default parameters (see the description
        of each file for details). In addition a number of common parameters
        are available to be passed to each file.<variablelist>
            <varlistentry>
              <term>%c</term>

              <listitem>
                <para>Command currently being executed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%d</term>

              <listitem>
                <para>Date and time of executing command.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%h</term>

              <listitem>
                <para>Remote host name, on client/server connections.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%u</term>

              <listitem>
                <para>Current cvs username.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%r</term>

              <listitem>
                <para>virtual repository name (repository alias, to be
                displayed to the user).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%R</term>

              <listitem>
                <para>Physical repository name (for file access).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%S</term>

              <listitem>
                <para>Session ID or commit ID.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%e</term>

              <listitem>
                <para>Current value of $CVSEDITOR.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%H</term>

              <listitem>
                <para>Local host name.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%P</term>

              <listitem>
                <para>Local directory (temporary directory in client/server
                connections).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%i</term>

              <listitem>
                <para>Client version string if supplied by the client.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%n</term>

              <listitem>
                <para>An empty string.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>%%</term>

              <listitem>
                <para>% sign</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>$...</term>

              <listitem>
                <para>CVSNT environment variable (see <xref
                linkend="Environment-variables" />), System environment
                variable, or User variable (see <xref
                linkend="Variables" />).</para>
              </listitem>
            </varlistentry>
          </variablelist></para>

        <para>You can group parameters into a single script argument using the
        <command>%{}</command> syntax.</para>

        <para>Parameters can be sent either to the script command line, or its
        standard input. Options for standard input begin with
        <command>%&lt;</command>, as below.</para>

        <variablelist>
          <varlistentry>
            <term>%&lt;option</term>

            <listitem>
              <para>Send value of option to standard input.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%&lt;{options}</term>

            <listitem>
              <para>Send value of options to standard input on a single
              line.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%&lt;&lt; text for standard input\nhello %u!\n</term>

            <listitem>
              <para>Send the following string to standard input. This must be
              the last item on the line.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%&lt;&lt;TAG</term>

            <listitem>
              <para>Send everything in the file until the next occurence of
              <command>TAG</command> on its own to standard input. This must
              be the last item on the line.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <sect1 id="triggers">
      <title>Triggers</title>

      <indexterm>
        <primary>triggers</primary>
      </indexterm>

      <indexterm>
        <primary>Library interface</primary>
      </indexterm>

      <para>The triggers file defines a binary interface to the cvsnt server.
      The calling parameters to this interface are listed in a separate
      document (The CVS Library Interface).</para>

      <para>Each line of the file lists the location of the a trigger library
      to be loaded on server startup. On Win32 this line may also be the Class
      ID of a COM object resident on the server.</para>

      <para>As the server goes through each phase of operation, each trigger
      is called in turn. In addition a default library (called
      default_trigger) is called, which dispatches scripts contained in each
      of the files mentioned below.</para>
    </sect1>

    <sect1 id="commitinfo">
      <title>Commitinfo</title>

      <para><indexterm>
          <primary>Commitinfo</primary>
        </indexterm><indexterm>
          <primary>Checking commits</primary>
        </indexterm><indexterm>
          <primary>Precommit checking</primary>
        </indexterm> The <command>commitinfo</command> file defines programs
      to execute whenever <command>cvs commit</command> is about to execute.
      These programs are used for pre-commit checking to verify that the
      modified, added and removed files are really ready to be committed. This
      could be used, for instance, to verify that the changed files conform to
      to your site's standards for coding practice.</para>

      <para>As mentioned earlier, each line in the
      <command>commitinfo</command> file consists of a regular expression and
      a command-line template. A number of extra options are available in the
      commitinfo file beyond those in the generic list.<variablelist>
          <varlistentry>
            <term>%s</term>

            <listitem>
              <para>File name(s) that this invocation is using.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%m</term>

            <listitem>
              <para>Commit message supplied by the user</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%p</term>

            <listitem>
              <para>Current directory name, relative to the root.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>The default pattern used if none is specified is <command>%r/%p
      %&lt;s</command>, which causes the full path to the current source
      repository to be appended to the template, followed by the file names of
      any files involved in the commit (added, removed, and modified
      files).</para>

      <para><indexterm>
          <primary>Exit status, of commitinfo</primary>
        </indexterm>The first line with a regular expression matching the
      directory within the repository will be used. If the command returns a
      non-zero exit status the commit will be aborted.</para>

      <para><indexterm>
          <primary>DEFAULT in commitinfo</primary>
        </indexterm>If the repository name does not match any of the regular
      expressions in this file, the <command>DEFAULT</command> line is used,
      if it is specified.</para>

      <para><indexterm>
          <primary>ALL in commitinfo</primary>
        </indexterm>All occurrences of the name <command>ALL</command>
      appearing as a regular expression are used in addition to the first
      matching regular expression or the name
      <command>DEFAULT</command>.</para>

      <para>Note: when cvsnt is accessing a remote repository,
      <command>commitinfo</command> will be run on the
      <emphasis>remote</emphasis> (i.e., server) side, not the client side
      (<xref linkend="Remote-repositories" />).</para>
    </sect1>

    <sect1 id="verifymsg">
      <title>Verifying</title>

      <para><indexterm>
          <primary>verifymsg</primary>
        </indexterm><indexterm>
          <primary>Log message, verifying</primary>
        </indexterm> Once you have entered a log message, you can evaluate
      that message to check for specific content, such as a bug ID. Use the
      <command>verifymsg</command> file to specify a program that is used to
      verify the log message. This program could be a simple script that
      checks that the entered message contains the required fields.</para>

      <para>The <command>verifymsg</command> file is often most useful
      together with the <command>rcsinfo</command> file, which can be used to
      specify a log message template.</para>

      <para>Each line in the <command>verifymsg</command> file consists of a
      regular expression and a command-line template. Each line can have any
      combination of the following, in addition to those listed in the common
      syntax.<variablelist>
          <varlistentry>
            <term>%p</term>

            <listitem>
              <para>Directory name relative to the current root.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%l</term>

            <listitem>
              <para>Full path to file containing the log message.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>The template must include a program name, and can include any
      number of arguments. If no other formatting is used
      <command>%l</command> is automatically added which appends the full path
      to the current log message file file to the template.</para>

      <para><indexterm>
          <primary>DEFAULT in verifymsg</primary>
        </indexterm>If the repository name does not match any of the regular
      expressions in this file, the <command>DEFAULT</command> line is used,
      if it is specified.</para>

      <para><indexterm>
          <primary>Exit status, of verifymsg</primary>
        </indexterm>If the verification script exits with a non-zero exit
      status, the commit is aborted.</para>

      <para>Note that the verification script cannot change the log message;
      it can merely accept it or reject it.</para>

      <para>The following is a little silly example of a
      <command>verifymsg</command> file, together with the corresponding
      <command>rcsinfo</command> file, the log message template and an
      verification script. We begin with the log message template. We want to
      always record a bug-id number on the first line of the log message. The
      rest of log message is free text. The following template is found in the
      file <command>/usr/cvssupport/tc.template</command>.</para>

      <para><screen>BugId:
</screen></para>

      <para>The script <command>/usr/cvssupport/bugid.verify</command> is used
      to evaluate the log message.</para>

      <para><screen>
#!/bin/sh
#
#       bugid.verify filename
#
#  Verify that the log message contains a valid bugid
#  on the first line.
#
if head -1 &lt; $1 | grep '^BugId:[ ]*[0-9][0-9]*$' &gt; /dev/null; then
    exit 0
else
    echo "No BugId found."
    exit 1
fi
</screen></para>

      <para>The <command>verifymsg</command> file contains this line:</para>

      <para><screen>
^tc     /usr/cvssupport/bugid.verify
</screen></para>

      <para>The <command>rcsinfo</command> file contains this line:</para>

      <para><screen>
^tc     /usr/cvssupport/tc.template
</screen></para>
    </sect1>

    <sect1 id="loginfo">
      <title>Loginfo</title>

      <para><indexterm>
          <primary>loginfo</primary>
        </indexterm><indexterm>
          <primary>Storing log messages</primary>
        </indexterm><indexterm>
          <primary>Mailing log messages</primary>
        </indexterm><indexterm>
          <primary>Distributing log messages</primary>
        </indexterm><indexterm>
          <primary>Log messages</primary>
        </indexterm> The <command>loginfo</command> file is used to control
      where <command>cvs commit</command> log information is sent. The first
      entry on a line is a regular expression which is tested against the
      directory that the change is being made to, relative to the
      <command>$CVSROOT</command>. If a match is found, then the remainder of
      the line is a filter program that should expect log information on its
      standard input.</para>

      <para>If the repository name does not match any of the regular
      expressions in this file, the <command>DEFAULT</command> line is used,
      if it is specified.</para>

      <para>All occurrences of the name <command>ALL</command> appearing as a
      regular expression are used in addition to the first matching regular
      expression or <command>DEFAULT</command>.</para>

      <para>The first matching regular expression is used.</para>

      <para><xref linkend="commit-files" />, for a description of the syntax
      of the <command>loginfo</command> file.</para>

      <para>The user may specify a format string as part of the filter. The
      string is composed of a <command>%</command> followed by a space, or
      followed by a single format character, or followed by a set of format
      characters surrounded by <command>{</command> and <command>}</command>
      as separators. The format characters are those in the common syntax
      plus:</para>

      <variablelist>
        <varlistentry>
          <term>%m</term>

          <listitem>
            <para>Message supplied by user</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%T</term>

          <listitem>
            <para>Status string</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%p</term>

          <listitem>
            <para>Directory name relative to the current root</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%s</term>

          <listitem>
            <para>Module name, followed by the list of filenames. When used in
            a group this option has a special action which is designed to
            mimic previous versions of cvs when the standard
            <command>%{sVv}</command> is used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%V</term>

          <listitem>
            <para>Current version, pre-checkin.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%v</term>

          <listitem>
            <para>Current version, post-checkin.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%b</term>

          <listitem>
            <para>Bug identifier</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%t</term>

          <listitem>
            <para>Tag</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>%y</term>

          <listitem>
            <para>Type</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>All other characters that appear in a format string expand to an
      empty field (commas separating fields are still provided).</para>

      <para>For example, some valid format strings are <command>%</command>,
      <command>%s</command>, <command>%{s}</command>, and
      <command>%{sVv}</command>.</para>

      <para>By default the standard input is a formatted string which mimics
      the behaviour of older CVS versions (see below).</para>

      <para>For a commit the command line will be a string of tokens separated
      by spaces. For backwards compatibility, the first token will be the
      repository subdirectory. The rest of the tokens will be comma-delimited
      lists of the information requested in the format string. For example, if
      <command>/u/src/master/yoyodyne/tc</command> is the repository,
      <command>%{sVv}</command> is the format string, and three files
      (<wordasword>ChangeLog</wordasword>, <wordasword>Makefile</wordasword>,
      <wordasword>foo.c</wordasword>) were modified, the output might
      be:</para>

      <para><screen>yoyodyne/tc ChangeLog,1.1,1.2 Makefile,1.3,1.4 foo.c,1.12,1.13</screen></para>

      <para>As another example, <command>%{}</command> means that only the
      name of the repository will be generated.</para>

      <para>When run as part of an import or add directory, the command line
      the repository subdirectory followed by the text</para>

      <para><command>- New Directory</command></para>

      <para>or</para>

      <para><command>- Imported Sources</command></para>

      <para>Note: when cvsnt is accessing a remote repository,
      <command>loginfo</command> will be run on the
      <emphasis>remote</emphasis> (i.e., server) side, not the client side
      (<xref linkend="Remote-repositories" />).</para>

      <sect2 id="loginfo-example">
        <title>Loginfo example</title>

        <para>The following <command>loginfo</command> file, together with the
        tiny shell-script below, appends all log messages to the file
        <command>$REAL_CVSROOT/CVSROOT/commitlog</command>, and any commits to
        the administrative files (inside the <command>CVSROOT</command>
        directory) are also logged in <command>/usr/adm/cvsroot-log</command>.
        Commits to the <command>prog1</command> directory are mailed to
        <wordasword>ceder</wordasword>.</para>

        <para><screen>ALL             /usr/local/bin/cvs-log $REAL_CVSROOT/CVSROOT/commitlog $USER
^CVSROOT        /usr/local/bin/cvs-log /usr/adm/cvsroot-log
^prog1          Mail -s %s ceder</screen></para>

        <para>The shell-script <command>/usr/local/bin/cvs-log</command> looks
        like this:</para>

        <para><screen>
#!/bin/sh
(echo "------------------------------------------------------";
 echo -n $2"  ";
 date;
 echo;
 cat) &gt;&gt; $1</screen></para>
      </sect2>

      <sect2>
        <title>Loginfo default standard input format</title>

        <para>For both commit and import the first two lines are the
        following:<screen>Update of %r/%p
In directory %H:%P</screen> Next part is different for import and commit. For
        commits there comes line with the current operation/operations, namely
        "Added Files:", "Removed Files:" or "Modified Files:". In the next
        lines there are, indented with TAB, space separated list of added,
        removed or modified files. There is no such section for added
        directories (because one can remove empty directories only with
        checkout/update with -P option, not by commit). There is instead
        "Directory $CVSROOT/subdirectory added to repository" log message. For
        import next part (separated by empty line) is the log message:<screen>Log Message:
%m</screen> This part is also after commit, but for commit it is at the very
        end of input, and is _not_ separated by an empty line. Further parts
        are for import solely. After log message, separated by empty line
        comes:<screen>Status:</screen> Next is the information about release
        and vendor tag (see 'cvs import' syntax), separated of course from log
        message by an empty line, namely<screen>Vendor Tag: vendor_tag
Release Tags: release_tag</screen> Next, separated by an empty line, is the
        output of the import command. The format is<screen>X module_dir/subdir/file</screen>
        where X is one letter indicator of status. The last line is the status
        of import command, e.g.<screen>No conflicts created by this import</screen></para>
      </sect2>
    </sect1>

    <sect1 id="precommand">
      <title>Precommand</title>

      <para><indexterm>
          <primary>precommand</primary>
        </indexterm><indexterm>
          <primary>Precommand actions</primary>
        </indexterm> Prior to each cvs command, this file is called to
      validate the command arguments. The following formatting strings are
      available in addition to those in the common syntax:<variablelist>
          <varlistentry>
            <term>%a</term>

            <listitem>
              <para>List of arguments passed on the command line</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>By default <command>%r %c %&lt;a</command> is used, which passes
      the repository, command name, and all the command arguments in the
      standard input. An error (non-zero) return from this script will abort
      the command.</para>
    </sect1>

    <sect1 id="postcommand">
      <title>postcommand</title>

      <para><indexterm>
          <primary>postcommand</primary>
        </indexterm><indexterm>
          <primary>Postcommand actions</primary>
        </indexterm> After a command has completed, the actions in this file
      are executed so that you can perform operations on the repository before
      returning. The following formatting strings are available in addition to
      those in the common syntax:<variablelist>
          <varlistentry>
            <term>%p</term>

            <listitem>
              <para>Last directory affected, relative to repository
              root</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>%x</term>
            <listitem>
              <para>Return code of the command</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>By default the string <command>%r/%p %c</command> is used, which
      passes the current directory and command on the command line.</para>

      <para>If a command uses multiple modules, the module name used to select
      the line in the postcommand script is undefined. For this reason it is
      recommended to use only the <command>DEFAULT</command> and
      <command>ALL</command> lines.</para>

      <para>Typical uses of this would be to keep a checked-out copy of a
      repository.</para>
    </sect1>

    <sect1 id="premodule">
      <title>premodule</title>

      <para><indexterm>
          <primary>premodule</primary>
        </indexterm><indexterm>
          <primary>Premodule actions</primary>
        </indexterm> Before parsing a module, this script is called with the
      command name and module, to validate or log the use of the module.
      Returning nonzero from this script will terminate the operation. The
      following formatting strings are available in addition to those in the
      common syntax:<variablelist>
          <varlistentry>
            <term>%o</term>

            <listitem>
              <para>Logical module name</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>By default the string <command>%r/%p %c %o</command> is used,
      which passes the current directory, command and module on the command
      line.</para>

      <para>Not all command pass through premodule. In particular
      sandbox-related commands use the information in CVS/Repository and do
      not use the module system.</para>
    </sect1>

    <sect1 id="postmodule">
      <title>postmodule</title>

      <para><indexterm>
          <primary>postmodule</primary>
        </indexterm><indexterm>
          <primary>Postmodule actions</primary>
        </indexterm> This script is called after module processing is
      completed. It is passed the command name and module. The following
      strings are available in addition to those in the common
      syntax:<variablelist>
          <varlistentry>
            <term>%o</term>

            <listitem>
              <para>Logical module name</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>By default the string <command>%r/%p %c %o</command> is used,
      which passes the current directory, command and module on the command
      line.</para>

      <para>As modules in CVSROOT/modules may be defined recursively, it is
      possible that many premodule calls will be made in sequence before the
      first postmodule call. Scripts must be written to handle this when it
      occurs.</para>
    </sect1>

    <sect1 id="postcommit">
      <title>postcommit</title>

      <indexterm>
        <primary>postcommit</primary>
      </indexterm>

      <para>This script is called after a commit has completed. Its use has
      largely been superceded by the use of the postcommand script. The
      following formatting strings are available in addition to those in the
      common syntax:<variablelist>
          <varlistentry>
            <term>%p</term>

            <listitem>
              <para>Directory relative to root of last directory
              committed.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>By default the string <command>%r/%p</command> is used, which
      passes the last directory committed.</para>

      <para>If multiple modules or repositories are committed the module in
      effect when this file is parsed is undetermined, so it is recommended
      that only the DEFAULT and ALL lines are used.</para>
    </sect1>

    <sect1 id="historyinfo">
      <title>historyinfo</title>

      <indexterm>
        <primary>historyinfo</primary>
      </indexterm>

      <para>This script is called whenever a new line is to be written to the
      history file. As this can happen frequently it is not recommended that
      the script interface for this command be used as it will slow down
      server operations. The following formatting strings are available in
      addition to those in the common syntax:<variablelist>
          <varlistentry>
            <term>%t</term>

            <listitem>
              <para>History entry type</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%w</term>

            <listitem>
              <para>Working directory, truncated to history format</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%v</term>

            <listitem>
              <para>Affected revisions</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%s</term>

            <listitem>
              <para>Name of affected file</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>By default the string <command>%t|%d|%u|%w|%s|%v</command> is
      used, which is the same as the line written to the history file.</para>
    </sect1>

    <sect1 id="rcsinfo">
      <title>rcsinfo</title>

      <para><indexterm>
          <primary>rcsinfo</primary>
        </indexterm><indexterm>
          <primary>Form for log message</primary>
        </indexterm><indexterm>
          <primary>Log message template</primary>
        </indexterm><indexterm>
          <primary>Template for log message</primary>
        </indexterm> The <command>rcsinfo</command> file can be used to
      specify a form to edit when filling out the commit log. The
      <command>rcsinfo</command> file has a syntax similar to the
      <command>verifymsg</command>, <command>commitinfo</command> and
      <command>loginfo</command> files. <xref linkend="syntax" />. Unlike the
      other files the second part is <emphasis>not</emphasis> a command-line
      template. Instead, the part after the regular expression should be a
      full pathname to a file containing the log message template.</para>

      <para>If the repository name does not match any of the regular
      expressions in this file, the <command>DEFAULT</command> line is used,
      if it is specified.</para>

      <para>All occurrences of the name <command>ALL</command> appearing as a
      regular expression are used in addition to the first matching regular
      expression or <command>DEFAULT</command>.</para>

      <para>The log message template will be used as a default log message. If
      you specify a log message with <command>cvs commit -m
      <varname>message</varname></command> or <command>cvs commit -f
      <varname>file</varname></command> that log message will override the
      template.</para>

      <para><xref linkend="verifymsg" />, for an example
      <command>rcsinfo</command> file.</para>

      <para>When cvsnt is accessing a remote repository, the contents of
      <command>rcsinfo</command> at the time of the last update are used. If
      you edit <command>rcsinfo</command> or its templates, you may need to
      update your working directory.</para>
    </sect1>

    <sect1 id="notify">
      <title>notify</title>

      <indexterm>
        <primary>notify</primary>
      </indexterm>

      <para>The notify file is called whenever a watched file is changed
      during commit, edit or unedit. See also <xref linkend="Watches" /> for
      more details.</para>

      <para>In addition to the formatting strings in the common syntax, the
      following formatting strings are available:<variablelist>
          <varlistentry>
            <term>%m</term>

            <listitem>
              <para>Message supplied by user.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%b</term>

            <listitem>
              <para>Bug identifier</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%p</term>

            <listitem>
              <para>Directory name relative to current root</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%s</term>

            <listitem>
              <para>User being notified</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%t</term>

            <listitem>
              <para>Tag or branch of file being notified</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%y</term>

            <listitem>
              <para>Type of notification</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%f</term>

            <listitem>
              <para>File being notified about</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>By default the notify file has a string designed to be compatible
      with older versions of cvs passed in its standard input:<screen>%&lt;&lt; %p %f
---
Triggered %y watch on %r
By %u</screen></para>
    </sect1>

    <sect1 id="User-Defined-Keywords">
      <title>keywords</title>

      <indexterm>
        <primary>keywords</primary>
      </indexterm>

      <indexterm>
        <primary>CVSROOT/keywords</primary>
      </indexterm>

      <indexterm>
        <primary>RCS keywords, redefining</primary>
      </indexterm>

      <para>The keywords file contains user defined mappings of the standard
      rcs keywords (see <xref linkend="Keyword-substitution" />).</para>

      <para>For each module listed the first line defines the module(s) that
      the keyword list applies to, then on subsequent lines the keywords are
      listed, indented by at least one space. The special module name
      <command>ALL</command> refers to all modules, and is used by
      default.<screen>ALL
  Maintainer   Joe Bloggs
^Foo$
  Maintainer   Fred Bloggs</screen></para>

      <para>In the example above, Joe Bloggs maintains the repository and his
      brother Fred maintains the Foo module on his own. The rcs tag
      $Maintainer$ will be expanded differently depending on the location of
      any source files.</para>

      <para>You can also redefine or remove RCS tags, for example when
      tracking third party sources it may be desirable for the RCS tags from
      the imported sources to remain intact.<screen>ALL
  Id
  LocalId    %f %v %d %a %s</screen></para>

      <para>Listing a keyword with no definition disables its standard usage.
      In the example above $Id$ will no longer be considered as an RCS
      keyword, and $LocalId$ has been defined with the pattern previously
      assigned to $Id$.</para>

      <para>When redefining keywords you can use any variable listed in the
      common syntax, plus the following:<variablelist>
          <varlistentry>
            <term>%p</term>

            <listitem>
              <para>Path relative to repository root</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%f</term>

            <listitem>
              <para>Filename</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%a</term>

            <listitem>
              <para>Author</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%d</term>

            <listitem>
              <para>Date formatted in human readable format</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%D</term>

            <listitem>
              <para>Date formatted in RCS format</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%l</term>

            <listitem>
              <para>File locker (not normally useful in cvsnt)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%s</term>

            <listitem>
              <para>State (normally one of <command>Exp</command> or
              <command>Dead</command>)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%v</term>

            <listitem>
              <para>Version number</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%N</term>

            <listitem>
              <para>RCS $Name$ value</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%b</term>

            <listitem>
              <para>Bug identifier(s) identified with file</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%C</term>

            <listitem>
              <para>Commit/Session identifier</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>%t</term>

            <listitem>
              <para>Branch that revision is a member of</para>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>The standard RCS keywords are defined as follows:<screen>ALL
  Author     %a
  Date       %d
  Header     %r/%p/%f %v %d %a %s
  CVSHeader  %p/%f %v %d %a %s
  Id         %f %v %d %a %s
  Locker     %l
  Log        %f
  Name       %N
  RCSfile    %f
  Revision   %v
  Source     %r/%p/%f
  State      %s
  CommitId   %C
  Branch     %t</screen></para>

      <sect2>
        <title>Storing user defined information using keywords</title>

        <para>The keywords file is parsed on checkout, which means it isn't
        useful for storing environment variables or other dynamic data. To
        store such data user defined variables (see <xref
        linkend="Variables" />) can be used.</para>

        <para>For example, using the following keywords file<screen>ALL
  Weather    $WEATHER</screen></para>

        <para>the definition of WEATHER be defined during commit as a user
        defined variable<screen>$ cvs -s WEATHER=Sunny commit -m "Fix stuff" foo.c</screen></para>

        <para>This is then associated with that revision for future
        checkouts.</para>

        <para><remark><command>Compatibility note</command>: Programs which
        try to read the repository may fail on files with this data stored. If
        you use such software check that it still works
        afterwards.</remark></para>
      </sect2>
    </sect1>

    <sect1 id="Email-notification">
      <title>Email notification</title>

      <indexterm>
        <primary>Email notification</primary>
      </indexterm>

      <para>CVSNT contains a trigger library which is capable of sending
      notification emails on commit, tag or notify. It allows you to put any
      contents in the emails, but the output format is fairly simple - it is
      no substitute for a purpose designed notification program.</para>

      <para>Email sending is disabled by default. To configure it for use you
      must do the following.</para>

      <sect2>
        <title>Configure the commit support files</title>

        <para>The commit support files <command>commit_email</command>,
        <command>tag_email</command> and <command>notify_email</command>
        contain the names of the template files to use for commit, tag and
        notify respectively. Each line in these files is a regular expression
        followed by a filename. The filename is always relative to the CVSROOT
        directory and may not be an absolute path for security reasons.</para>

        <para>The first matching line for each directory committed is used. If
        there is no match the DEFAULT line is used.</para>

        <para>The name of the template file should also be <command>listed in
        the checkoutlist file</command> so that it is available for the script
        to use.</para>

        <para>The <command>CVSROOT/users</command> file is used to lookup the
        username -&gt; email mapping. This file is a list of colon separated
        username/email pairs. If this file does not exist or the username is
        not listed the default domain name set in the global configuration is
        used.</para>
      </sect2>

      <sect2>
        <title>Write the template</title>

        <para>The template file is a simple text file listing the exact text
        of the email to send including headers. The To:, From:, Cc: and Bcc:
        lines are used by the sending software to determing the addresses to
        use.</para>

        <para>An example commit template is:<screen>From: [email]
To: cvsnt_users@mycompany.com
Subject: Commit to [module]

CVSROOT:     [repository]
Module name: [module]
Changes by:  [email]           [date]
On host:     [hostname]

[begin_directory]
Directory: [directory]

[begin_file]
[change_type] [filename]   [tag]   [old_revision] -&gt; [new_revision]   [bugid]
[end_file]
[end_directory]

Log message:
[message]</screen></para>

        <para>A number of replacements are done on the file to format it for
        final sending. This differs for each file, and is listed below.</para>
      </sect2>

      <sect2>
        <title>Configure the server</title>

        <para>There are two ways that CVSNT can send email. The simplest is to
        set the SMTP Server and default domain in the global configuration
        (Control Panel in win32, /etc/cvsnt/PServer in Unix) and let the
        internal SMTP client send the emails.</para>

        <para>This will not work in the case where authenticaton is required
        or the server is not capable of SMTP. In these cases you instead set
        the Email Command. This command should take a list of 'to' addresses
        as parameters, and a raw RFC822 email as its standard input.</para>

        <para>A suitable configuration for Unix systems is<screen>/usr/sbin/sendmail -i</screen></para>

        <para>Similar programs exist for Win32.</para>
      </sect2>

      <sect2>
        <title>Keywords used in template files</title>

        <para>The following are the global keywords used in the email template
        files.<variablelist>
            <varlistentry>
              <term>[hostname]</term>

              <listitem>
                <para>Client hostname, it known</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[repository]</term>

              <listitem>
                <para>Repository name</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[commitid] or [sessionid]</term>

              <listitem>
                <para>Session identifier</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[server_hostname]</term>

              <listitem>
                <para>Local hostname of server</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[user]</term>

              <listitem>
                <para>User who is performing the action</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[email]</term>

              <listitem>
                <para>Email address, as looked up from
                <command>CVSROOT/users</command></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[date]</term>

              <listitem>
                <para>Date/time of action</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[message]</term>

              <listitem>
                <para>Message associated with action, if any</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[module]</term>

              <listitem>
                <para>Module associated with action</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[begin_directory] .. [end_directory]</term>

              <listitem>
                <para>Lines between these tags (which must be on their own on
                the line) are repeated for each directory referenced by the
                operation.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[begin_file] .. [end_file]</term>

              <listitem>
                <para>Lines between these tags (which must be on their own on
                the line) are repeated for each file referenced by the
                operation. These tags can only exist inside begin/end
                directory tags.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[directory]</term>

              <listitem>
                <para>Current directory</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[filename]</term>

              <listitem>
                <para>Curent file</para>
              </listitem>
            </varlistentry>
          </variablelist></para>

        <para>Each type of template also has its own keywords that is
        uses:</para>

        <sect3>
          <title>commit emails</title>

          <variablelist>
            <varlistentry>
              <term>[old_revision]</term>

              <listitem>
                <para>Revision number of previous revision.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[new_revision]</term>

              <listitem>
                <para>Revision number of new revision.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[tag]</term>

              <listitem>
                <para>Tag for file.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[change_type]</term>

              <listitem>
                <para>Code for change made by this commit.. 'M', 'A',
                etc.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect3>

        <sect3>
          <title>tag emails</title>

          <variablelist>
            <varlistentry>
              <term>[tag_type]</term>

              <listitem>
                <para>Type of tag operation.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[action]</term>

              <listitem>
                <para>What is being done with the tag.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[tag]</term>

              <listitem>
                <para>Tag for file</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[revision]</term>

              <listitem>
                <para>File revision that is being tagged.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect3>

        <sect3>
          <title>notify emails</title>

          <variablelist>
            <varlistentry>
              <term>[bugid]</term>

              <listitem>
                <para>Bug identifier(s) associated with this
                notification.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[tag]</term>

              <listitem>
                <para>Tag name of file</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>[notify_type]</term>

              <listitem>
                <para>Notification type</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect3>
      </sect2>
    </sect1>

    <sect1 id="cvsignore">
      <title>Ignoring files via cvsignore</title>

      <para><indexterm>
          <primary>cvsignore (admin file), global</primary>
        </indexterm><indexterm>
          <primary>Global cvsignore</primary>
        </indexterm><indexterm>
          <primary>Ignoring files</primary>
        </indexterm> There are certain file names that frequently occur inside
      your working copy, but that you don't want to put under cvsnt control.
      Examples are all the object files that you get while you compile your
      sources. Normally, when you run <command>cvs update</command>, it prints
      a line for each file it encounters that it doesn't know about (<xref
      linkend="update-output" />).</para>

      <para>cvsnt has a list of files (or sh(1) file name patterns) that it
      should ignore while running <command>update</command>,
      <command>import</command> and <command>release</command>. This list is
      constructed in the following way.</para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>The list is initialized to include certain file name patterns:
          names associated with cvsnt administration, or with other common
          source control systems; common names for patch files, object files,
          archive files, and editor backup files; and other names that are
          usually artifacts of assorted utilities. Currently, the default list
          of ignored file name patterns is:</para>

          <para><indexterm>
              <primary>Ignored files</primary>
            </indexterm><indexterm>
              <primary>Automatically ignored files</primary>
            </indexterm><screen>. .. core RCSLOG tags TAGS RCS SCCS .make.state .nse_depinfo #* .#* cvslog.* ,*
CVS CVS.adm .del-* *.a *.olb *.o *.obj *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK
*.orig *.rej *.exe *.dll *.pdb *.lib *.ncb *.ilk *.exp .DS_Store _$* *$</screen></para>
        </listitem>

        <listitem>
          <para>The per-repository list in
          <command>$REAL_CVSROOT/CVSROOT/cvsignore</command> is appended to
          the list, if that file exists.</para>
        </listitem>

        <listitem>
          <para>The per-user list in <command>.cvsignore</command> in your
          home directory is appended to the list, if it exists.</para>
        </listitem>

        <listitem>
          <para>Any entries in the environment variable
          <command>$CVSIGNORE</command> is appended to the list.</para>
        </listitem>

        <listitem>
          <para>Any <command>-I</command> options given to cvsnt is
          appended.</para>
        </listitem>

        <listitem>
          <para>As cvsnt traverses through your directories, the contents of
          any <command>.cvsignore</command> will be appended to the list. The
          patterns found in <command>.cvsignore</command> are only valid for
          the directory that contains them, not for any
          sub-directories.</para>
        </listitem>
      </itemizedlist>

      <para>In any of the 5 places listed above, a single exclamation mark
      (<command>!</command>) clears the ignore list. This can be used if you
      want to store any file which normally is ignored by cvsnt.</para>

      <para>Specifying <command>-I !</command> to <command>cvs
      import</command> will import everything, which is generally what you
      want to do if you are importing files from a pristine distribution or
      any other source which is known to not contain any extraneous files.
      However, looking at the rules above you will see there is a fly in the
      ointment; if the distribution contains any <command>.cvsignore</command>
      files, then the patterns from those files will be processed even if
      <command>-I !</command> is specified. The only workaround is to remove
      the <command>.cvsignore</command> files in order to do the import.
      Because this is awkward, in the future <command>-I !</command> might be
      modified to override <command>.cvsignore</command> files in each
      directory.</para>

      <para>Note that the syntax of the ignore files consists of a series of
      lines, each of which contains a space separated list of filenames. This
      offers no clean way to specify filenames which contain spaces, but you
      can use a workaround like <command>foo?bar</command> to match a file
      named <command>foo bar</command> (it also matches
      <command>fooxbar</command> and the like). Also note that there is
      currently no way to specify comments.</para>
    </sect1>

    <sect1 id="checkoutlist">
      <title>The checkoutlist file</title>

      <para><indexterm>
          <primary>checkoutlist</primary>
        </indexterm> It may be helpful to use cvsnt to maintain your own files
      in the <command>CVSROOT</command> directory. For example, suppose that
      you have a script <command>logcommit.pl</command> which you run by
      including the following line in the <command>commitinfo</command>
      administrative file:</para>

      <para><screen>ALL   $REAL_CVSROOT/CVSROOT/logcommit.pl
</screen></para>

      <para>To maintain <command>logcommit.pl</command> with cvsnt you would
      add the following line to the <command>checkoutlist</command>
      administrative file:</para>

      <para><screen>
logcommit.pl
</screen></para>

      <para>The format of <command>checkoutlist</command> is one line for each
      file that you want to maintain using cvsnt, giving the name of the
      file.</para>

      <para>Files in checkoutlist must always be relative to and below
      CVSROOT. Attempting to checkout files outside these constraints is an
      error.</para>

      <para>After setting up <command>checkoutlist</command> in this fashion,
      the files listed there will function just like cvsnt's built-in
      administrative files. For example, when checking in one of the files you
      should get a message such as:</para>

      <para><screen>
cvs commit: Rebuilding administrative file database
</screen></para>

      <para>and the checked out copy in the <command>CVSROOT</command>
      directory should be updated.</para>

      <para>Note that listing <command>passwd</command> (<xref
      linkend="Authentication-server" />) in <command>checkoutlist</command>
      is not allowed for security reasons.</para>

      <para>For information about keeping a checkout out copy in a more
      general context than the one provided by
      <command>checkoutlist</command>, see <xref
      linkend="Keeping-a-checked-out-copy" />.</para>
    </sect1>

    <sect1 id="history-file">
      <title>The history file</title>

      <para><indexterm>
          <primary>History file</primary>
        </indexterm><indexterm>
          <primary>Log information, saving</primary>
        </indexterm> The file <command>$REAL_CVSROOT/CVSROOT/history</command>
      is used to log information for the <command>history</command> command
      (<xref linkend="history" />). This file must be created to turn on
      logging. </para>

      <para>The file format of the <command>history</command> file is
      documented only in comments in the cvsnt source code, but generally
      programs should use the <command>cvs history</command> command to access
      it anyway, in case the format changes with future releases of
      cvsnt.</para>

      <para>For new installations it is preferred to setup auditiing rather
      than use the history file. In a future release the history file will be
      deprecated.</para>
    </sect1>

    <sect1 id="shadow-file">
      <title>The shadow file</title>

      <indexterm>
        <primary>CVROOT/shadow</primary>
      </indexterm>

      <indexterm>
        <primary>Shadow file</primary>
      </indexterm>

      <para>The CVSROOT/shadow file is used by the checkout plugin to specify
      directories that will be automatically updated on checkout or
      tag.</para>

      <para>In order for the shadow file to have any effect the "Automatic
      checkout extension" plugin must be enabled in the CVSNT control
      panel.</para>

      <sect2 id="Keeping-a-checked-out-copy">
        <title>Keeping a checked out copy</title>

        <para><indexterm>
            <primary>Keeping a checked out copy</primary>
          </indexterm><indexterm>
            <primary>Checked out copy, keeping</primary>
          </indexterm><indexterm>
            <primary>Web pages, maintaining with CVS</primary>
          </indexterm> It is often useful to maintain a directory tree which
        contains files which correspond to the latest version in the
        repository. For example, other developers might want to refer to the
        latest sources without having to check them out, or you might be
        maintaining a web site with cvsnt and want every checkin to cause the
        files used by the web server to be updated.</para>

        <para>The way to do this is by having a line in the
        <command>CVSROOT/shadow</command>. Here is an example (this should all
        be on one line):</para>

        <para><screen>^cyclic-pages HEAD /u/www/local-docs</screen></para>

        <para>This will cause checkins to repository directories starting with
        <command>cyclic-pages</command> to update the checked out tree in
        <command>/u/www/local-docs</command>.</para>

        <para>Note that if the shadow copy does not exist already it will be
        created by the execution of the shadow command. Likewise if a shadow
        copy exists and new directories have been added to the module then
        these directories and files will also be checked out into the shadow
        copy. So it will always be a true representation of the current state
        of the module.</para>

        <para>The shadow file works only on the physical file system level
        (inside the repository). This means that a module specified in the
        regular expression must match a physical module name in order to be
        recognized.</para>

        <para>For example if you have created virtual modules inside the
        CVSROOT/modules file or CVSROOT/modules2 file you cannot specify such
        a module name in the shadow file.</para>
      </sect2>
    </sect1>

    <sect1 id="activescript">
      <title>ActiveScript support</title>

      <indexterm>
        <primary>ActiveScript support</primary>
      </indexterm>

      <indexterm>
        <primary>script.vbs</primary>

        <secondary>vbscript</secondary>
      </indexterm>

      <indexterm>
        <primary>script.js</primary>

        <secondary>javascript</secondary>
      </indexterm>

      <indexterm>
        <primary>script.pl</primary>

        <secondary>perlscript</secondary>
      </indexterm>

      <indexterm>
        <primary>script.rb</primary>

        <secondary>rubyscript</secondary>
      </indexterm>

      <para>On Windows platforms (Windows 2000 and later), cvsnt can use the
      builtin active scripting support to produce simple scripts.</para>

      <para>To enable this functionality, enable the 'ActiveScript Plugin'
      using the cvsnt control panel, and <command>cvs add</command> a file to
      the checked out CVSROOT as follows:</para>

      <itemizedlist>
        <listitem>
          <para><filename>script.vbs</filename> for VBScript support</para>
        </listitem>

        <listitem>
          <para><filename>script.js</filename> for JavaScript support</para>
        </listitem>

        <listitem>
          <para><filename>script.pl</filename> for PerlScript support</para>
        </listitem>

        <listitem>
          <para><filename>script.rb</filename> for RubyScript support</para>
        </listitem>
      </itemizedlist>

      <para>The scripting engine you intend to use must be installed on the
      server - only the VBScript engine is installed by default.</para>

      <para>Available functions are as follows:</para>

      <programlisting>init(command, current_date, hostname, username, virtual_repository, physical_repository, session_id, editor, user_variable_array, client_version, character_set)
close
taginfo(message,directory, file_array, action, tag)
verifymsg(directory, filename)
loginfo(message, status, directory, change_array)
history(history_type, workdir, revs, name, bugid, message, dummy)
notify(message, bugid, directory, notify_user, tag, notify_type, file)
precommit(name_list, message, directory)
postcommit(directory)
precommand(argument_list)
postcommand(directory)
premodule(module)
postmodule(module)
get_template(directory)
parse_keyword(keyword, directory, file, branch, author, printable_date, rcs_date, locker, state, version, name, bugid, commitid, global_properties, local_properties)
prercsdiff(file, directory, oldfile, newfile, diff_type, options, oldversion, newversion)
rcsdiff(file, directory, oldfile, newfile, diff, diff_type, options, oldversion, newversion, added, removed)</programlisting>

      <para>Functions should return 0 if successful. Arguments are strings,
      except where the name ends in _list which are arrays of strings, or
      _array, which are associative arrays (name=value).</para>

      <para>The exceptions to this is <filename>loginfo</filename>, which is
      passed an array of structures containing <varname>filename</varname>,
      <varname>rev_old</varname> and <varname>rev_new</varname>. Also the
      <function>get_template</function> and <function>parse_keyword</function>
      functions, which are expected to return a string or
      <literal>null</literal>.</para>

      <para>The script has access to a server object, called
      <classname>Server</classname>, which contains the following
      functions:</para>

      <programlisting>Trace(tracelevel,message)
Warning(message)
Error(message)</programlisting>

      <para>An example of all these functions is available in the cvsnt source
      tree, called <filename>script.vbs</filename> in the
      <filename>contrib_nt</filename> directory.</para>
    </sect1>

    <sect1 id="Variables">
      <title>Expansions in administrative files</title>

      <para><indexterm>
          <primary>Internal variables</primary>
        </indexterm><indexterm>
          <primary>Variables</primary>
        </indexterm> Sometimes in writing an administrative file, you might
      want the file to be able to know various things based on environment
      cvsnt is running in. There are several mechanisms to do that.</para>

      <para>To find the home directory of the user running cvsnt (from the
      <command>HOME</command> environment variable), use <command>~</command>
      followed by <command>/</command> or the end of the line. Likewise for
      the home directory of <varname>user</varname>, use
      <command>~<varname>user</varname></command>. These variables are
      expanded on the server machine, and don't get any reasonable expansion
      if pserver (<xref linkend="Password-authenticated" />) is in use;
      therefore user variables (see below) may be a better choice to customize
      behavior based on the user running cvsnt.</para>

      <para>One may want to know about various pieces of information internal
      to cvsnt. A cvsnt internal variable has the syntax
      <command>${<varname>variable</varname>}</command>, where
      <varname>variable</varname> starts with a letter and consists of
      alphanumeric characters and <command>_</command>. If the character
      following <varname>variable</varname> is a non-alphanumeric character
      other than <command>_</command>, the <command>{</command> and
      <command>}</command> can be omitted. The cvsnt internal variables
      are:</para>

      <variablelist>
        <varlistentry>
          <term>CVSROOT</term>

          <listitem>
            <para><indexterm>
                <primary>CVSROOT, internal variable</primary>
              </indexterm>This is the name of the current cvsnt repository as
            the user sees it.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>VIRTUAL_CVSROOT</term>

          <listitem>
            <para><indexterm>
                <primary>VIRTUAL_CVSROOT, internal variable</primary>
              </indexterm>This is the name of the current cvsnt repository as
            the user sees it.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>REAL_CVSROOT</term>

          <listitem>
            <para><indexterm>
                <primary>REAL_CVSROOT, internal variable</primary>
              </indexterm>This is the physical location of the current cvsnt
            repository. Avoid displaying this value to users as it is an
            information leak.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CVSEDITOR</term>

          <listitem>
            <para><indexterm>
                <primary>CVSEDITOR, internal variable</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>VISUAL</term>

          <listitem>
            <para><indexterm>
                <primary>VISUAL, internal variable</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>EDITOR</term>

          <listitem>
            <para><indexterm>
                <primary>EDITOR, internal variable</primary>
              </indexterm>These all expand to the same value, which is the
            editor that cvsnt is using. <xref linkend="Global-options" />, for
            how to specify this.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>USER</term>

          <listitem>
            <para><indexterm>
                <primary>USER, internal variable</primary>
              </indexterm>Username of the user running cvsnt (on the cvsnt
            server machine). When using pserver, this is the user specified in
            the repository specification which need not be the same as the
            username the server is running as (<xref
            linkend="Authentication-server" />).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CVSPID</term>

          <listitem>
            <para><indexterm>
                <primary>CVSPID, internal variable</primary>
              </indexterm>Parent process ID of the cvsnt process.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>SESSIONID</term>

          <listitem>
            <para><indexterm>
                <primary>SESSIONID, internal variable</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>COMMITID</term>

          <listitem>
            <para><indexterm>
                <primary>COMMITID, internal variable</primary>
              </indexterm>Unique Session ID of cvsnt process. This is a random
            string of printable characters that may be up to 256 characters
            long.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>If you want to pass a value to the administrative files which the
      user who is running cvsnt can specify, use a user variable. <indexterm>
          <primary>User variables</primary>
        </indexterm>To expand a user variable, the administrative file
      contains <command>$<varname>variable</varname></command>. To set a user
      variable, specify the global option <command>-s</command> to cvsnt, with
      argument
      <command><varname>variable</varname>=<varname>value</varname></command>.
      It may be particularly useful to specify this option via
      <command>.cvsrc</command> (<xref linkend="cvsrc" />).</para>

      <para>For example, if you want the administrative file to refer to a
      test directory you might create a user variable
      <command>TESTDIR</command>. Then if cvsnt is invoked as</para>

      <para><screen>
cvs -s TESTDIR=/work/local/tests
</screen></para>

      <para>and the administrative file contains <command>sh
      $TESTDIR/runtests</command>, then that string is expanded to <command>sh
      /work/local/tests/runtests</command>.</para>

      <para>Environment variables passed to administrative files are:</para>

      <variablelist>
        <title><indexterm>
            <primary>environment variables, passed to administrative
            files</primary>
          </indexterm></title>

        <varlistentry>
          <term>CVS_USER</term>

          <listitem>
            <para>The cvsnt-specific username provided by the user, if it can
            be provided (currently just for the pserver access method), and to
            the empty string otherwise. (CVS_USER and USER may differ when
            <command>$REAL_CVSROOT/CVSROOT/passwd</command> is used to map cvs
            usernames to system usernames.)</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="config">
      <title>The CVSROOT/config configuration file</title>

      <para><indexterm>
          <primary>config, in CVSROOT</primary>
        </indexterm><indexterm>
          <primary>CVSROOT/config</primary>
        </indexterm> The administrative file <command>config</command>
      contains various miscellaneous settings which affect the behavior of
      cvsnt. The syntax is slightly different from the other administrative
      files. Variables are not expanded. Lines which start with
      <command>#</command> are considered comments. Other lines consist of a
      keyword, <command>=</command>, and a value. Note that this syntax is
      very strict. Extraneous spaces or tabs are not permitted.</para>

      <para>Currently defined keywords are:</para>

      <variablelist>
        <title><indexterm>
            <primary>SystemAuth, in CVSROOT/config</primary>
          </indexterm></title>

        <varlistentry>
          <term>SystemAuth=<varname>value</varname></term>

          <listitem>
            <para>If <varname>value</varname> is <command>yes</command>, then
            pserver should check for users in the system's user database if
            not found in <command>CVSROOT/passwd</command>. If it is
            <command>no</command>, then all pserver users must exist in
            <command>CVSROOT/passwd</command>. The default is
            <command>yes</command>. For more on pserver, see <xref
            linkend="Password-authenticated" />.</para>

            <para><indexterm>
                <primary>TopLevelAdmin, in CVSROOT/config</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TopLevelAdmin=<varname>value</varname></term>

          <listitem>
            <para>Modify the <command>checkout</command> command to create a
            <command>CVS</command> directory at the top level of the new
            working directory, in addition to <command>CVS</command>
            directories created within checked-out directories. The default
            value is <command>no</command>.</para>

            <para>This option is useful if you find yourself performing many
            commands at the top level of your working directory, rather than
            in one of the checked out subdirectories. The
            <command>CVS</command> directory created there will mean you don't
            have to specify <command>CVSROOT</command> for each command. It
            also provides a place for the <command>CVS/Template</command> file
            (<xref linkend="Working-directory-storage" />).</para>

            <para><indexterm>
                <primary>AclMode, in CVSROOT/config</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>AclMode=value</term>

          <listitem>
            <para>Select the access control list mode. One of 3
            values:<itemizedlist>
                <listitem>
                  <para><command>none</command> - No extra access control is
                  done on this repository.</para>
                </listitem>

                <listitem>
                  <para><command>compat</command> (default) - Default access
                  mode is to allow access.</para>
                </listitem>

                <listitem>
                  <para><command>normal</command> - Default access mode is to
                  deny access.</para>

                  <para><indexterm>
                      <primary>LockDir, in CVSROOT/config</primary>
                    </indexterm></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LockDir=<varname>directory</varname></term>

          <listitem>
            <para>This option is ignored unless the lockserver is disabled. It
            is accepted only for compatibility with older systems. This option
            will be removed in the near future.</para>

            <para>Put cvsnt lock files in <varname>directory</varname> rather
            than directly in the repository. This is useful if you want to let
            users read from the repository while giving them write access only
            to <varname>directory</varname>, not to the repository. You need
            to create <varname>directory</varname>, but cvsnt will create
            subdirectories of <varname>directory</varname> as it needs them.
            For information on cvsnt locks, see <xref
            linkend="Concurrency" />.</para>

            <para>Before enabling the LockDir option, make sure that you have
            tracked down and removed any copies of cvsnt 1.9 or older. Such
            versions neither support LockDir, nor will give an error
            indicating that they don't support it. The result, if this is
            allowed to happen, is that some cvsnt users will put the locks one
            place, and others will put them another place, and therefore the
            repository could become corrupted. CVS 1.10 does not support
            LockDir but it will print a warning if run on a repository with
            LockDir enabled.</para>

            <para><indexterm>
                <primary>LockServer, in CVSROOT/config</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LockServer=<varname>hostname</varname>[:port]</term>

          <listitem>
            <para>Uses the cvsnt lock server to handle locking rather than
            using files in the repository. This is useful if you want to let
            users read from the repository while giving them write access only
            to <varname>directory</varname>, not to the repository. For
            information on cvsnt locks, see <xref linkend="Concurrency" />.
            cvsnt 2.0.15 and above use the LockServer by default and other
            methods of locking are depreciated. You can override this
            behaviour by using the line <command>LockServer=none</command>.
            Note however that future versions may not allow this override. See
            also <xref linkend="Lockserver" /></para>

            <para><indexterm>
                <primary>LogHistory, in CVSROOT/config</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>LogHistory=<varname>value</varname></term>

          <listitem>
            <para>Control what is logged to the
            <command>CVSROOT/history</command> file. Default of
            <command>TOFEWGCMAR</command> (or simply <command>all</command>)
            will log all transactions. Any subset of the default is legal.
            (For example, to only log transactions that modify the
            <command>*,v</command> files, use
            <command>LogHistory=TMAR</command>.)</para>

            <para><indexterm>
                <primary>RereadLogAfterVerify, in CVSROOT/config</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>RereadLogAfterVerify=<varname>value</varname></term>

          <listitem>
            <para>If enabled the log message parsed by
            <command>verifymsg</command> is reread after the script has run.
            The default behavoiur is to not reread this file.</para>

            <para><indexterm>
                <primary>Watcher, in CVSROOT/config</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Watcher=<varname>name</varname></term>

          <listitem>
            <para>Set a watcher who sees all edit/unedit/commit notifications
            via the <command>CVSROOT/notify</command> script. The watcher sees
            all notificaitons regardless of an existing edit/watch on the
            file, which for a large commit could be a lot of files. It is
            therefore recommended that the notify script completes as fast a
            possible. Using a custom trigger library or COM interface is
            recommended for best efficiency.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="Server-Configuration">
      <title>The server configuration files</title>

      <indexterm>
        <primary>Configuration, Server</primary>
      </indexterm>

      <indexterm>
        <primary>/etc/cvsnt/PServer</primary>
      </indexterm>

      <indexterm>
        <primary>Server configuration</primary>
      </indexterm>

      <para>The CVSNT global server configuration contains information with
      affects all repositories.</para>

      <para>On Win32, this information is stored in the registry and is
      normaly only manipulated via the cvsnt control panel. On Unix, a text
      file, normally <command>/etc/cvsnt/PServer</command> is used to store
      most of this information.</para>

      <para>See the <command>PServer.example</command> file for the list of
      current available settings.</para>
    </sect1>
  </appendix>

  <appendix id="Environment-variables">
    <title>All environment variables which affect CVS</title>

    <para><indexterm>
        <primary>Environment variables</primary>
      </indexterm><indexterm>
        <primary>Reference manual for variables</primary>
      </indexterm> This is a complete list of all environment variables that
    affect cvsnt.</para>

    <variablelist>
      <title><indexterm>
          <primary>CVSIGNORE, environment variable</primary>
        </indexterm></title>

      <varlistentry>
        <term>$CVSIGNORE</term>

        <listitem>
          <para>A whitespace-separated list of file name patterns that cvsnt
          should ignore. <xref linkend="cvsignore" />.</para>

          <para><indexterm>
              <primary>CVSWRAPPERS, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVSWRAPPERS</term>

        <listitem>
          <para>A whitespace-separated list of file name patterns that cvsnt
          should treat as wrappers. <xref linkend="Wrappers" />.</para>

          <para><indexterm>
              <primary>CVSREAD, environment variable</primary>
            </indexterm><indexterm>
              <primary>Read-only files, and CVSREAD</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVSREAD</term>

        <listitem>
          <para>If this is set, <command>checkout</command> and
          <command>update</command> will try hard to make the files in your
          working directory read-only. When this is not set, the default
          behavior is to permit modification of your working files.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVSUMASK</term>

        <listitem>
          <para>Controls permissions of files in the repository. See <xref
          linkend="File-permissions" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVSROOT</term>

        <listitem>
          <para>Should contain the full pathname to the root of the cvsnt
          source repository (where the rcs files are kept). This information
          must be available to cvsnt for most commands to execute; if
          <command>$CVSROOT</command> is not set, or if you wish to override
          it for one invocation, you can supply it on the command line:
          <command>cvs -d cvsroot cvs_command...</command> Once you have
          checked out a working directory, cvsnt stores the appropriate root
          (in the file <command>CVS/Root</command>), so normally you only need
          to worry about this when initially checking out a working
          directory.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$EDITOR</term>

        <term>$CVSEDITOR</term>

        <term>$VISUAL</term>

        <listitem>
          <para>Specifies the program to use for recording log messages during
          commit. <command>$CVSEDITOR</command> overrides
          <command>$EDITOR</command>. See <xref
          linkend="Committing-your-changes" />.</para>

          <para><indexterm>
              <primary>PATH, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$PATH</term>

        <listitem>
          <para>If <command>$rcsBIN</command> is not set, and no path is
          compiled into cvsnt, it will use <command>$PATH</command> to try to
          find all programs it uses.</para>

          <para><indexterm>
              <primary>HOME, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$HOME</term>

        <listitem>
          <para><indexterm>
              <primary>HOMEPATH, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$HOMEPATH</term>

        <listitem>
          <para><indexterm>
              <primary>HOMEDRIVE, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$HOMEDRIVE</term>

        <listitem>
          <para>Used to locate the directory where the
          <command>.cvsrc</command> file, and other such files, are searched.
          On Unix, cvsnt just checks for <command>HOME</command>. On Windows
          NT, the system will set <command>HOMEDRIVE</command>, for example to
          <command>d:</command> and <command>HOMEPATH</command>, for example
          to <command>\joe</command>. On Windows 95, you'll probably need to
          set <command>HOMEDRIVE</command> and <command>HOMEPATH</command>
          yourself.</para>

          <para><indexterm>
              <primary>CVS_EXT, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVS_EXT</term>

        <listitem>
          <para><indexterm>
              <primary>CVS_RSH, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVS_RSH</term>

        <listitem>
          <para>Specifies the external program which cvsnt connects with, when
          <command>:ext:</command> access method is specified. This replaces
          the <command>CVS_RSH</command> environment used in older
          implementations of cvs.</para>

          <para>The <command>CVS_EXT</command> variable parsed as a formatting
          string specifying the command to pass to invoke the remote server.
          The default string is: <command>ssh -l %u %h</command> The
          <command>%u</command> parameter is replaced with the username
          specified in the CVSROOT (or the current username if none is
          specified) and the <command>%h</command> parameter is replaced with
          the hostname specified in the CVSROOT.</para>

          <para>The CVS_EXT string has the string ' cvs server' appended to
          it, and this is then passed to the command processor for
          execution.</para>

          <para><xref linkend="Connecting-via-ssh" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVS_CLIENT_PORT</term>

        <listitem>
          <para>Used in client-server mode when accessing the server via
          Kerberos, GSSAPI, or cvsnt's password authentication if the port is
          not specified in $CVSROOT. <xref
          linkend="Remote-repositories" /></para>

          <para><indexterm>
              <primary>CVS_CLIENT_LOG, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVS_CLIENT_LOG</term>

        <listitem>
          <para>Used for debugging only in client-server mode. If set,
          everything sent to the server is logged into
          <command><command>$CVS_CLIENT_LOG</command>.in</command> and
          everything sent from the server is logged into
          <command><command>$CVS_CLIENT_LOG</command>.out</command>.</para>

          <para><indexterm>
              <primary>CVS_SERVER_LOB, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVS_SERVER_LOG</term>

        <listitem>
          <para>Used for debugging only in client-server mode. If set,
          everything sent to the server is logged into
          <command><command>$CVS_SERVER_LOG</command>.in</command> and
          everything sent from the server is logged into
          <command><command>$CVS_SERVER_LOG</command>.out</command>.</para>

          <para><indexterm>
              <primary>CVS_SERVER_SLEEP, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVS_SERVER_SLEEP</term>

        <listitem>
          <para>Used only for debugging the server side in client-server mode.
          If set, delays the start of the server child process the specified
          amount of seconds so that you can attach to it with a
          debugger.</para>

          <para><indexterm>
              <primary>CVS_DIR, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVS_DIR</term>

        <listitem>
          <para>Used by the client to find the lockserver when automatically
          executing it. If not defined the client looks in the system
          path.</para>

          <para><indexterm>
              <primary>CVSLIB, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVSLIB</term>

        <listitem>
          <para>Location of the libraries and protocol DLLs used by cvsnt. Not
          used on Win32.</para>

          <para><indexterm>
              <primary>CVSCONF, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$CVSCONF</term>

        <listitem>
          <para>Location of the global configuration settings file. Not used
          on Win32.</para>

          <para><indexterm>
              <primary>COMSPEC, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$COMSPEC</term>

        <listitem>
          <para>Used under DOS/Windows and OS/2 only. It specifies the name of
          the command interpreter and defaults to cmd.exe.</para>

          <para><indexterm>
              <primary>TMPDIR, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$TMPDIR</term>

        <listitem>
          <para><indexterm>
              <primary>TMP, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$TMP</term>

        <listitem>
          <para><indexterm>
              <primary>TEMP, environment variable</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$TEMP</term>

        <listitem>
          <para><indexterm>
              <primary>Temporary files, location of</primary>
            </indexterm>Directory in which temporary files are located. The
          cvsnt server uses <command>TMPDIR</command>. <xref
          linkend="Global-options" />, for a description of how to specify
          this. Some parts of cvsnt will always use <command>/tmp</command>
          (via the <command>tmpnam</command> function provided by the
          system).</para>

          <para>On Windows NT, <command>TMP</command> is used (via the
          <command>_tempnam</command> function provided by the system).</para>

          <para>The <command>patch</command> program which is used by the
          cvsnt client uses <command>TMPDIR</command>, and if it is not set,
          uses <command>/tmp</command> (at least with GNU patch 2.1). Note
          that if your server and client are both running cvsnt 1.9.10 or
          later, cvsnt will not invoke an external <command>patch</command>
          program.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </appendix>

  <appendix id="Compatibility">
    <title>Compatibility between CVS Versions</title>

    <para><indexterm>
        <primary>CVS, versions of</primary>
      </indexterm><indexterm>
        <primary>Versions, of CVS</primary>
      </indexterm><indexterm>
        <primary>Compatibility, between CVS versions</primary>
      </indexterm> It is always possible to upgrade from an earlier version of
    CVS or CVSNT to a newer version. Downgrading however is not guaranteed to
    work. In particular downgrading from CVSNT 2.x to CVS 1.x will require
    some work on the repository format as many features are unsupported in the
    older version.</para>

    <para>The working directory format is compatible going back to cvsnt 1.5.
    It did change between cvsnt 1.3 and cvsnt 1.5. If you run cvsnt 1.5 or
    newer on a working directory checked out with cvsnt 1.3, cvsnt will
    convert it, but to go back to cvsnt 1.3 you need to check out a new
    working directory with cvsnt 1.3.</para>

    <para>Support for the Entries.Extra file varies between versions, however
    this should not normally affect client operations. Client versions of
    CVSNT before 2.0.55 used a <command>Baserev</command> file to store edit
    information. If downgrading a client existing edits may be lost.</para>

    <para>The remote protocol is interoperable going back to cvsnt 1.5, but no
    further (1.5 was the first official release with the remote protocol, but
    some older versions might still be floating around). In many cases you
    need to upgrade both the client and the server to take advantage of new
    features and bugfixes, however.</para>

    <para>When changing between platforms care should be taken to avoid
    platform-specific issues. RCS files are always in the same format and are
    interoperable, however the CVSROOT control files are often written
    specifically for the platform, and will need to be updated.</para>

    <para><indexterm>
        <primary>cygwin, compatibility issues</primary>
      </indexterm> The Win32 port of CVSNT is a fully native application and
    does not require cygwin. It is not recommended that cygwin CVS and CVSNT
    are installed on the same machine as confusion and incompatibities may
    arise between versions.</para>

    <para>CVSNT obeys the CYGWIN environment variable when deciding where to
    store extended permissions. However its default is ntea not ntsec, so this
    will be needed to be specified if using both environments. The recommended
    setting is CYGWIN="ntea nontsec tty" which will force both CYGWIN and
    CVSNT to use the same permissions structure.</para>
  </appendix>

  <appendix id="Troubleshooting">
    <title>Troubleshooting</title>

    <para>If you are having trouble with cvsnt, this appendix may help. If
    there is a particular error message which you are seeing, then you can
    look up the message alphabetically. If not, you can look through the
    section on other problems to see if your problem is mentioned
    there.</para>

    <sect1 id="Error-messages">
      <title>Partial list of error messages</title>

      <para>Here is a partial list of error messages that you may see from
      cvsnt. It is not a complete list--cvsnt is capable of printing many,
      many error messages, often with parts of them supplied by the operating
      system, but the intention is to list the common and/or potentially
      confusing error messages.</para>

      <para>The messages are alphabetical, but introductory text such as
      <command>cvs update: </command> is not considered in ordering
      them.</para>

      <para>In some cases the list includes messages printed by old versions
      of cvsnt (partly because users may not be sure which version of cvsnt
      they are using at any particular moment).</para>

      <variablelist>
        <varlistentry>
          <term>cvs <varname>command</varname>: authorization failed: server
          <varname>host</varname> rejected access</term>

          <listitem>
            <para>This is a generic response when trying to connect to a
            pserver server which chooses not to provide a specific reason for
            denying authorization. Check that the username and password
            specified are correct and that the <command>CVSROOT</command>
            specified is allowed by <command>-allow-root</command> in
            <command>inetd.conf</command>. See <xref
            linkend="Password-authenticated" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>file</varname>:<varname>line</varname>: Assertion
          '<varname>text</varname>' failed</term>

          <listitem>
            <para>The exact format of this message may vary depending on your
            system. It indicates a bug in cvsnt, which can be handled as
            described in <xref linkend="BUGS" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs <varname>command</varname>: conflict: removed
          <varname>file</varname> was modified by second party</term>

          <listitem>
            <para>This message indicates that you removed a file, and someone
            else modified it. To resolve the conflict, first run <command>cvs
            add <varname>file</varname></command>. If desired, look at the
            other party's modification to decide whether you still want to
            remove it. If you don't want to remove it, stop here. If you do
            want to remove it, proceed with <command>cvs remove
            <varname>file</varname></command> and commit your removal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cannot change permissions on temporary directory</term>

          <listitem>
            <para><screen>Operation not permitted
</screen> This message has been happening in a non-reproducible, occasional
            way when we run the client/server testsuite, both on Red Hat Linux
            3.0.3 and 4.1. We haven't been able to figure out what causes it,
            nor is it known whether it is specific to linux (or even to this
            particular machine!). If the problem does occur on other unices,
            <command>Operation not permitted</command> would be likely to read
            <command>Not owner</command> or whatever the system in question
            uses for the unix <command>EPERM</command> error. If you have any
            information to add, please let us know as described in <xref
            linkend="BUGS" />. If you experience this error while using cvsnt,
            retrying the operation which produced it should work fine.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [server aborted]: Cannot check out files into the
          repository itself</term>

          <listitem>
            <para>The obvious cause for this message (especially for
            non-client/server cvsnt) is that the cvsnt root is, for example,
            <command>/usr/local/cvsroot</command> and you try to check out
            files when you are in a subdirectory, such as
            <command>/usr/local/cvsroot/test</command>. However, there is a
            more subtle cause, which is that the temporary directory on the
            server is set to a subdirectory of the root (which is also not
            allowed). If this is the problem, set the temporary directory to
            somewhere else, for example <command>/var/tmp</command>; see
            <command>TMPDIR</command> in <xref
            linkend="Environment-variables" />, for how to set the temporary
            directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cannot open CVS/Entries for reading: No such file or
          directory</term>

          <listitem>
            <para>This generally indicates a cvsnt internal error, and can be
            handled as with other cvsnt bugs (<xref linkend="BUGS" />).
            Usually there is a workaround--the exact nature of which would
            depend on the situation but which hopefully could be figured
            out.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [init aborted]: cannot open CVS/Root: No such file or
          directory</term>

          <listitem>
            <para>This message is harmless. Provided it is not accompanied by
            other errors, the operation has completed successfully. This
            message should not occur with current versions of cvsnt, but it is
            documented here for the benefit of cvsnt 1.9 and older.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [checkout aborted]: cannot rename file
          <varname>file</varname> to CVS/,,<varname>file</varname>: Invalid
          argument</term>

          <listitem>
            <para>This message has been reported as intermittently happening
            with cvsnt 1.9 on Solaris 2.5. The cause is unknown; if you know
            more about what causes it, let us know as described in <xref
            linkend="BUGS" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [<varname>command</varname> aborted]: cannot start server
          via rcmd</term>

          <listitem>
            <para>This, unfortunately, is a rather nonspecific error message
            which cvsnt 1.9 will print if you are running the cvsnt client and
            it is having trouble connecting to the server. Current versions of
            cvsnt should print a much more specific error message. If you get
            this message when you didn't mean to run the client at all, you
            probably forgot to specify <command>:local:</command>, as
            described in <xref linkend="Repository" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>ci: <varname>file</varname>,v: bad diff output line: Binary
          files - and /tmp/T2a22651 differ</term>

          <listitem>
            <para>cvsnt 1.9 and older will print this message when trying to
            check in a binary file if rcs is not correctly installed. Re-read
            the instructions that came with your rcs distribution and the
            install file in the cvsnt distribution. Alternately, upgrade to a
            current version of cvsnt, which checks in files itself rather than
            via rcs.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs checkout: could not check out
          <varname>file</varname></term>

          <listitem>
            <para>With cvsnt 1.9, this can mean that the <command>co</command>
            program (part of rcs) returned a failure. It should be preceded by
            another error message, however it has been observed without
            another error message and the cause is not well-understood. With
            the current version of cvsnt, which does not run
            <command>co</command>, if this message occurs without another
            error message, it is definitely a cvsnt bug (<xref
            linkend="BUGS" />).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [login aborted]: could not find out home directory</term>

          <listitem>
            <para>This means that you need to set the environment variables
            that cvsnt uses to locate your home directory. See the discussion
            of <command>HOME</command>, <command>HOMEDRIVE</command>, and
            <command>HOMEPATH</command> in <xref
            linkend="Environment-variables" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs update: could not merge revision <varname>rev</varname> of
          <varname>file</varname>: No such file or directory</term>

          <listitem>
            <para>cvsnt 1.9 and older will print this message if there was a
            problem finding the <command>rcsmerge</command> program. Make sure
            that it is in your <command>PATH</command>, or upgrade to a
            current version of cvsnt, which does not require an external
            <command>rcsmerge</command> program.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [update aborted]: could not patch <varname>file</varname>:
          No such file or directory</term>

          <listitem>
            <para>This means that there was a problem finding the
            <command>patch</command> program. Make sure that it is in your
            <command>PATH</command>. Note that despite appearances the message
            is <emphasis>not</emphasis> referring to whether it can find
            <varname>file</varname>. If both the client and the server are
            running a current version of cvsnt, then there is no need for an
            external patch program and you should not see this message. But if
            either client or server is running cvsnt 1.9, then you need
            <command>patch</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs update: could not patch <varname>file</varname>; will
          refetch</term>

          <listitem>
            <para>This means that for whatever reason the client was unable to
            apply a patch that the server sent. The message is nothing to be
            concerned about, because inability to apply the patch only slows
            things down and has no effect on what cvsnt does.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>dying gasps from <varname>server</varname> unexpected</term>

          <listitem>
            <para>There is a known bug in the server for CVS 1.9.18 and older
            which can cause this. For me, this was reproducible if I used the
            <command>-t</command> global option. It was fixed by Andy Piper's
            14 Nov 1997 change to src/filesubr.c, if anyone is curious. If you
            see the message, you probably can just retry the operation which
            failed, or if you have discovered information concerning its
            cause, please let us know as described in <xref
            linkend="BUGS" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>end of file from server (consult above messages if any)</term>

          <listitem>
            <para>The most common cause for this message is if you are using
            an external <command>rsh</command> program and it exited with an
            error. In this case the <command>rsh</command> program should have
            printed a message, which will appear before the above message. For
            more information on setting up a cvsnt client and server, see
            <xref linkend="Remote-repositories" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [update aborted]: EOF in key in rcs file
          <varname>file</varname>,v</term>

          <term>cvs [checkout aborted]: EOF while looking for end of string in
          rcs file <varname>file</varname>,v</term>

          <listitem>
            <para>This means that there is a syntax error in the given rcs
            file. Note that this might be true even if rcs can read the file
            OK; cvsnt does more error checking of errors in the rcs file. That
            is why you may see this message when upgrading from CVS 1.9 to CVS
            1.10. The likely cause for the original corruption is hardware,
            the operating system, or the like. Of course, if you find a case
            in which cvsnt seems to corrupting the file, by all means report
            it, (<xref linkend="BUGS" />). There are quite a few variations of
            this error message, depending on exactly where in the rcs file
            cvsnt finds the syntax error.</para>

            <para><indexterm>
                <primary>mkmodules</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs commit: Executing 'mkmodules'</term>

          <listitem>
            <para>This means that your repository is set up for a version of
            cvsnt prior to cvsnt 1.8. When using cvsnt 1.8 or later, the above
            message will be preceded by</para>

            <para><screen>
cvs commit: Rebuilding administrative file database
</screen></para>

            <para>If you see both messages, the database is being rebuilt
            twice, which is unnecessary but harmless. If you wish to avoid the
            duplication, and you have no versions of cvsnt 1.7 or earlier in
            use, remove <command>-i mkmodules</command> every place it appears
            in your <command>modules</command> file. For more information on
            the <command>modules</command> file, see <xref
            linkend="modules" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>missing author</term>

          <listitem>
            <para>Typically this can happen if you created an rcs file with
            your username set to empty. cvsnt will, bogusly, create an illegal
            rcs file with no value for the author field. The solution is to
            make sure your username is set to a non-empty value and re-create
            the rcs file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [checkout aborted]: no such tag
          <varname>tag</varname></term>

          <listitem>
            <para>This message means that cvsnt isn't familiar with the tag
            <varname>tag</varname>. Usually this means that you have mistyped
            a tag name; however there are (relatively obscure) cases in which
            cvsnt will require you to try a few other cvsnt commands involving
            that tag, before you find one which will cause cvsnt to update the
            <command>val-tags</command> file; see discussion of val-tags in
            <xref linkend="File-permissions" />. You only need to worry about
            this once for a given tag; when a tag is listed in
            <command>val-tags</command>, it stays there. Note that using
            <command>-f</command> to not require tag matches does not override
            this check; see <xref linkend="Common-options" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>*PANIC* administration files missing</term>

          <listitem>
            <para>This typically means that there is a directory named cvsnt
            but it does not contain the administrative files which cvsnt puts
            in a CVS directory. If the problem is that you created a CVS
            directory via some mechanism other than cvsnt, then the answer is
            simple, use a name other than cvsnt. If not, it indicates a cvsnt
            bug (<xref linkend="BUGS" />).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>rcs error: Unknown option: -x,v/</term>

          <listitem>
            <para>This message will be followed by a usage message for rcs. It
            means that you have an old version of rcs (probably supplied with
            your operating system), as well as an old version of cvsnt. CVS
            1.9.18 and earlier only work with rcs version 5 and later; current
            versions of cvsnt do not run rcs programs.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [server aborted]: received broken pipe signal</term>

          <listitem>
            <para>This message seems to be caused by a hard-to-track-down bug
            in cvsnt or the systems it runs on (we don't know--we haven't
            tracked it down yet!). It seems to happen only after a cvsnt
            command has completed, and you should be able to just ignore the
            message. However, if you have discovered information concerning
            its cause, please let us know as described in <xref
            linkend="BUGS" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Too many arguments!</term>

          <listitem>
            <para>This message is typically printed by the
            <command>log.pl</command> script which is in the
            <command>contrib</command> directory in the cvsnt source
            distribution. In some versions of cvsnt, <command>log.pl</command>
            has been part of the default cvsnt installation. The
            <command>log.pl</command> script gets called from the
            <command>loginfo</command> administrative file. Check that the
            arguments passed in <command>loginfo</command> match what your
            version of <command>log.pl</command> expects. In particular, the
            <command>log.pl</command> from cvsnt 1.3 and older expects the
            logfile as an argument whereas the <command>log.pl</command> from
            cvsnt 1.5 and newer expects the logfile to be specified with a
            <command>-f</command> option. Of course, if you don't need
            <command>log.pl</command> you can just comment it out of
            <command>loginfo</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [update aborted]: unexpected EOF reading
          <varname>file</varname>,v</term>

          <listitem>
            <para>See <command>EOF in key in rcs file</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs [login aborted]: unrecognized auth response from
          <varname>server</varname></term>

          <listitem>
            <para>This message typically means that the server is not set up
            properly. For example, if <command>inetd.conf</command> points to
            a nonexistent cvs executable. To debug it further, find the log
            file which inetd writes (<command>/var/log/messages</command> or
            whatever inetd uses on your system). For details, see <xref
            linkend="Connection" />, and <xref
            linkend="Authentication-server" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs server: cannot open /root/.cvsignore: Permission
          denied</term>

          <term>cvs [server aborted]: can't chdir(/root): Permission
          denied</term>

          <listitem>
            <para>See <xref linkend="Connection" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs commit: Up-to-date check failed for
          `<varname>file</varname>'</term>

          <listitem>
            <para>This means that someone else has committed a change to that
            file since the last time that you did a <command>cvs
            update</command>. So before proceeding with your <command>cvs
            commit</command> you need to <command>cvs update</command>. cvsnt
            will merge the changes that you made and the changes that the
            other person made. If it does not detect any conflicts it will
            report <command>M <varname>file</varname></command> and you are
            ready to <command>cvs commit</command>. If it detects conflicts it
            will print a message saying so, will report <command>C
            <varname>file</varname></command>, and you need to manually
            resolve the conflict. For more details on this process see <xref
            linkend="Conflicts-example" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Usage: diff3 [-exEX3 [-i | -m] [-L label1 -L label3]] file1
          file2 file3</term>

          <listitem>
            <para><screen>
Only one of [exEX3] allowed
</screen> This indicates a problem with the installation of
            <command>diff3</command> and <command>rcsmerge</command>.
            Specifically <command>rcsmerge</command> was compiled to look for
            GNU diff3, but it is finding unix diff3 instead. The exact text of
            the message will vary depending on the system. The simplest
            solution is to upgrade to a current version of cvsnt, which does
            not rely on external <command>rcsmerge</command> or
            <command>diff3</command> programs.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>warning: unrecognized response `<varname>text</varname>' from
          cvs server</term>

          <listitem>
            <para>If <varname>text</varname> contains a valid response (such
            as <command>ok</command>) followed by an extra carriage return
            character (on many systems this will cause the second part of the
            message to overwrite the first part), then it probably means that
            you are using the <command>:ext:</command> access method with a
            version of rsh, such as most non-unix rsh versions, which does not
            by default provide a transparent data stream. In such cases you
            probably want to try <command>:server:</command> instead of
            <command>:ext:</command>. If <varname>text</varname> is something
            else, this may signify a problem with your cvsnt server.
            Double-check your installation against the instructions for
            setting up the cvsnt server.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs commit: [<varname>time</varname>] waiting for
          <varname>user</varname>'s lock in
          <varname>directory</varname></term>

          <listitem>
            <para>This is a normal message, not an error. See <xref
            linkend="Concurrency" />, for more details.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cvs commit: warning: editor session failed</term>

          <listitem>
            <para><indexterm>
                <primary>Exit status, of editor</primary>
              </indexterm>This means that the editor which cvsnt is using
            exits with a nonzero exit status. Some versions of vi will do this
            even when there was not a problem editing the file. If so, point
            the <command>CVSEDITOR</command> environment variable to a small
            script such as:</para>

            <para><screen>
#!/bin/sh
vi $*
exit 0
</screen></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="Connection">
      <title>Trouble making a connection to a CVS server</title>

      <para>This section concerns what to do if you are having trouble making
      a connection to a cvsnt server. If you are running the cvsnt command
      line client running on Windows, first upgrade the client to cvsnt 1.9.12
      or later. The error reporting in earlier versions provided much less
      information about what the problem was. If the client is non-Windows,
      cvsnt 1.9 should be fine.</para>

      <para>If the error messages are not sufficient to track down the
      problem, the next steps depend largely on which access method you are
      using.</para>

      <variablelist>
        <title><indexterm>
            <primary>:ext:, troubleshooting</primary>
          </indexterm></title>

        <varlistentry>
          <term>:ext:</term>

          <listitem>
            <para>Try running the ssh program from the command line. For
            example: "ssh servername cvs -v" should print cvsnt version
            information. If this doesn't work, you need to fix it before you
            can worry about cvsnt problems.</para>

            <para><indexterm>
                <primary>:server:, troubleshooting</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>:server:</term>

          <listitem>
            <para>You don't need a command line rsh program to use this access
            method, but if you have an rsh program around, it may be useful as
            a debugging tool. Follow the directions given for :ext:.</para>

            <para><indexterm>
                <primary>:pserver:, troubleshooting</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>:pserver:</term>

          <listitem>
            <para>Errors along the lines of "connection refused" typically
            indicate that inetd isn't even listening for connections on port
            2401 whereas errors like "connection reset by peer" or "recv()
            from server: EOF" typically indicate that inetd is listening for
            connections but is unable to start cvsnt (this is frequently
            caused by having an incorrect path in
            <command>inetd.conf</command>). "unrecognized auth response"
            errors are caused by a bad command line in
            <command>inetd.conf</command>, typically an invalid option or
            forgetting to put the <command>authserver</command> command at the
            end of the line. Another less common problem is invisible control
            characters that your editor "helpfully" added without you
            noticing.</para>

            <para>One good debugging tool is to "telnet servername 2401".
            After connecting, send any text (for example "foo" followed by
            return). If cvsnt is working correctly, it will respond
            with</para>

            <para><screen>cvs [authserver aborted]: bad auth protocol start: foo
</screen></para>

            <para>If instead you get:</para>

            <para><screen>
Usage: cvs [cvs-options] command [command-options-and-arguments]
...
</screen></para>

            <para>then you're missing the <command>authserver</command>
            command at the end of the line in <command>inetd.conf</command>;
            check to make sure that the entire command is on one line and that
            it's complete.</para>

            <para>Likewise, if you get something like:</para>

            <para><screen>
Unknown command: `authserver'

CVS commands are:
        add          Add a new file/directory to the repository
...
</screen></para>

            <para>then you've misspelled <command>authserver</command> in some
            way. If it isn't obvious, check for invisible control characters
            (particularly carriage returns) in
            <command>inetd.conf</command>.</para>

            <para>If it fails to work at all, then make sure inetd is working
            right. Change the invocation in <command>inetd.conf</command> to
            run the echo program instead of cvs. For example:</para>

            <para><screen>
2401  stream  tcp  nowait  root /bin/echo echo hello
</screen></para>

            <para>After making that change and instructing inetd to re-read
            its configuration file, "telnet servername 2401" should show you
            the text hello and then the server should close the connection. If
            this doesn't work, you need to fix it before you can worry about
            cvsnt problems.</para>

            <para>On AIX systems, the system will often have its own program
            trying to use port 2401. This is AIX's problem in the sense that
            port 2401 is registered for use with cvsnt. I hear that there is
            an AIX patch available to address this problem.</para>

            <para>Another good debugging tool is the <command>-d</command>
            (debugging) option to inetd. Consult your system documentation for
            more information.</para>

            <para>If you seem to be connecting but get errors like:</para>

            <para><screen>
cvs server: cannot open /root/.cvsignore: Permission denied
cvs [server aborted]: can't chdir(/root): Permission denied
</screen></para>

            <para>then you probably haven't specified <command>-f</command> in
            <command>inetd.conf</command>.</para>

            <para>If you can connect successfully for a while but then can't,
            you've probably hit inetd's rate limit. (If inetd receives too
            many requests for the same service in a short period of time, it
            assumes that something is wrong and temporarily disables the
            service.) Check your inetd documentation to find out how to adjust
            the rate limit (some versions of inetd have a single rate limit,
            others allow you to set the limit for each service
            separately.)</para>

            <indexterm>
              <primary>:gserver:, troublshooting</primary>
            </indexterm>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>:gserver:</term>

          <listitem>
            <para>If you cannot connect using gserver, ensure that your
            kerberos installation is correctly configured. You will need a
            working PAM configuraiton if your system uses that, and
            nsswitch.conf may need to be configured to recognise kerberos
            users.</para>

            <para>Kerberos is rather difficult to configure, and it is beyond
            the scope of this manual. There are many resources on the internet
            to help you with this.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>
  </appendix>

  <appendix id="Credits">
    <title>Credits</title>

    <para><indexterm>
        <primary>Contributors (manual)</primary>
      </indexterm><indexterm>
        <primary>Credits (manual)</primary>
      </indexterm>March Hare Software Ltd thank the many contributors to the
    open Source CVS, CVSNT, CVSWEB, CVSWEBNT, WINCVS, TORTOISECVS, and
    BUGZILLA projects for their tremendous effort and support.</para>

    <para>In particular Tony Hoyle has been instrumental in the development of
    CVSNT and this manual.</para>

    <para>For a more complete list of who has contributed to this manual see
    the file <command>doc/ChangeLog</command> in the cvsnt source
    distribution.</para>
  </appendix>

  <appendix id="BUGS">
    <title>Dealing with bugs or getting help</title>

    <para><indexterm>
        <primary>Bugs in this manual or CVS</primary>
      </indexterm>Neither cvsnt nor this manual is perfect, and they probably
    never will be. If you are having trouble using cvsnt, or think you have
    found a bug, there are a number of things you can do about it. Note that
    if the manual is unclear, that can be considered a bug in the manual, so
    these problems are often worth doing something about as well as problems
    with cvsnt itself.</para>

    <para><indexterm>
        <primary>Reporting bugs</primary>
      </indexterm><indexterm>
        <primary>Bugs, reporting</primary>
      </indexterm><indexterm>
        <primary>Errors, reporting</primary>
      </indexterm></para>

    <itemizedlist mark="bullet">
      <listitem>
        <para>March Hare Software provide worldwide support including toll
        free numbers for telephone support in the USA, UK and Australia.
        Security update notification, patches, installation and training are
        also included. March Hare can guarantee this support because the
        people who have been developing CVS since 1999 work for us.</para>

        <para>At the time of writing, quality-assured builds of CVSNT are 
         available from US$152 with many additional integrations (eg: Bugzilla,
         Mantis, Jira, Visual Studio NET) and extensive documentation and a 
         range of support SLAs (Service Level Agreements) are available for 
         an additional change.  On site services such as training and installation
         are also available worldwide.</para>
      </listitem>

      <listitem>
        <para>cvsnt has an active network of volunteers. If you want to help
        them to fix any bugs that you report please report as much information
        as possible about your system and which version of cvsnt that you are
        using on the CVSNT newsgroup <screen>news://news.cvsnt.org/support.cvsnt</screen>
        or <screen>http://www.cvsnt.org/cgi-bin/mailman/listinfo/cvsnt</screen>
        .</para>
      </listitem>

      <listitem>
        <para>If you got cvsnt through a distributor, such as an operating
        system vendor or a vendor of freeware cd-roms, you may wish to see
        whether the distributor provides support. Often, they will provide no
        support or minimal support, but this may vary from distributor to
        distributor.</para>
      </listitem>

      <listitem>
        <para>If you have the skills and time to do so, you may wish to fix
        the bug yourself. If you wish to submit your fix for inclusion in
        future releases of cvsnt.</para>
      </listitem>

      <listitem>
        <para>There may be resources on the net which can help. A good place
        to start is:</para>

        <para><screen>http://www.cvsnt.org</screen></para>
      </listitem>
    </itemizedlist>
  </appendix>

  <index id="Index"></index>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:1
sgml-indent-data:nil
End:
-->
